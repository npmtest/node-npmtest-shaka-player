{"/home/travis/build/npmtest/node-npmtest-shaka-player/test.js":"/* istanbul instrument in package npmtest_shaka_player */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-shaka-player/lib.npmtest_shaka_player.js":"/* istanbul instrument in package npmtest_shaka_player */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_shaka_player = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_shaka_player = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-shaka-player/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-shaka-player && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_shaka_player */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_shaka_player\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_shaka_player.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_shaka_player.rollup.js'] =\n            local.assetsDict['/assets.npmtest_shaka_player.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_shaka_player.__dirname + '/lib.npmtest_shaka_player.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/dist/shaka-player.compiled.js":"(function(){var g={};\n(function(window){var k,aa=this;aa.md=!0;function m(a,b){var c=a.split(\".\"),d=aa;c[0]in d||!d.execScript||d.execScript(\"var \"+c[0]);for(var e;c.length&&(e=c.shift());)c.length||void 0===b?d[e]?d=d[e]:d=d[e]={}:d[e]=b}function ba(a){var b=p;function c(){}c.prototype=b.prototype;a.qd=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.nd=function(a,c,f){return b.prototype[c].apply(a,Array.prototype.slice.call(arguments,2))}};/*\n\n Copyright 2016 Google Inc.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\nfunction ca(a){this.c=Math.exp(Math.log(.5)/a);this.b=this.a=0}function da(a,b,c){var d=Math.pow(a.c,b);c=c*(1-d)+d*a.a;isNaN(c)||(a.a=c,a.b+=b)}function ea(a){return a.a/(1-Math.pow(a.c,a.b))};function fa(){this.c=new ca(2);this.f=new ca(5);this.a=0;this.b=5E5}fa.prototype.setDefaultEstimate=function(a){this.b=a};fa.prototype.getBandwidthEstimate=function(){return 128E3>this.a?this.b:Math.min(ea(this.c),ea(this.f))};function ga(){}function ha(){};function q(){this.h=null;this.f=!1;this.b=new fa;this.g={};this.a={};this.i=!1;this.c=null}m(\"shaka.abr.SimpleAbrManager\",q);q.prototype.stop=function(){this.h=null;this.f=!1;this.g={};this.a={};this.c=null};q.prototype.stop=q.prototype.stop;q.prototype.init=function(a){this.h=a};q.prototype.init=q.prototype.init;\nq.prototype.chooseStreams=function(a){for(var b in a)this.g[b]=a[b];b={};if(\"audio\"in a){var c=ia(this);c?(b.audio=c,this.a.audio=c):delete this.a.audio}\"video\"in a&&((c=ja(this))?(b.video=c,this.a.video=c):delete this.a.video);\"text\"in a&&(b.text=a.text.streams[0]);this.c=Date.now();return b};q.prototype.chooseStreams=q.prototype.chooseStreams;q.prototype.enable=function(){this.f=!0};q.prototype.enable=q.prototype.enable;q.prototype.disable=function(){this.f=!1};q.prototype.disable=q.prototype.disable;\nq.prototype.segmentDownloaded=function(a,b,c){var d=this.b;b-=a;16E3>c||(a=8E3*c/b,b/=1E3,d.a+=c,da(d.c,b,a),da(d.f,b,a));if(null!=this.c&&this.f)a:{if(!this.i){if(!(128E3<=this.b.a))break a;this.i=!0}else if(8E3>Date.now()-this.c)break a;c={};if(d=ia(this))c.audio=d,this.a.audio=d;if(d=ja(this))c.video=d,this.a.video=d;this.c=Date.now();this.b.getBandwidthEstimate();this.h(c)}};q.prototype.segmentDownloaded=q.prototype.segmentDownloaded;q.prototype.getBandwidthEstimate=function(){return this.b.getBandwidthEstimate()};\nq.prototype.getBandwidthEstimate=q.prototype.getBandwidthEstimate;q.prototype.setDefaultEstimate=function(a){this.b.setDefaultEstimate(a)};q.prototype.setDefaultEstimate=q.prototype.setDefaultEstimate;function ia(a){a=a.g.audio;if(!a)return null;a=ka(a);return a[Math.floor(a.length/2)]}\nfunction ja(a){var b=a.g.video;if(!b)return null;var b=ka(b),c=a.a.audio,c=c&&c.bandwidth||0;a=a.b.getBandwidthEstimate();for(var d=b[0],e=0;e<b.length;++e){var f=b[e];if(f.bandwidth){var g=((e+1<b.length?b[e+1]:{bandwidth:Infinity}).bandwidth+c)/.85;a>=(f.bandwidth+c)/.95&&a<=g&&(d=f)}}return d}function ka(a){return a.streams.slice(0).filter(function(a){return a.allowedByApplication&&a.allowedByKeySystem}).sort(function(a,c){return a.bandwidth-c.bandwidth})};function t(a,b){var c=b||{},d;for(d in c)this[d]=c[d];this.defaultPrevented=this.cancelable=this.bubbles=!1;this.timeStamp=window.performance&&window.performance.now?window.performance.now():Date.now();this.type=a;this.isTrusted=!1;this.target=this.currentTarget=null;this.a=!1}t.prototype.preventDefault=function(){};t.prototype.stopImmediatePropagation=function(){this.a=!0};t.prototype.stopPropagation=function(){};var la=\"ended play playing pause pausing ratechange seeked seeking timeupdate volumechange\".split(\" \"),ma=\"buffered currentTime duration ended loop muted paused playbackRate seeking videoHeight videoWidth volume\".split(\" \"),na=[\"loop\",\"playbackRate\"],oa=[\"pause\",\"play\"],pa=\"adaptation buffering emsg error loading unloading texttrackvisibility trackschanged\".split(\" \"),qa=\"drmInfo getConfiguration getManifestUri getPlaybackRate getTracks getStats isBuffering isInProgress isLive isTextTrackVisible keySystem seekRange\".split(\" \"),\nra=[[\"getConfiguration\",\"configure\"]],sa=[[\"isTextTrackVisible\",\"setTextTrackVisibility\"]],ta=\"addTextTrack cancelTrickPlay configure resetConfiguration selectTrack setTextTrackVisibility trickPlay\".split(\" \"),ua=[\"load\",\"unload\"];\nfunction va(a){return JSON.stringify(a,function(a,c){if(\"manager\"!=a&&\"function\"!=typeof c){if(c instanceof Event||c instanceof t){var b={},e;for(e in c){var f=c[e];f&&\"object\"==typeof f||e in Event||(b[e]=f)}return b}if(c instanceof TimeRanges)for(b={__type__:\"TimeRanges\",length:c.length,start:[],end:[]},e=0;e<c.length;++e)b.start.push(c.start(e)),b.end.push(c.end(e));else b=\"number\"==typeof c?isNaN(c)?\"NaN\":isFinite(c)?c:0>c?\"-Infinity\":\"Infinity\":c;return b}})}\nfunction wa(a){return JSON.parse(a,function(a,c){return\"NaN\"==c?NaN:\"-Infinity\"==c?-Infinity:\"Infinity\"==c?Infinity:c&&\"object\"==typeof c&&\"TimeRanges\"==c.__type__?xa(c):c})}function xa(a){return{length:a.length,start:function(b){return a.start[b]},end:function(b){return a.end[b]}}};function v(a,b,c){this.category=a;this.code=b;this.data=Array.prototype.slice.call(arguments,2)}m(\"shaka.util.Error\",v);v.prototype.toString=function(){return\"shaka.util.Error \"+JSON.stringify(this,null,\"  \")};v.Category={NETWORK:1,TEXT:2,MEDIA:3,MANIFEST:4,STREAMING:5,DRM:6,PLAYER:7,CAST:8,STORAGE:9};\nv.Code={UNSUPPORTED_SCHEME:1E3,BAD_HTTP_STATUS:1001,HTTP_ERROR:1002,TIMEOUT:1003,MALFORMED_DATA_URI:1004,UNKNOWN_DATA_URI_ENCODING:1005,INVALID_TEXT_HEADER:2E3,INVALID_TEXT_CUE:2001,UNABLE_TO_DETECT_ENCODING:2003,BAD_ENCODING:2004,INVALID_XML:2005,INVALID_TTML:2006,INVALID_MP4_TTML:2007,INVALID_MP4_VTT:2008,BUFFER_READ_OUT_OF_BOUNDS:3E3,JS_INTEGER_OVERFLOW:3001,EBML_OVERFLOW:3002,EBML_BAD_FLOATING_POINT_SIZE:3003,MP4_SIDX_WRONG_BOX_TYPE:3004,MP4_SIDX_INVALID_TIMESCALE:3005,MP4_SIDX_TYPE_NOT_SUPPORTED:3006,\nWEBM_CUES_ELEMENT_MISSING:3007,WEBM_EBML_HEADER_ELEMENT_MISSING:3008,WEBM_SEGMENT_ELEMENT_MISSING:3009,WEBM_INFO_ELEMENT_MISSING:3010,WEBM_DURATION_ELEMENT_MISSING:3011,WEBM_CUE_TRACK_POSITIONS_ELEMENT_MISSING:3012,WEBM_CUE_TIME_ELEMENT_MISSING:3013,MEDIA_SOURCE_OPERATION_FAILED:3014,MEDIA_SOURCE_OPERATION_THREW:3015,VIDEO_ERROR:3016,QUOTA_EXCEEDED_ERROR:3017,UNABLE_TO_GUESS_MANIFEST_TYPE:4E3,DASH_INVALID_XML:4001,DASH_NO_SEGMENT_INFO:4002,DASH_EMPTY_ADAPTATION_SET:4003,DASH_EMPTY_PERIOD:4004,DASH_WEBM_MISSING_INIT:4005,\nDASH_UNSUPPORTED_CONTAINER:4006,DASH_PSSH_BAD_ENCODING:4007,DASH_NO_COMMON_KEY_SYSTEM:4008,DASH_MULTIPLE_KEY_IDS_NOT_SUPPORTED:4009,DASH_CONFLICTING_KEY_IDS:4010,UNPLAYABLE_PERIOD:4011,RESTRICTIONS_CANNOT_BE_MET:4012,NO_PERIODS:4014,DASH_DUPLICATE_REPRESENTATION_ID:4018,INVALID_STREAMS_CHOSEN:5005,NO_RECOGNIZED_KEY_SYSTEMS:6E3,REQUESTED_KEY_SYSTEM_CONFIG_UNAVAILABLE:6001,FAILED_TO_CREATE_CDM:6002,FAILED_TO_ATTACH_TO_VIDEO:6003,INVALID_SERVER_CERTIFICATE:6004,FAILED_TO_CREATE_SESSION:6005,FAILED_TO_GENERATE_LICENSE_REQUEST:6006,\nLICENSE_REQUEST_FAILED:6007,LICENSE_RESPONSE_REJECTED:6008,ENCRYPTED_CONTENT_WITHOUT_DRM_INFO:6010,NO_LICENSE_SERVER_GIVEN:6012,OFFLINE_SESSION_REMOVED:6013,EXPIRED:6014,LOAD_INTERRUPTED:7E3,CAST_API_UNAVAILABLE:8E3,NO_CAST_RECEIVERS:8001,ALREADY_CASTING:8002,UNEXPECTED_CAST_ERROR:8003,CAST_CANCELED_BY_USER:8004,CAST_CONNECTION_TIMED_OUT:8005,CAST_RECEIVER_APP_UNAVAILABLE:8006,INDEXED_DB_NOT_SUPPORTED:9E3,INDEXED_DB_ERROR:9001,OPERATION_ABORTED:9002,REQUESTED_ITEM_NOT_FOUND:9003,MALFORMED_OFFLINE_URI:9004,\nCANNOT_STORE_LIVE_OFFLINE:9005,STORE_ALREADY_IN_PROGRESS:9006,NO_INIT_DATA_FOR_OFFLINE:9007};function w(){var a,b,c=new Promise(function(c,e){a=c;b=e});c.resolve=a;c.reject=b;return c};function ya(a,b,c,d,e){this.C=a;this.l=b;this.A=c;this.B=d;this.s=e;this.f=this.j=this.h=!1;this.v=\"\";this.a=this.i=null;this.b={video:{},player:{}};this.m=0;this.c={};this.g=null}k=ya.prototype;k.o=function(){za(this);this.a&&(this.a.stop(function(){},function(){}),this.a=null);this.B=this.A=this.l=null;this.f=this.j=this.h=!1;this.g=this.c=this.b=this.a=this.i=null;return Promise.resolve()};k.O=function(){return this.f};k.cb=function(){return this.v};\nk.init=function(){if(window.chrome&&chrome.cast&&chrome.cast.isAvailable){delete window.__onGCastApiAvailable;this.h=!0;this.l();var a=new chrome.cast.SessionRequest(this.C),a=new chrome.cast.ApiConfig(a,this.kc.bind(this),this.rc.bind(this),\"origin_scoped\");chrome.cast.initialize(a,function(){},function(){})}else window.__onGCastApiAvailable=function(a){a&&this.init()}.bind(this)};k.fb=function(a){this.i=a;this.f&&Aa(this,{type:\"appData\",appData:this.i})};\nk.cast=function(a){if(!this.h)return Promise.reject(new v(8,8E3));if(!this.j)return Promise.reject(new v(8,8001));if(this.f)return Promise.reject(new v(8,8002));this.g=new w;chrome.cast.requestSession(this.ab.bind(this,a),this.ub.bind(this));return this.g};\nk.get=function(a,b){if(\"video\"==a){if(0<=oa.indexOf(b))return this.Fb.bind(this,a,b)}else if(\"player\"==a){if(0<=ta.indexOf(b))return this.Fb.bind(this,a,b);if(0<=ua.indexOf(b))return this.Gc.bind(this,a,b);if(0<=qa.indexOf(b))return this.Cb.bind(this,a,b)}return this.Cb(a,b)};k.set=function(a,b,c){this.b[a][b]=c;Aa(this,{type:\"set\",targetName:a,property:b,value:c})};\nk.ab=function(a,b){this.a=b;this.a.addUpdateListener(this.vb.bind(this));this.a.addMessageListener(\"urn:x-cast:com.google.shaka.v2\",this.lc.bind(this));this.vb();Aa(this,{type:\"init\",initState:a,appData:this.i});this.g.resolve()};k.ub=function(a){var b=8003;switch(a.code){case \"cancel\":b=8004;break;case \"timeout\":b=8005;break;case \"receiver_unavailable\":b=8006}this.g.reject(new v(8,b,a))};k.Cb=function(a,b){return this.b[a][b]};\nk.Fb=function(a,b){Aa(this,{type:\"call\",targetName:a,methodName:b,args:Array.prototype.slice.call(arguments,2)})};k.Gc=function(a,b){var c=Array.prototype.slice.call(arguments,2),d=new w,e=this.m.toString();this.m++;this.c[e]=d;Aa(this,{type:\"asyncCall\",targetName:a,methodName:b,args:c,id:e});return d};k.kc=function(a){var b=this.s();this.g=new w;this.ab(b,a)};k.rc=function(a){this.j=\"available\"==a;this.l()};\nk.vb=function(){var a=this.a?\"connected\"==this.a.status:!1;if(this.f&&!a){this.B();for(var b in this.b)this.b[b]={};za(this)}this.v=(this.f=a)?this.a.receiver.friendlyName:\"\";this.l()};function za(a){for(var b in a.c){var c=a.c[b];delete a.c[b];c.reject(new v(7,7E3))}}\nk.lc=function(a,b){var c=wa(b);switch(c.type){case \"event\":var d=c.targetName,e=c.event;this.A(d,new t(e.type,e));break;case \"update\":e=c.update;for(d in e){var c=this.b[d]||{},f;for(f in e[d])c[f]=e[d][f]}break;case \"asyncComplete\":if(d=c.id,f=c.error,c=this.c[d],delete this.c[d],c)if(f){d=new v(f.category,f.code);for(e in f)d[e]=f[e];c.reject(d)}else c.resolve()}};function Aa(a,b){var c=va(b);a.a.sendMessage(\"urn:x-cast:com.google.shaka.v2\",c,function(){},ga)};function Ba(){this.a={}}k=Ba.prototype;k.push=function(a,b){this.a.hasOwnProperty(a)?this.a[a].push(b):this.a[a]=[b]};k.set=function(a,b){this.a[a]=b};k.has=function(a){return this.a.hasOwnProperty(a)};k.get=function(a){return(a=this.a[a])?a.slice():null};k.remove=function(a,b){var c=this.a[a];if(c)for(var d=0;d<c.length;++d)c[d]==b&&(c.splice(d,1),--d)};k.keys=function(){var a=[],b;for(b in this.a)a.push(b);return a};function x(){this.a=new Ba}x.prototype.o=function(){Ca(this);this.a=null;return Promise.resolve()};function y(a,b,c,d){b=new Da(b,c,d);a.a.push(c,b)}x.prototype.la=function(a,b){for(var c=this.a.get(b)||[],d=0;d<c.length;++d){var e=c[d];e.target==a&&(e.la(),this.a.remove(b,e))}};function Ca(a){var b=a.a,c=[],d;for(d in b.a)c.push.apply(c,b.a[d]);for(b=0;b<c.length;++b)c[b].la();a.a.a={}}function Da(a,b,c){this.target=a;this.type=b;this.a=c;this.target.addEventListener(b,c,!1)}\nDa.prototype.la=function(){this.target&&(this.target.removeEventListener(this.type,this.a,!1),this.a=this.target=null)};function p(){this.Ba=new Ba;this.U=this}p.prototype.addEventListener=function(a,b){this.Ba.push(a,b)};p.prototype.removeEventListener=function(a,b){this.Ba.remove(a,b)};p.prototype.dispatchEvent=function(a){for(var b=this.Ba.get(a.type)||[],c=0;c<b.length;++c){a.target=this.U;a.currentTarget=this.U;var d=b[c];try{d.handleEvent?d.handleEvent(a):d.call(this,a)}catch(e){}if(a.a)break}return a.defaultPrevented};function z(a,b,c){p.call(this);this.c=a;this.b=b;this.h=this.f=this.g=this.i=this.j=null;this.a=new ya(c,this.Vc.bind(this),this.Wc.bind(this),this.Xc.bind(this),this.qb.bind(this));Ea(this)}ba(z);m(\"shaka.cast.CastProxy\",z);z.prototype.o=function(){var a=[this.h?this.h.o():null,this.b?this.b.o():null,this.a?this.a.o():null];this.a=this.h=this.i=this.j=this.b=this.c=null;return Promise.all(a)};z.prototype.destroy=z.prototype.o;z.prototype.cc=function(){return this.j};z.prototype.getVideo=z.prototype.cc;\nz.prototype.ac=function(){return this.i};z.prototype.getPlayer=z.prototype.ac;z.prototype.Qb=function(){return this.a?this.a.h&&this.a.j:!1};z.prototype.canCast=z.prototype.Qb;z.prototype.O=function(){return this.a?this.a.O():!1};z.prototype.isCasting=z.prototype.O;z.prototype.cb=function(){return this.a?this.a.cb():\"\"};z.prototype.receiverName=z.prototype.cb;z.prototype.cast=function(){var a=this.qb();return this.a.cast(a).then(function(){return this.b.kb()}.bind(this))};z.prototype.cast=z.prototype.cast;\nz.prototype.fb=function(a){this.a.fb(a)};z.prototype.setAppData=z.prototype.fb;z.prototype.cd=function(){var a=this.a;if(a.f){var b=a.s();chrome.cast.requestSession(a.ab.bind(a,b),a.ub.bind(a))}};z.prototype.suggestDisconnect=z.prototype.cd;\nfunction Ea(a){a.a.init();a.h=new x;la.forEach(function(a){y(this.h,this.c,a,this.kd.bind(this))}.bind(a));pa.forEach(function(a){y(this.h,this.b,a,this.Cc.bind(this))}.bind(a));a.j={};for(var b in a.c)Object.defineProperty(a.j,b,{configurable:!1,enumerable:!0,get:a.jd.bind(a,b),set:a.ld.bind(a,b)});a.i={};for(b in a.b)Object.defineProperty(a.i,b,{configurable:!1,enumerable:!0,get:a.Bc.bind(a,b)});a.g=new p;a.g.U=a.j;a.f=new p;a.f.U=a.i}k=z.prototype;\nk.qb=function(){var a={video:{},player:{},playerAfterLoad:{},manifest:this.b.pa,startTime:null};this.c.pause();na.forEach(function(b){a.video[b]=this.c[b]}.bind(this));this.c.ended||(a.startTime=this.c.currentTime);ra.forEach(function(b){var c=b[1];b=this.b[b[0]]();a.player[c]=b}.bind(this));sa.forEach(function(b){var c=b[1];b=this.b[b[0]]();a.playerAfterLoad[c]=b}.bind(this));return a};k.Vc=function(){this.dispatchEvent(new t(\"caststatuschanged\"))};\nk.Xc=function(){ra.forEach(function(a){var b=a[1];a=this.a.get(\"player\",a[0])();this.b[b](a)}.bind(this));var a=this.a.get(\"player\",\"getManifestUri\")(),b=this.a.get(\"video\",\"ended\"),c=Promise.resolve(),d=this.c.autoplay,e=null;b||(e=this.a.get(\"video\",\"currentTime\"));a&&(this.c.autoplay=!1,c=this.b.load(a,e),c[\"catch\"](function(a){this.b.dispatchEvent(new t(\"error\",{detail:a}))}.bind(this)));var f={};na.forEach(function(a){f[a]=this.a.get(\"video\",a)}.bind(this));c.then(function(){na.forEach(function(a){this.c[a]=\nf[a]}.bind(this));sa.forEach(function(a){var b=a[1];a=this.a.get(\"player\",a[0])();this.b[b](a)}.bind(this));this.c.autoplay=d;a&&this.c.play()}.bind(this))};\nk.jd=function(a){if(\"addEventListener\"==a)return this.g.addEventListener.bind(this.g);if(\"removeEventListener\"==a)return this.g.removeEventListener.bind(this.g);if(this.a.O()&&!Object.keys(this.a.b.video).length){var b=this.c[a];if(\"function\"!=typeof b)return b}return this.a.O()?this.a.get(\"video\",a):(b=this.c[a],\"function\"==typeof b&&(b=b.bind(this.c)),b)};k.ld=function(a,b){this.a.O()?this.a.set(\"video\",a,b):this.c[a]=b};k.kd=function(a){this.a.O()||this.g.dispatchEvent(new t(a.type,a))};\nk.Bc=function(a){return\"addEventListener\"==a?this.f.addEventListener.bind(this.f):\"removeEventListener\"==a?this.f.removeEventListener.bind(this.f):\"getNetworkingEngine\"==a?this.b.rb.bind(this.b):this.a.O()&&!Object.keys(this.a.b.video).length&&0<=qa.indexOf(a)||!this.a.O()?(a=this.b[a],a.bind(this.b)):this.a.get(\"player\",a)};k.Cc=function(a){this.a.O()||this.f.dispatchEvent(a)};k.Wc=function(a,b){this.a.O()&&(\"video\"==a?this.g.dispatchEvent(b):\"player\"==a&&this.f.dispatchEvent(b))};function A(a,b,c){p.call(this);this.b=a;this.a=b;this.i={video:a,player:b};this.j=c||function(){};this.h=!1;this.c=!0;this.f=this.g=null;Fa(this)}ba(A);m(\"shaka.cast.CastReceiver\",A);A.prototype.ec=function(){return this.h};A.prototype.isConnected=A.prototype.ec;A.prototype.fc=function(){return this.c};A.prototype.isIdle=A.prototype.fc;\nA.prototype.o=function(){var a=this.a?this.a.o():Promise.resolve();null!=this.f&&window.clearTimeout(this.f);this.j=this.i=this.a=this.b=null;this.h=!1;this.c=!0;this.f=this.g=null;return a.then(function(){cast.receiver.CastReceiverManager.getInstance().stop()})};A.prototype.destroy=A.prototype.o;\nfunction Fa(a){var b=cast.receiver.CastReceiverManager.getInstance();b.onSenderConnected=a.Ab.bind(a);b.onSenderDisconnected=a.Ab.bind(a);b.onSystemVolumeChanged=a.Xb.bind(a);a.g=b.getCastMessageBus(\"urn:x-cast:com.google.shaka.v2\");a.g.onMessage=a.mc.bind(a);b.start();la.forEach(function(a){this.b.addEventListener(a,this.Db.bind(this,\"video\"))}.bind(a));pa.forEach(function(a){this.a.addEventListener(a,this.Db.bind(this,\"player\"))}.bind(a));cast.__platform__&&cast.__platform__.canDisplayType('video/mp4; codecs=\"avc1.640028\"; width=3840; height=2160')?\na.a.gb(3840,2160):a.a.gb(1920,1080);a.a.addEventListener(\"loading\",function(){this.c=!1;Ga(this)}.bind(a));a.b.addEventListener(\"playing\",function(){this.c=!1;Ga(this)}.bind(a));a.a.addEventListener(\"unloading\",function(){this.c=!0;Ga(this)}.bind(a));a.b.addEventListener(\"ended\",function(){window.setTimeout(function(){this.b&&this.b.ended&&(this.c=!0,Ga(this))}.bind(this),5E3)}.bind(a))}k=A.prototype;k.Ab=function(){this.h=!!cast.receiver.CastReceiverManager.getInstance().getSenders().length;Ga(this)};\nfunction Ga(a){Promise.resolve().then(function(){this.dispatchEvent(new t(\"caststatuschanged\"))}.bind(a))}\nfunction Ha(a,b,c){for(var d in b.player)a.a[d](b.player[d]);a.j(c);c=Promise.resolve();var e=a.b.autoplay;b.manifest&&(a.b.autoplay=!1,c=a.a.load(b.manifest,b.startTime),c[\"catch\"](function(a){this.a.dispatchEvent(new t(\"error\",{detail:a}))}.bind(a)));c.then(function(){for(var a in b.video){var c=b.video[a];this.b[a]=c}for(a in b.playerAfterLoad)c=b.playerAfterLoad[a],this.a[a](c);this.b.autoplay=e;b.manifest&&this.b.play()}.bind(a))}\nk.Db=function(a,b){this.bb();Ia(this,{type:\"event\",targetName:a,event:b})};k.bb=function(){null!=this.f&&window.clearTimeout(this.f);this.f=window.setTimeout(this.bb.bind(this),500);var a={video:{},player:{}};ma.forEach(function(b){a.video[b]=this.b[b]}.bind(this));qa.forEach(function(b){a.player[b]=this.a[b]()}.bind(this));var b=cast.receiver.CastReceiverManager.getInstance().getSystemVolume();b&&(a.video.volume=b.level,a.video.muted=b.muted);Ia(this,{type:\"update\",update:a})};\nk.Xb=function(){var a=cast.receiver.CastReceiverManager.getInstance().getSystemVolume();a&&Ia(this,{type:\"update\",update:{video:{volume:a.level,muted:a.muted}}});Ia(this,{type:\"event\",targetName:\"video\",event:{type:\"volumechange\"}})};\nk.mc=function(a){var b=wa(a.data);switch(b.type){case \"init\":Ha(this,b.initState,b.appData);this.bb();break;case \"appData\":this.j(b.appData);break;case \"set\":var c=b.targetName,d=b.property,e=b.value;if(\"video\"==c)if(b=cast.receiver.CastReceiverManager.getInstance(),\"volume\"==d){b.setSystemVolumeLevel(e);break}else if(\"muted\"==d){b.setSystemVolumeMuted(e);break}this.i[c][d]=e;break;case \"call\":c=b.targetName;d=b.methodName;e=b.args;c=this.i[c];c[d].apply(c,e);break;case \"asyncCall\":c=b.targetName,\nd=b.methodName,e=b.args,b=b.id,a=a.senderId,c=this.i[c],c[d].apply(c,e).then(this.Jb.bind(this,a,b,null),this.Jb.bind(this,a,b))}};k.Jb=function(a,b,c){Ia(this,{type:\"asyncComplete\",id:b,error:c},a)};function Ia(a,b,c){a.h&&(b=va(b),c?a.g.getCastChannel(c).send(b):a.g.broadcast(b))};function Ja(a,b){return a.reduce(function(a,b,e){return b[\"catch\"](a.bind(null,e))}.bind(null,b),Promise.reject())}function B(a,b){return a.concat(b)}function C(){}function Ka(a){return null!=a}function La(a){return function(b){return b!=a}}function Ma(a,b,c){return c.indexOf(a)==b};function Na(a){return!a||!Object.keys(a).length}function F(a){return Object.keys(a).map(function(b){return a[b]})}function Oa(a,b){return Object.keys(a).reduce(function(c,d){c[d]=b(a[d],d);return c},{})}function Pa(a,b){return Object.keys(a).every(function(c){return b(c,a[c])})};function Qa(a){return window.btoa(String.fromCharCode.apply(null,a)).replace(/\\+/g,\"-\").replace(/\\//g,\"_\").replace(/=*$/,\"\")}function Ra(a){a=window.atob(a.replace(/-/g,\"+\").replace(/_/g,\"/\"));for(var b=new Uint8Array(a.length),c=0;c<a.length;++c)b[c]=a.charCodeAt(c);return b}function Sa(a){for(var b=new Uint8Array(a.length/2),c=0;c<a.length;c+=2)b[c/2]=window.parseInt(a.substr(c,2),16);return b}\nfunction Ta(a){for(var b=\"\",c=0;c<a.length;++c){var d=a[c].toString(16);1==d.length&&(d=\"0\"+d);b+=d}return b}function Ua(a,b){if(!a&&!b)return!0;if(!a||!b||a.length!=b.length)return!1;for(var c=0;c<a.length;++c)if(a[c]!=b[c])return!1;return!0};function Va(a,b){var c=G(a,b);return 1!=c.length?null:c[0]}function G(a,b){return Array.prototype.filter.call(a.childNodes,function(a){return a.tagName==b})}function Wa(a){var b=a.firstChild;return b&&b.nodeType==Node.TEXT_NODE?a.textContent.trim():null}function H(a,b,c,d){var e=null;a=a.getAttribute(b);null!=a&&(e=c(a));return null==e?void 0!==d?d:null:e}function Xa(a){if(!a)return null;a=Date.parse(a);return isNaN(a)?null:Math.floor(a/1E3)}\nfunction I(a){if(!a)return null;a=/^P(?:([0-9]*)Y)?(?:([0-9]*)M)?(?:([0-9]*)D)?(?:T(?:([0-9]*)H)?(?:([0-9]*)M)?(?:([0-9.]*)S)?)?$/.exec(a);if(!a)return null;a=31536E3*Number(a[1]||null)+2592E3*Number(a[2]||null)+86400*Number(a[3]||null)+3600*Number(a[4]||null)+60*Number(a[5]||null)+Number(a[6]||null);return isFinite(a)?a:null}function Ya(a){var b=/([0-9]+)-([0-9]+)/.exec(a);if(!b)return null;a=Number(b[1]);if(!isFinite(a))return null;b=Number(b[2]);return isFinite(b)?{start:a,end:b}:null}\nfunction Za(a){a=Number(a);return a%1?null:a}function $a(a){a=Number(a);return!(a%1)&&0<a?a:null}function bb(a){a=Number(a);return!(a%1)&&0<=a?a:null}function cb(a){var b;a=(b=a.match(/^(\\d+)\\/(\\d+)$/))?Number(b[1]/b[2]):Number(a);return isNaN(a)?null:a};var db={\"urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b\":\"org.w3.clearkey\",\"urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\":\"com.widevine.alpha\",\"urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95\":\"com.microsoft.playready\",\"urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb\":\"com.adobe.primetime\"};\nfunction eb(a,b){var c=fb(a),d=null,e=c.filter(function(a){return\"urn:mpeg:dash:mp4protection:2011\"==a.Ib?(d=a.init||d,!1):!0}),f=c.map(function(a){return a.keyId}).filter(Ka),g=null;if(0<f.length&&(g=f[0],f.some(La(g))))throw new v(4,4010);f=[];0<e.length?(f=gb(d,b,e),f.length||(f=[hb(\"\",d)])):0<c.length&&(f=F(db).map(function(a){return hb(a,d)}));return{nb:g,od:d,drmInfos:f,pb:!0}}\nfunction ib(a,b,c){var d=eb(a,b);if(c.pb){a=1==c.drmInfos.length&&!c.drmInfos[0].keySystem;b=!d.drmInfos.length;if(!c.drmInfos.length||a&&!b)c.drmInfos=d.drmInfos;c.pb=!1}else if(0<d.drmInfos.length&&(c.drmInfos=c.drmInfos.filter(function(a){return d.drmInfos.some(function(b){return b.keySystem==a.keySystem})}),!c.drmInfos.length))throw new v(4,4008);return d.nb||c.nb}\nfunction hb(a,b){return{keySystem:a,licenseServerUri:\"\",distinctiveIdentifierRequired:!1,persistentStateRequired:!1,audioRobustness:\"\",videoRobustness:\"\",serverCertificate:null,initData:b||[],keyIds:[]}}function gb(a,b,c){return c.map(function(c){var d=db[c.Ib];return d?[hb(d,c.init||a)]:b(c.node)||[]}).reduce(B,[])}\nfunction fb(a){return a.map(function(a){var b=a.getAttribute(\"schemeIdUri\"),d=a.getAttribute(\"cenc:default_KID\"),e=G(a,\"cenc:pssh\").map(Wa);if(!b)return null;b=b.toLowerCase();if(d&&(d=d.replace(/-/g,\"\").toLowerCase(),0<=d.indexOf(\" \")))throw new v(4,4009);var f=[];try{f=e.map(function(a){return{initDataType:\"cenc\",initData:Ra(a)}})}catch(g){throw new v(4,4007);}return{node:a,Ib:b,keyId:d,init:0<f.length?f:null}}).filter(Ka)};var jb=/^(?:([^:/?#.]+):)?(?:\\/\\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#(.*))?$/;function kb(a){var b;a instanceof kb?(lb(this,a.T),this.ma=a.ma,this.V=a.V,mb(this,a.ya),this.P=a.P,nb(this,ob(a.a)),this.da=a.da):a&&(b=String(a).match(jb))?(lb(this,b[1]||\"\",!0),this.ma=pb(b[2]||\"\"),this.V=pb(b[3]||\"\",!0),mb(this,b[4]),this.P=pb(b[5]||\"\",!0),nb(this,b[6]||\"\",!0),this.da=pb(b[7]||\"\")):this.a=new qb(null)}k=kb.prototype;k.T=\"\";k.ma=\"\";k.V=\"\";k.ya=null;k.P=\"\";k.da=\"\";\nk.toString=function(){var a=[],b=this.T;b&&a.push(rb(b,sb,!0),\":\");if(b=this.V){a.push(\"//\");var c=this.ma;c&&a.push(rb(c,sb,!0),\"@\");a.push(encodeURIComponent(b).replace(/%25([0-9a-fA-F]{2})/g,\"%$1\"));b=this.ya;null!=b&&a.push(\":\",String(b))}if(b=this.P)this.V&&\"/\"!=b.charAt(0)&&a.push(\"/\"),a.push(rb(b,\"/\"==b.charAt(0)?tb:ub,!0));(b=this.a.toString())&&a.push(\"?\",b);(b=this.da)&&a.push(\"#\",rb(b,vb));return a.join(\"\")};\nk.resolve=function(a){var b=new kb(this);\"data\"===b.T&&(b=new kb);var c=!!a.T;c?lb(b,a.T):c=!!a.ma;c?b.ma=a.ma:c=!!a.V;c?b.V=a.V:c=null!=a.ya;var d=a.P;if(c)mb(b,a.ya);else if(c=!!a.P){if(\"/\"!=d.charAt(0))if(this.V&&!this.P)d=\"/\"+d;else{var e=b.P.lastIndexOf(\"/\");-1!=e&&(d=b.P.substr(0,e+1)+d)}if(\"..\"==d||\".\"==d)d=\"\";else if(-1!=d.indexOf(\"./\")||-1!=d.indexOf(\"/.\")){for(var e=!d.lastIndexOf(\"/\",0),d=d.split(\"/\"),f=[],g=0;g<d.length;){var h=d[g++];\".\"==h?e&&g==d.length&&f.push(\"\"):\"..\"==h?((1<f.length||\n1==f.length&&\"\"!=f[0])&&f.pop(),e&&g==d.length&&f.push(\"\")):(f.push(h),e=!0)}d=f.join(\"/\")}}c?b.P=d:c=\"\"!==a.a.toString();c?nb(b,ob(a.a)):c=!!a.da;c&&(b.da=a.da);return b};function lb(a,b,c){a.T=c?pb(b,!0):b;a.T&&(a.T=a.T.replace(/:$/,\"\"))}function mb(a,b){if(b){b=Number(b);if(isNaN(b)||0>b)throw Error(\"Bad port number \"+b);a.ya=b}else a.ya=null}function nb(a,b,c){b instanceof qb?a.a=b:(c||(b=rb(b,wb)),a.a=new qb(b))}function pb(a,b){return a?b?decodeURI(a):decodeURIComponent(a):\"\"}\nfunction rb(a,b,c){return\"string\"==typeof a?(a=encodeURI(a).replace(b,xb),c&&(a=a.replace(/%25([0-9a-fA-F]{2})/g,\"%$1\")),a):null}function xb(a){a=a.charCodeAt(0);return\"%\"+(a>>4&15).toString(16)+(a&15).toString(16)}var sb=/[#\\/\\?@]/g,ub=/[\\#\\?:]/g,tb=/[\\#\\?]/g,wb=/[\\#\\?@]/g,vb=/#/g;function qb(a){this.b=a||null}qb.prototype.a=null;qb.prototype.c=null;\nqb.prototype.toString=function(){if(this.b)return this.b;if(!this.a)return\"\";var a=[],b;for(b in this.a)for(var c=encodeURIComponent(b),d=this.a[b],e=0;e<d.length;e++){var f=c;\"\"!==d[e]&&(f+=\"=\"+encodeURIComponent(d[e]));a.push(f)}return this.b=a.join(\"&\")};function ob(a){var b=new qb;b.b=a.b;if(a.a){var c={},d;for(d in a.a)c[d]=a.a[d].concat();b.a=c;b.c=a.c}return b};function yb(a,b,c){this.a=a;this.M=b;this.D=c}m(\"shaka.media.InitSegmentReference\",yb);function J(a,b,c,d,e,f){this.position=a;this.startTime=b;this.endTime=c;this.a=d;this.M=e;this.D=f}m(\"shaka.media.SegmentReference\",J);var zb=1/15;function Ab(a,b,c,d,e){null!==e&&(e=Math.round(e));var f={RepresentationID:b,Number:c,Bandwidth:d,Time:e};return a.replace(/\\$(RepresentationID|Number|Bandwidth|Time)?(?:%0([0-9]+)d)?\\$/g,function(a,b,c){if(\"$$\"==a)return\"$\";var d=f[b];if(null==d)return a;\"RepresentationID\"==b&&c&&(c=void 0);a=d.toString();c=window.parseInt(c,10)||1;return Array(Math.max(0,c-a.length)+1).join(\"0\")+a})}\nfunction Bb(a,b,c){if(c.length){var d=c[0];d.startTime<=zb&&(c[0]=new J(d.position,0,d.endTime,d.a,d.M,d.D));a||(a=c[c.length-1],a.startTime>b||(c[c.length-1]=new J(a.position,a.startTime,b,a.a,a.M,a.D)))}}function K(a,b){if(!b.length)return a;var c=b.map(function(a){return new kb(a)});return a.map(function(a){return new kb(a)}).map(function(a){return c.map(a.resolve.bind(a))}).reduce(B,[]).map(function(a){return a.toString()})}\nfunction Cb(a,b){var c=L(a,b,\"timescale\"),d=1;c&&(d=$a(c)||1);c=L(a,b,\"duration\");(c=$a(c||\"\"))&&(c/=d);var e=L(a,b,\"startNumber\"),f=L(a,b,\"presentationTimeOffset\"),g=bb(e||\"\");if(null==e||null==g)g=1;var h=Db(a,b,\"SegmentTimeline\"),e=null;if(h){for(var e=d,l=Number(f),n=a.I.duration||Infinity,h=G(h,\"S\"),r=[],u=0,X=0;X<h.length;++X){var D=h[X],E=H(D,\"t\",bb),ab=H(D,\"d\",bb),D=H(D,\"r\",Za);null!=E&&(E-=l);if(!ab)break;E=null!=E?E:u;D=D||0;if(0>D)if(X+1<h.length){D=H(h[X+1],\"t\",bb);if(null==D)break;else if(E>=\nD)break;D=Math.ceil((D-E)/ab)-1}else{if(Infinity==n)break;else if(E/e>=n)break;D=Math.ceil((n*e-E)/ab)-1}0<r.length&&E!=u&&(r[r.length-1].end=E/e);for(var Yc=0;Yc<=D;++Yc)u=E+ab,r.push({start:E/e,end:u/e,gd:E}),E=u}e=r}return{timescale:d,G:c,ja:g,presentationTimeOffset:Number(f)/d||0,lb:Number(f),w:e}}function L(a,b,c){return[b(a.u),b(a.R),b(a.L)].filter(Ka).map(function(a){return a.getAttribute(c)}).reduce(function(a,b){return a||b})}\nfunction Db(a,b,c){return[b(a.u),b(a.R),b(a.L)].filter(Ka).map(function(a){return Va(a,c)}).reduce(function(a,b){return a||b})};function Eb(a){if(!a)return\"\";a=new Uint8Array(a);239==a[0]&&187==a[1]&&191==a[2]&&(a=a.subarray(3));a=escape(Fb(a));try{return decodeURIComponent(a)}catch(b){throw new v(2,2004);}}function Gb(a,b){if(!a)return\"\";if(a.byteLength%2)throw new v(2,2004);var c;if(a instanceof ArrayBuffer)c=a;else{var d=new Uint8Array(a.byteLength);d.set(new Uint8Array(a));c=d.buffer}var d=a.byteLength/2,e=new Uint16Array(d);c=new DataView(c);for(var f=0;f<d;f++)e[f]=c.getUint16(2*f,b);return Fb(e)}\nfunction Hb(a){var b=new Uint8Array(a);if(239==b[0]&&187==b[1]&&191==b[2])return Eb(b);if(254==b[0]&&255==b[1])return Gb(b.subarray(2),!1);if(255==b[0]&&254==b[1])return Gb(b.subarray(2),!0);var c=function(a,b){return a.byteLength<=b||32<=a[b]&&126>=a[b]}.bind(null,b);if(b[0]||b[2]){if(!b[1]&&!b[3])return Gb(a,!0);if(c(0)&&c(1)&&c(2)&&c(3))return Eb(a)}else return Gb(a,!1);throw new v(2,2003);}\nfunction Ib(a){a=unescape(encodeURIComponent(a));for(var b=new Uint8Array(a.length),c=0;c<a.length;++c)b[c]=a.charCodeAt(c);return b.buffer}function Fb(a){for(var b=\"\",c=0;c<a.length;c+=16E3)b+=String.fromCharCode.apply(null,a.subarray(c,c+16E3));return b};function Jb(a){this.b=a;this.c=0==Kb;this.a=0}var Kb=1;function Lb(a){return a.a<a.b.byteLength}function Mb(a){try{var b=a.b.getUint8(a.a)}catch(c){Nb()}a.a+=1;return b}function Ob(a){try{var b=a.b.getUint16(a.a,a.c)}catch(c){Nb()}a.a+=2;return b}function M(a){try{var b=a.b.getUint32(a.a,a.c)}catch(c){Nb()}a.a+=4;return b}\nfunction Pb(a){var b,c;try{a.c?(b=a.b.getUint32(a.a,!0),c=a.b.getUint32(a.a+4,!0)):(c=a.b.getUint32(a.a,!1),b=a.b.getUint32(a.a+4,!1))}catch(d){Nb()}if(2097151<c)throw new v(3,3001);a.a+=8;return c*Math.pow(2,32)+b}function Qb(a,b){a.a+b>a.b.byteLength&&Nb();var c=a.b.buffer.slice(a.a,a.a+b);a.a+=b;return new Uint8Array(c)}function N(a,b){a.a+b>a.b.byteLength&&Nb();a.a+=b}\nfunction Rb(a){var b=a.a;try{for(;Lb(a)&&a.b.getUint8(a.a);)a.a+=1}catch(c){Nb()}b=a.b.buffer.slice(b,a.a);a.a+=1;return Eb(b)}function Nb(){throw new v(3,3E3);};function Sb(a,b){for(;Lb(b);){var c=b.a,d=M(b),e=M(b);1==d?d=Pb(b):d||(d=b.b.byteLength-c);if(e==a)return d;N(b,d-(b.a-c))}return-1}function Tb(a,b){for(var c=new Jb(new DataView(a)),d=[[1836019574,0],[1953653099,0],[1835297121,0],[1835626086,0],[1937007212,0],[1937011556,8],[b,0]],e=-1,f=0;f<d.length;f++){var g=d[f][1],e=Sb(d[f][0],c);if(-1==e)return-1;N(c,g)}return e};function Ub(a,b,c,d){var e=[];a=new Jb(new DataView(a));var f=Sb(1936286840,a);if(-1==f)throw new v(3,3004);var g=Mb(a);N(a,3);N(a,4);var h=M(a);if(!h)throw new v(3,3005);var l,n;g?(l=Pb(a),n=Pb(a)):(l=M(a),n=M(a));N(a,2);g=Ob(a);d=l-d;b=b+f+n;for(f=0;f<g;f++){l=M(a);n=(l&2147483648)>>>31;l&=2147483647;var r=M(a);N(a,4);if(1==n)throw new v(3,3006);e.push(new J(e.length,d/h,(d+r)/h,function(){return c},b,b+l-1));d+=r;b+=l}return e};function O(a){this.a=a}m(\"shaka.media.SegmentIndex\",O);O.prototype.o=function(){this.a=null;return Promise.resolve()};O.prototype.destroy=O.prototype.o;O.prototype.find=function(a){for(var b=this.a.length-1;0<=b;--b){var c=this.a[b];if(a>=c.startTime&&a<c.endTime)return c.position}return null};O.prototype.find=O.prototype.find;O.prototype.get=function(a){if(!this.a.length)return null;a-=this.a[0].position;return 0>a||a>=this.a.length?null:this.a[a]};O.prototype.get=O.prototype.get;\nO.prototype.Za=function(a){for(var b=[],c=0,d=0;c<this.a.length&&d<a.length;){var e=this.a[c],f=a[d];e.startTime<f.startTime?(b.push(e),c++):(e.startTime>f.startTime||(.1<Math.abs(e.endTime-f.endTime)?b.push(f):b.push(e),c++),d++)}for(;c<this.a.length;)b.push(this.a[c++]);if(b.length)for(c=b[b.length-1].position+1;d<a.length;)f=a[d++],f=new J(c++,f.startTime,f.endTime,f.a,f.M,f.D),b.push(f);else b=a;this.a=b};O.prototype.merge=O.prototype.Za;\nO.prototype.Ta=function(a){for(var b=0;b<this.a.length&&!(this.a[b].endTime>a);++b);this.a.splice(0,b)};O.prototype.evict=O.prototype.Ta;function Vb(a){this.b=a;this.a=new Jb(a);Wb||(Wb=[new Uint8Array([255]),new Uint8Array([127,255]),new Uint8Array([63,255,255]),new Uint8Array([31,255,255,255]),new Uint8Array([15,255,255,255,255]),new Uint8Array([7,255,255,255,255,255]),new Uint8Array([3,255,255,255,255,255,255]),new Uint8Array([1,255,255,255,255,255,255,255])])}var Wb;\nfunction Xb(a){var b;b=Yb(a);if(7<b.length)throw new v(3,3002);for(var c=0,d=0;d<b.length;d++)c=256*c+b[d];b=c;c=Yb(a);a:{for(d=0;d<Wb.length;d++)if(Ua(c,Wb[d])){d=!0;break a}d=!1}if(d)c=a.b.byteLength-a.a.a;else{if(8==c.length&&c[1]&224)throw new v(3,3001);for(var d=c[0]&(1<<8-c.length)-1,e=1;e<c.length;e++)d=256*d+c[e];c=d}c=a.a.a+c<=a.b.byteLength?c:a.b.byteLength-a.a.a;d=new DataView(a.b.buffer,a.b.byteOffset+a.a.a,c);N(a.a,c);return new Zb(b,d)}\nfunction Yb(a){var b=Mb(a.a),c;for(c=1;8>=c&&!(b&1<<8-c);c++);if(8<c)throw new v(3,3002);var d=new Uint8Array(c);d[0]=b;for(b=1;b<c;b++)d[b]=Mb(a.a);return d}function Zb(a,b){this.id=a;this.a=b}function $b(a){if(8<a.a.byteLength)throw new v(3,3002);if(8==a.a.byteLength&&a.a.getUint8(0)&224)throw new v(3,3001);for(var b=0,c=0;c<a.a.byteLength;c++)var d=a.a.getUint8(c),b=256*b+d;return b};function ac(a,b,c,d,e,f){function g(){return e}var h=[];a=new Vb(a.a);for(var l=-1,n=-1;Lb(a.a);){var r=Xb(a);if(187==r.id){var u=bc(r);u&&(r=c*(u.hd-f),u=b+u.Fc,0<=l&&h.push(new J(h.length,l,r,g,n,u-1)),l=r,n=u)}}0<=l&&h.push(new J(h.length,l,d,g,n,null));return h}function bc(a){var b=new Vb(a.a);a=Xb(b);if(179!=a.id)throw new v(3,3013);a=$b(a);b=Xb(b);if(183!=b.id)throw new v(3,3012);for(var b=new Vb(b.a),c=0;Lb(b.a);){var d=Xb(b);if(241==d.id){c=$b(d);break}}return{hd:a,Fc:c}};function cc(a,b){var c=Db(a,b,\"Initialization\");if(!c)return null;var d=a.u.N,e=c.getAttribute(\"sourceURL\");e&&(d=K(a.u.N,[e]));var e=0,f=null;if(c=H(c,\"range\",Ya))e=c.start,f=c.end;return new yb(function(){return d},e,f)}\nfunction dc(a,b){var c=L(a,ec,\"presentationTimeOffset\"),d=cc(a,ec),e;e=Number(c);var f=a.u.contentType,g=a.u.mimeType.split(\"/\")[1];if(\"text\"!=f&&\"mp4\"!=g&&\"webm\"!=g)throw new v(4,4006);if(\"webm\"==g&&!d)throw new v(4,4005);var f=Db(a,ec,\"RepresentationIndex\"),h=L(a,ec,\"indexRange\"),l=a.u.N,h=Ya(h||\"\");if(f){var n=f.getAttribute(\"sourceURL\");n&&(l=K(a.u.N,[n]));h=H(f,\"range\",Ya,h)}if(!h)throw new v(4,4002);e=fc(a,b,d,l,h.start,h.end,g,e);return{createSegmentIndex:e.createSegmentIndex,findSegmentPosition:e.findSegmentPosition,\ngetSegmentReference:e.getSegmentReference,initSegmentReference:d,presentationTimeOffset:Number(c)||0}}\nfunction fc(a,b,c,d,e,f,g,h){var l=a.presentationTimeline,n=a.I.start,r=a.I.duration,u=b,X=null;return{createSegmentIndex:function(){var b=[u(d,e,f),\"webm\"==g?u(c.a(),c.M,c.D):null];u=null;return Promise.all(b).then(function(b){var c,f,u=b[0];b=b[1]||null;if(\"mp4\"==g)u=Ub(u,e,d,h);else{b=new Vb(new DataView(b));if(440786851!=Xb(b).id)throw new v(3,3008);f=Xb(b);if(408125543!=f.id)throw new v(3,3009);b=f.a.byteOffset;f=new Vb(f.a);for(c=null;Lb(f.a);){var D=Xb(f);if(357149030==D.id){c=D;break}}if(!c)throw new v(3,\n3010);c=new Vb(c.a);D=1E6;for(f=null;Lb(c.a);){var E=Xb(c);if(2807729==E.id)D=$b(E);else if(17545==E.id)if(f=E,4==f.a.byteLength)f=f.a.getFloat32(0);else if(8==f.a.byteLength)f=f.a.getFloat64(0);else throw new v(3,3003);}if(null==f)throw new v(3,3011);c=D/=1E9;f*=D;u=Xb(new Vb(new DataView(u)));if(475249515!=u.id)throw new v(3,3007);u=ac(u,b,c,f,d,h)}Bb(a.Sa,r,u);l.Ha(n,u);X=new O(u)})},findSegmentPosition:function(a){return X.find(a)},getSegmentReference:function(a){return X.get(a)}}}\nfunction ec(a){return a.Ia};function gc(a,b){var c=cc(a,hc),d;d=ic(a);var e=Cb(a,hc),f=e.ja;f||(f=1);var g=0;e.G?g=e.G*(f-1):e.w&&0<e.w.length&&(g=e.w[0].start);d={G:e.G,startTime:g,ja:f,presentationTimeOffset:e.presentationTimeOffset,w:e.w,wa:d};if(!d.G&&!d.w&&1<d.wa.length)throw new v(4,4002);if(!d.G&&!a.I.duration&&!d.w&&1==d.wa.length)throw new v(4,4002);if(d.w&&!d.w.length)throw new v(4,4002);f=e=null;a.L.id&&a.u.id&&(f=a.L.id+\",\"+a.u.id,e=b[f]);g=jc(a.I.duration,d.ja,a.u.N,d);Bb(a.Sa,a.I.duration,g);e?(e.Za(g),e.Ta(a.presentationTimeline.ua()-\na.I.start)):(a.presentationTimeline.Ha(a.I.start,g),e=new O(g),f&&(b[f]=e));return{createSegmentIndex:Promise.resolve.bind(Promise),findSegmentPosition:e.find.bind(e),getSegmentReference:e.get.bind(e),initSegmentReference:c,presentationTimeOffset:d.presentationTimeOffset}}function hc(a){return a.$}\nfunction jc(a,b,c,d){var e=d.wa.length;d.w&&d.w.length!=d.wa.length&&(e=Math.min(d.w.length,d.wa.length));for(var f=[],g=d.startTime,h=0;h<e;h++){var l=d.wa[h],n=K(c,[l.ic]),r;r=null!=d.G?g+d.G:d.w?d.w[h].end:g+a;f.push(new J(h+b,g,r,function(a){return a}.bind(null,n),l.start,l.end));g=r}return f}\nfunction ic(a){return[a.u.$,a.R.$,a.L.$].filter(Ka).map(function(a){return G(a,\"SegmentURL\")}).reduce(function(a,c){return 0<a.length?a:c}).map(function(b){b.getAttribute(\"indexRange\")&&!a.tb&&(a.tb=!0);var c=b.getAttribute(\"media\");b=H(b,\"mediaRange\",Ya,{start:0,end:null});return{ic:c,start:b.start,end:b.end}})};function kc(a,b,c,d){var e=lc(a),f;f=Cb(a,mc);var g=L(a,mc,\"media\"),h=L(a,mc,\"index\");f={G:f.G,timescale:f.timescale,ja:f.ja,presentationTimeOffset:f.presentationTimeOffset,lb:f.lb,w:f.w,Ya:g,Fa:h};g=0+(f.Fa?1:0);g+=f.w?1:0;g+=f.G?1:0;if(!g)throw new v(4,4002);1!=g&&(f.Fa&&(f.w=null),f.G=null);if(!f.Fa&&!f.Ya)throw new v(4,4002);if(f.Fa){c=a.u.mimeType.split(\"/\")[1];if(\"mp4\"!=c&&\"webm\"!=c)throw new v(4,4006);if(\"webm\"==c&&!e)throw new v(4,4005);d=Ab(f.Fa,a.u.id,null,a.bandwidth||null,null);d=K(a.u.N,\n[d]);a=fc(a,b,e,d,0,null,c,f.presentationTimeOffset)}else f.G?(d||a.presentationTimeline.$a(f.G),a=nc(a,f)):(d=b=null,a.L.id&&a.u.id&&(d=a.L.id+\",\"+a.u.id,b=c[d]),g=oc(a,f),Bb(a.Sa,a.I.duration,g),b?(b.Za(g),b.Ta(a.presentationTimeline.ua()-a.I.start)):(a.presentationTimeline.Ha(a.I.start,g),b=new O(g),d&&(c[d]=b)),a={createSegmentIndex:Promise.resolve.bind(Promise),findSegmentPosition:b.find.bind(b),getSegmentReference:b.get.bind(b)});return{createSegmentIndex:a.createSegmentIndex,findSegmentPosition:a.findSegmentPosition,\ngetSegmentReference:a.getSegmentReference,initSegmentReference:e,presentationTimeOffset:f.presentationTimeOffset}}function mc(a){return a.Ja}\nfunction nc(a,b){var c=a.I.duration,d=b.G,e=b.ja,f=b.timescale,g=b.Ya,h=a.bandwidth||null,l=a.u.id,n=a.u.N;return{createSegmentIndex:Promise.resolve.bind(Promise),findSegmentPosition:function(a){return 0>a||c&&a>=c?null:Math.floor(a/d)},getSegmentReference:function(a){var b=a*d;return 0>b||c&&b>=c?null:new J(a,b,b+d,function(){var c=Ab(g,l,a+e,h,b*f);return K(n,[c])},0,null)}}}\nfunction oc(a,b){for(var c=[],d=0;d<b.w.length;d++){var e=d+b.ja;c.push(new J(e,b.w[d].start,b.w[d].end,function(a,b,c,d,e,r){a=Ab(a,b,e,c,r);return K(d,[a]).map(function(a){return a.toString()})}.bind(null,b.Ya,a.u.id,a.bandwidth||null,a.u.N,e,b.w[d].gd+b.lb),0,null))}return c}function lc(a){var b=L(a,mc,\"initialization\");if(!b)return null;var c=a.u.id,d=a.bandwidth||null,e=a.u.N;return new yb(function(){var a=Ab(b,c,null,d,null);return K(e,[a])},0,null)};function P(a){this.f=!1;this.a=[];this.b=[];this.c=[];this.h=a||null}m(\"shaka.net.NetworkingEngine\",P);P.RequestType={MANIFEST:0,SEGMENT:1,LICENSE:2};var pc={};P.registerScheme=function(a,b){pc[a]=b};P.unregisterScheme=function(a){delete pc[a]};P.prototype.Ec=function(a){this.b.push(a)};P.prototype.registerRequestFilter=P.prototype.Ec;P.prototype.fd=function(a){var b=this.b;a=b.indexOf(a);0<=a&&b.splice(a,1)};P.prototype.unregisterRequestFilter=P.prototype.fd;P.prototype.Tb=function(){this.b=[]};\nP.prototype.clearAllRequestFilters=P.prototype.Tb;P.prototype.Eb=function(a){this.c.push(a)};P.prototype.registerResponseFilter=P.prototype.Eb;P.prototype.Ob=function(a){var b=this.c;a=b.indexOf(a);0<=a&&b.splice(a,1)};P.prototype.unregisterResponseFilter=P.prototype.Ob;P.prototype.Ub=function(){this.c=[]};P.prototype.clearAllResponseFilters=P.prototype.Ub;function qc(){return{maxAttempts:2,baseDelay:1E3,backoffFactor:2,fuzzFactor:.5,timeout:0}}\nfunction rc(a,b){return{uris:a,method:\"GET\",body:null,headers:{},allowCrossSiteCredentials:!1,retryParameters:b}}P.prototype.o=function(){this.f=!0;this.b=[];this.c=[];for(var a=[],b=0;b<this.a.length;++b)a.push(this.a[b][\"catch\"](C));return Promise.all(a)};P.prototype.destroy=P.prototype.o;\nP.prototype.request=function(a,b){if(this.f)return Promise.reject();for(var c=Date.now(),d=this.b,e=0;e<d.length;e++)try{d[e](a,b)}catch(l){return Promise.reject(l)}for(var e=b.retryParameters||{},d=e.maxAttempts||1,f=e.backoffFactor||2,g=null==e.baseDelay?1E3:e.baseDelay,h=this.g(a,b,0),e=1;e<d;e++)h=h[\"catch\"](this.i.bind(this,a,b,g,e%b.uris.length)),g*=f;this.a.push(h);return h.then(function(b){0<=this.a.indexOf(h)&&this.a.splice(this.a.indexOf(h),1);var d=Date.now();this.h&&1==a&&this.h(c,d,b.data.byteLength);\nreturn b}.bind(this))[\"catch\"](function(a){0<=this.a.indexOf(h)&&this.a.splice(this.a.indexOf(h),1);return Promise.reject(a)}.bind(this))};P.prototype.request=P.prototype.request;P.prototype.g=function(a,b,c){if(this.f)return Promise.reject();var d=new kb(b.uris[c]),e=d.T;e||(e=location.protocol,e=e.slice(0,-1),lb(d,e),b.uris[c]=d.toString());return(e=pc[e])?e(b.uris[c],b).then(function(b){for(var c=this.c,d=0;d<c.length;d++)c[d](a,b);return b}.bind(this)):Promise.reject(new v(1,1E3,d))};\nP.prototype.i=function(a,b,c,d){var e=new w,f=b.retryParameters||{};window.setTimeout(e.resolve,c*(1+(2*Math.random()-1)*(null==f.fuzzFactor?.5:f.fuzzFactor)));return e.then(this.g.bind(this,a,b,d))};var sc={},tc={};m(\"shaka.media.ManifestParser.registerParserByExtension\",function(a,b){tc[a]=b});m(\"shaka.media.ManifestParser.registerParserByMime\",function(a,b){sc[a]=b});function uc(){var a={},b;for(b in sc)a[b]=!0;for(b in tc)a[b]=!0;[\"application/dash+xml\",\"application/x-mpegurl\",\"application/vnd.apple.mpegurl\",\"application/vnd.ms-sstr+xml\"].forEach(function(b){a[b]=!!sc[b]});[\"mpd\",\"m3u8\",\"ism\"].forEach(function(b){a[b]=!!tc[b]});return a}\nfunction vc(a,b,c,d){var e=d;e||(d=(new kb(a)).P.split(\"/\").pop().split(\".\"),1<d.length&&(d=d.pop().toLowerCase(),e=tc[d]));if(e)return Promise.resolve(e);c=rc([a],c);c.method=\"HEAD\";return b.request(0,c).then(function(b){(b=b.headers[\"content-type\"])&&(b=b.toLowerCase());return(e=sc[b])?e:Promise.reject(new v(4,4E3,a))},function(a){return Promise.reject(a)})};function Q(a,b){this.j=a;this.i=b;this.c=this.a=Infinity;this.b=1;this.h=this.f=0;this.g=!0}m(\"shaka.media.PresentationTimeline\",Q);Q.prototype.ea=function(){return this.a};Q.prototype.getDuration=Q.prototype.ea;Q.prototype.Aa=function(a){this.a=a};Q.prototype.setDuration=Q.prototype.Aa;Q.prototype.Kb=function(a){this.h=a};Q.prototype.setClockOffset=Q.prototype.Kb;Q.prototype.Mb=function(a){this.g=a};Q.prototype.setStatic=Q.prototype.Mb;Q.prototype.bc=function(){return this.c};\nQ.prototype.getSegmentAvailabilityDuration=Q.prototype.bc;Q.prototype.Lb=function(a){this.c=a};Q.prototype.setSegmentAvailabilityDuration=Q.prototype.Lb;Q.prototype.Ha=function(a,b){b.length&&(this.b=b.reduce(function(a,b){return Math.max(a,b.endTime-b.startTime)},this.b),a||(this.f=Math.max(this.f,b[0].startTime)))};Q.prototype.notifySegments=Q.prototype.Ha;Q.prototype.$a=function(a){this.b=Math.max(this.b,a)};Q.prototype.notifyMaxSegmentDuration=Q.prototype.$a;\nQ.prototype.S=function(){return Infinity==this.a&&!this.g};Q.prototype.isLive=Q.prototype.S;Q.prototype.fa=function(){return Infinity!=this.a&&!this.g};Q.prototype.isInProgress=Q.prototype.fa;Q.prototype.ta=function(){return Math.max(Math.min(this.f,this.Z()),this.ua())};Q.prototype.getEarliestStart=Q.prototype.ta;Q.prototype.ua=function(){return Infinity==this.c?0:Math.max(0,this.Z()-this.c)};Q.prototype.getSegmentAvailabilityStart=Q.prototype.ua;\nQ.prototype.Z=function(){return this.S()||this.fa()?Math.min(Math.max(0,(Date.now()+this.h)/1E3-this.b-this.j),this.a):this.a};Q.prototype.getSegmentAvailabilityEnd=Q.prototype.Z;Q.prototype.Va=function(){return Math.max(0,this.Z()-(this.S()||this.fa()?this.i:0))};Q.prototype.getSeekRangeEnd=Q.prototype.Va;function wc(a,b,c){this.g=R[b];this.c=a;this.h=0;this.f=Infinity;this.a=this.b=null;this.i=c}var R={};m(\"shaka.media.TextEngine.registerParser\",function(a,b){R[a]=b});m(\"shaka.media.TextEngine.unregisterParser\",function(a){delete R[a]});function xc(a,b,c){return a>=b?null:new VTTCue(a,b,c)}m(\"shaka.media.TextEngine.makeCue\",xc);wc.prototype.o=function(){this.c&&yc(this,function(){return!0});this.c=this.g=null;return Promise.resolve()};\nfunction zc(a,b,c,d){var e=a.h;return Promise.resolve().then(function(){if(this.c){var a=this.g(b,e,c,d,this.i);if(null!=c&&null!=d){for(var g=0;g<a.length&&!(a[g].startTime>=this.f);++g)this.c.addCue(a[g]);null==this.b&&(this.b=c);this.a=Math.min(d,this.f)}}}.bind(a))}\nwc.prototype.remove=function(a,b){return Promise.resolve().then(function(){this.c&&(yc(this,function(c){return c.startTime>=b||c.endTime<=a?!1:!0}),null==this.b||b<=this.b||a>=this.a||(a<=this.b&&b>=this.a?this.b=this.a=null:a<=this.b&&b<this.a?this.b=b:a>this.b&&b>=this.a&&(this.a=a)))}.bind(this))};function Ac(a,b){return null==a.a||a.a<b||b<a.b?0:a.a-b}function yc(a,b){for(var c=a.c.cues,d=[],e=0;e<c.length;++e)b(c[e])&&d.push(c[e]);for(e=0;e<d.length;++e)a.c.removeCue(d[e])};function Bc(a,b,c){return c==b||a>=Cc&&c==b.split(\"-\")[0]||a>=Dc&&c.split(\"-\")[0]==b.split(\"-\")[0]?!0:!1}var Cc=1,Dc=2;function Ec(a){a=a.toLowerCase().split(\"-\");var b=Fc[a[0]];b&&(a[0]=b);return a.join(\"-\")}\nvar Fc={aar:\"aa\",abk:\"ab\",afr:\"af\",aka:\"ak\",alb:\"sq\",amh:\"am\",ara:\"ar\",arg:\"an\",arm:\"hy\",asm:\"as\",ava:\"av\",ave:\"ae\",aym:\"ay\",aze:\"az\",bak:\"ba\",bam:\"bm\",baq:\"eu\",bel:\"be\",ben:\"bn\",bih:\"bh\",bis:\"bi\",bod:\"bo\",bos:\"bs\",bre:\"br\",bul:\"bg\",bur:\"my\",cat:\"ca\",ces:\"cs\",cha:\"ch\",che:\"ce\",chi:\"zh\",chu:\"cu\",chv:\"cv\",cor:\"kw\",cos:\"co\",cre:\"cr\",cym:\"cy\",cze:\"cs\",dan:\"da\",deu:\"de\",div:\"dv\",dut:\"nl\",dzo:\"dz\",ell:\"el\",eng:\"en\",epo:\"eo\",est:\"et\",eus:\"eu\",ewe:\"ee\",fao:\"fo\",fas:\"fa\",fij:\"fj\",fin:\"fi\",fra:\"fr\",fre:\"fr\",\nfry:\"fy\",ful:\"ff\",geo:\"ka\",ger:\"de\",gla:\"gd\",gle:\"ga\",glg:\"gl\",glv:\"gv\",gre:\"el\",grn:\"gn\",guj:\"gu\",hat:\"ht\",hau:\"ha\",heb:\"he\",her:\"hz\",hin:\"hi\",hmo:\"ho\",hrv:\"hr\",hun:\"hu\",hye:\"hy\",ibo:\"ig\",ice:\"is\",ido:\"io\",iii:\"ii\",iku:\"iu\",ile:\"ie\",ina:\"ia\",ind:\"id\",ipk:\"ik\",isl:\"is\",ita:\"it\",jav:\"jv\",jpn:\"ja\",kal:\"kl\",kan:\"kn\",kas:\"ks\",kat:\"ka\",kau:\"kr\",kaz:\"kk\",khm:\"km\",kik:\"ki\",kin:\"rw\",kir:\"ky\",kom:\"kv\",kon:\"kg\",kor:\"ko\",kua:\"kj\",kur:\"ku\",lao:\"lo\",lat:\"la\",lav:\"lv\",lim:\"li\",lin:\"ln\",lit:\"lt\",ltz:\"lb\",lub:\"lu\",\nlug:\"lg\",mac:\"mk\",mah:\"mh\",mal:\"ml\",mao:\"mi\",mar:\"mr\",may:\"ms\",mkd:\"mk\",mlg:\"mg\",mlt:\"mt\",mon:\"mn\",mri:\"mi\",msa:\"ms\",mya:\"my\",nau:\"na\",nav:\"nv\",nbl:\"nr\",nde:\"nd\",ndo:\"ng\",nep:\"ne\",nld:\"nl\",nno:\"nn\",nob:\"nb\",nor:\"no\",nya:\"ny\",oci:\"oc\",oji:\"oj\",ori:\"or\",orm:\"om\",oss:\"os\",pan:\"pa\",per:\"fa\",pli:\"pi\",pol:\"pl\",por:\"pt\",pus:\"ps\",que:\"qu\",roh:\"rm\",ron:\"ro\",rum:\"ro\",run:\"rn\",rus:\"ru\",sag:\"sg\",san:\"sa\",sin:\"si\",slk:\"sk\",slo:\"sk\",slv:\"sl\",sme:\"se\",smo:\"sm\",sna:\"sn\",snd:\"sd\",som:\"so\",sot:\"st\",spa:\"es\",sqi:\"sq\",\nsrd:\"sc\",srp:\"sr\",ssw:\"ss\",sun:\"su\",swa:\"sw\",swe:\"sv\",tah:\"ty\",tam:\"ta\",tat:\"tt\",tel:\"te\",tgk:\"tg\",tgl:\"tl\",tha:\"th\",tib:\"bo\",tir:\"ti\",ton:\"to\",tsn:\"tn\",tso:\"ts\",tuk:\"tk\",tur:\"tr\",twi:\"tw\",uig:\"ug\",ukr:\"uk\",urd:\"ur\",uzb:\"uz\",ven:\"ve\",vie:\"vi\",vol:\"vo\",wel:\"cy\",wln:\"wa\",wol:\"wo\",xho:\"xh\",yid:\"yi\",yor:\"yo\",zha:\"za\",zho:\"zh\",zul:\"zu\"};function Gc(a,b,c){for(var d=0;d<a.length;++d)if(c(a[d],b))return d;return-1};function Hc(a){this.a=null;this.b=function(){this.a=null;a()}.bind(this)}Hc.prototype.cancel=function(){null!=this.a&&(clearTimeout(this.a),this.a=null)};function Ic(a){a.cancel();a.a=setTimeout(a.b,100)};function Jc(a,b,c){this.l=this.h=this.s=null;this.B=!1;this.b=null;this.f=new x;this.a=[];this.m=[];this.j=new w;this.H=a;this.i=null;this.g=function(a){this.j.reject(a);b(a)}.bind(this);this.A={};this.K=c;this.v=new Hc(this.Dc.bind(this));this.C=this.c=!1;this.j[\"catch\"](function(){})}k=Jc.prototype;\nk.o=function(){this.c=!0;var a=this.a.map(function(a){return(a.ha.close()||Promise.resolve())[\"catch\"](C)});this.j.reject();this.f&&a.push(this.f.o());this.l&&a.push(this.l.setMediaKeys(null)[\"catch\"](C));this.v&&this.v.cancel();this.f=this.l=this.h=this.s=this.b=this.v=null;this.a=[];this.m=[];this.g=this.i=this.H=null;return Promise.all(a)};k.configure=function(a){this.i=a};\nk.init=function(a,b){var c={},d=[];this.C=b;this.m=a.offlineSessionIds;Kc(this,a,b||0<a.offlineSessionIds.length,c,d);return d.length?Lc(this,c,d):(this.B=!0,Promise.resolve())};\nfunction Mc(a,b){if(!a.h)return y(a.f,b,\"encrypted\",function(){this.f.la(b,\"encrypted\");this.g(new v(6,6010))}.bind(a)),Promise.resolve();a.l=b;var c=a.l.setMediaKeys(a.h),c=c[\"catch\"](function(a){return Promise.reject(new v(6,6003,a.message))}),d=null;a.b.serverCertificate&&(d=a.h.setServerCertificate(a.b.serverCertificate),d=d[\"catch\"](function(a){return Promise.reject(new v(6,6004,a.message))}));return Promise.all([c,d]).then(function(){if(this.c)return Promise.reject();Nc(this);this.b.initData.length||\nthis.m.length||y(this.f,this.l,\"encrypted\",this.jc.bind(this))}.bind(a))[\"catch\"](function(a){return this.c?Promise.resolve():Promise.reject(a)}.bind(a))}function Oc(a,b){return Promise.all(b.map(function(a){return Pc(this,a).then(function(a){if(a){for(var b=new w,c=0;c<this.a.length;c++)if(this.a[c].ha==a){this.a[c].Oa=b;break}return Promise.all([a.remove(),b])}}.bind(this))}.bind(a)))}\nfunction Nc(a){var b=a.b?a.b.initData:[];b.forEach(function(a){Qc(this,a.initDataType,a.initData)}.bind(a));a.m.forEach(function(a){Pc(this,a)}.bind(a));b.length||a.m.length||a.j.resolve();return a.j}k.keySystem=function(){return this.b?this.b.keySystem:\"\"};function Rc(a){return a.a.map(function(a){return a.ha.sessionId})}\nfunction Kc(a,b,c,d,e){var f=Sc(a);b.periods.forEach(function(a){a.streamSets.forEach(function(a){\"text\"!=a.type&&(f&&(a.drmInfos=[f]),a.drmInfos.forEach(function(b){Tc(this,b);var f=d[b.keySystem];f||(f={audioCapabilities:[],videoCapabilities:[],distinctiveIdentifier:\"optional\",persistentState:c?\"required\":\"optional\",sessionTypes:[c?\"persistent-license\":\"temporary\"],label:b.keySystem,drmInfos:[]},d[b.keySystem]=f,e.push(b.keySystem));f.drmInfos.push(b);b.distinctiveIdentifierRequired&&(f.distinctiveIdentifier=\n\"required\");b.persistentStateRequired&&(f.persistentState=\"required\");var g=\"video\"==a.type?f.videoCapabilities:f.audioCapabilities,h=(\"video\"==a.type?b.videoRobustness:b.audioRobustness)||\"\";a.streams.forEach(function(a){var c=a.mimeType;a.codecs&&(c+='; codecs=\"'+a.codecs+'\"');a.keyId&&b.keyIds.push(a.keyId);g.push({robustness:h,contentType:c})}.bind(this))}.bind(this)))}.bind(this))}.bind(a))}\nfunction Lc(a,b,c){if(1==c.length&&\"\"==c[0])return Promise.reject(new v(6,6E3));var d=new w,e=d;[!0,!1].forEach(function(a){c.forEach(function(c){var d=b[c];d.drmInfos.some(function(a){return!!a.licenseServerUri})==a&&(d.audioCapabilities.length||delete d.audioCapabilities,d.videoCapabilities.length||delete d.videoCapabilities,e=e[\"catch\"](function(){return this.c?Promise.reject():navigator.requestMediaKeySystemAccess(c,[d])}.bind(this)))}.bind(this))}.bind(a));e=e[\"catch\"](function(){return Promise.reject(new v(6,\n6001))});e=e.then(function(a){if(this.c)return Promise.reject();var c=0<=navigator.userAgent.indexOf(\"Edge/\"),d=a.getConfiguration();this.s=(d.audioCapabilities||[]).concat(d.videoCapabilities||[]).map(function(a){return a.contentType});c&&(this.s=null);c=b[a.keySystem];Uc(this,a.keySystem,c,c.drmInfos);return this.b.licenseServerUri?a.createMediaKeys():Promise.reject(new v(6,6012))}.bind(a)).then(function(a){if(this.c)return Promise.reject();this.h=a;this.B=!0}.bind(a))[\"catch\"](function(a){if(this.c)return Promise.resolve();\nthis.s=this.b=null;return a instanceof v?Promise.reject(a):Promise.reject(new v(6,6002,a.message))}.bind(a));d.reject();return e}\nfunction Tc(a,b){var c=b.keySystem;if(c){if(!b.licenseServerUri){var d=a.i.servers[c];d&&(b.licenseServerUri=d)}b.keyIds||(b.keyIds=[]);if(c=a.i.advanced[c])b.distinctiveIdentifierRequired||(b.distinctiveIdentifierRequired=c.distinctiveIdentifierRequired),b.persistentStateRequired||(b.persistentStateRequired=c.persistentStateRequired),b.videoRobustness||(b.videoRobustness=c.videoRobustness),b.audioRobustness||(b.audioRobustness=c.audioRobustness),b.serverCertificate||(b.serverCertificate=c.serverCertificate)}}\nfunction Sc(a){if(Na(a.i.clearKeys))return null;var b=[],c=[],d;for(d in a.i.clearKeys){var e=a.i.clearKeys[d],f=Sa(d),e=Sa(e),f={kty:\"oct\",kid:Qa(f),k:Qa(e)};b.push(f);c.push(f.kid)}a=JSON.stringify({keys:b});c=JSON.stringify({kids:c});c=[{initData:new Uint8Array(Ib(c)),initDataType:\"keyids\"}];return{keySystem:\"org.w3.clearkey\",licenseServerUri:\"data:application/json;base64,\"+window.btoa(a),distinctiveIdentifierRequired:!1,persistentStateRequired:!1,audioRobustness:\"\",videoRobustness:\"\",serverCertificate:null,\ninitData:c,keyIds:[]}}function Uc(a,b,c,d){var e=[],f=[],g=[],h=[];Vc(d,e,f,g,h);a.b={keySystem:b,licenseServerUri:e[0],distinctiveIdentifierRequired:\"required\"==c.distinctiveIdentifier,persistentStateRequired:\"required\"==c.persistentState,audioRobustness:c.audioCapabilities?c.audioCapabilities[0].robustness:\"\",videoRobustness:c.videoCapabilities?c.videoCapabilities[0].robustness:\"\",serverCertificate:f[0],initData:g,keyIds:h}}\nfunction Vc(a,b,c,d,e){function f(a,b){return a.initDataType==b.initDataType&&Ua(a.initData,b.initData)}a.forEach(function(a){-1==b.indexOf(a.licenseServerUri)&&b.push(a.licenseServerUri);a.serverCertificate&&-1==Gc(c,a.serverCertificate,Ua)&&c.push(a.serverCertificate);a.initData&&a.initData.forEach(function(a){-1==Gc(d,a,f)&&d.push(a)});if(a.keyIds)for(var g=0;g<a.keyIds.length;++g)-1==e.indexOf(a.keyIds[g])&&e.push(a.keyIds[g])})}\nk.jc=function(a){for(var b=new Uint8Array(a.initData),c=0;c<this.a.length;++c)if(Ua(b,this.a[c].initData))return;Qc(this,a.initDataType,b)};\nfunction Pc(a,b){var c;try{c=a.h.createSession(\"persistent-license\")}catch(f){var d=new v(6,6005,f.message);a.g(d);return Promise.reject(d)}y(a.f,c,\"message\",a.Bb.bind(a));y(a.f,c,\"keystatuseschange\",a.wb.bind(a));var e={initData:null,ha:c,loaded:!1,Oa:null};a.a.push(e);return c.load(b).then(function(a){if(!this.c){if(a)return e.loaded=!0,this.a.every(function(a){return a.loaded})&&this.j.resolve(),c;this.a.splice(this.a.indexOf(e),1);this.g(new v(6,6013))}}.bind(a),function(a){this.c||(this.a.splice(this.a.indexOf(e),\n1),this.g(new v(6,6005,a.message)))}.bind(a))}function Qc(a,b,c){var d;try{d=a.C?a.h.createSession(\"persistent-license\"):a.h.createSession()}catch(e){a.g(new v(6,6005,e.message));return}y(a.f,d,\"message\",a.Bb.bind(a));y(a.f,d,\"keystatuseschange\",a.wb.bind(a));a.a.push({initData:c,ha:d,loaded:!1,Oa:null});d.generateRequest(b,c.buffer)[\"catch\"](function(a){if(!this.c){for(var b=0;b<this.a.length;++b)if(this.a[b].ha==d){this.a.splice(b,1);break}this.g(new v(6,6006,a.message))}}.bind(a))}\nk.Bb=function(a){for(var b=a.target,c,d=0;d<this.a.length;d++)if(this.a[d].ha==b){c=this.a[d].Oa;break}d=rc([this.b.licenseServerUri],this.i.retryParameters);d.body=a.message;d.method=\"POST\";\"com.microsoft.playready\"==this.b.keySystem&&Wc(d);this.H.request(2,d).then(function(a){return this.c?Promise.reject():b.update(a.data).then(function(){c&&c.resolve()})}.bind(this),function(a){if(this.c)return Promise.resolve();a=new v(6,6007,a);this.g(a);c&&c.reject(a)}.bind(this))[\"catch\"](function(a){if(this.c)return Promise.resolve();\na=new v(6,6008,a.message);this.g(a);c&&c.reject(a)}.bind(this))};function Wc(a){for(var b=Gb(a.body,!0),b=(new DOMParser).parseFromString(b,\"application/xml\"),c=b.getElementsByTagName(\"HttpHeader\"),d=0;d<c.length;++d)a.headers[c[d].querySelector(\"name\").textContent]=c[d].querySelector(\"value\").textContent;a.body=Ra(b.querySelector(\"Challenge\").textContent).buffer}\nk.wb=function(a){a=a.target;var b;for(b=0;b<this.a.length&&this.a[b].ha!=a;++b);if(b!=this.a.length){var c=!1;a.keyStatuses.forEach(function(a,d){if(\"string\"==typeof d){var e=d;d=a;a=e}if(\"com.microsoft.playready\"==this.b.keySystem&&16==d.byteLength){var e=new DataView(d),f=e.getUint32(0,!0),l=e.getUint16(4,!0),n=e.getUint16(6,!0);e.setUint32(0,f,!1);e.setUint16(4,l,!1);e.setUint16(6,n,!1)}\"com.microsoft.playready\"==this.b.keySystem&&\"status-pending\"==a&&(a=\"usable\");\"status-pending\"!=a&&(this.a[b].loaded=\n!0,this.a.every(function(a){return a.loaded})&&this.j.resolve());\"expired\"==a&&(c=!0);e=Ta(new Uint8Array(d));this.A[e]=a}.bind(this));var d=a.expiration-Date.now();(0>d||c&&1E3>d)&&!this.a[b].Oa&&(this.a.splice(b,1),a.close());Ic(this.v)}};k.Dc=function(){Pa(this.A,function(a,b){return\"expired\"==b})&&this.g(new v(6,6014));this.K(this.A)};\nfunction Xc(){var a=[],b=[{contentType:'video/mp4; codecs=\"avc1.42E01E\"'},{contentType:'video/webm; codecs=\"vp8\"'}],c=[{videoCapabilities:b,persistentState:\"required\",sessionTypes:[\"persistent-license\"]},{videoCapabilities:b}],d={};\"org.w3.clearkey com.widevine.alpha com.microsoft.playready com.apple.fps.2_0 com.apple.fps.1_0 com.apple.fps com.adobe.primetime\".split(\" \").forEach(function(b){var e=navigator.requestMediaKeySystemAccess(b,c).then(function(a){var c=a.getConfiguration().sessionTypes;d[b]=\n{persistentState:c?0<=c.indexOf(\"persistent-license\"):!1};return a.createMediaKeys()})[\"catch\"](function(){d[b]=null});a.push(e)});return Promise.all(a).then(function(){return d})};function Zc(a){return!a||1==a.length&&1E-6>a.end(0)-a.start(0)?null:a.length?a.end(a.length-1):null}function $c(a,b){var c=0;if(!a||1==a.length&&1E-6>a.end(0)-a.start(0))return c;var d=!1,e=1E-4;b||(e=.25);for(var f=0;f<a.length;++f)if(b+e>=a.start(f)&&b<a.end(f))c+=a.end(f)-b,d=!0;else if(d&&.04>=a.start(f)-a.end(f-1))c+=a.end(f)-a.start(f),c+=a.start(f)-a.end(f-1);else if(0<f&&b+e<a.start(f)&&b+e>=a.end(f-1))if(.04>=a.start(f)-b)c+=a.end(f)-b,d=!0;else break;else d=!1;return c}\nfunction ad(a,b,c){var d=$c(a,b);d||(d=$c(a,b+c))&&(d+=c);return d};function bd(a,b,c){this.f=a;this.F=b;this.i=c;this.c={};this.b=null;this.a={};this.g=new x;this.h=!1}\nfunction cd(){var a={};'video/mp4; codecs=\"avc1.42E01E\",video/mp4; codecs=\"avc3.42E01E\",video/mp4; codecs=\"hvc1.1.6.L93.90\",audio/mp4; codecs=\"mp4a.40.2\",audio/mp4; codecs=\"ac-3\",audio/mp4; codecs=\"ec-3\",video/webm; codecs=\"vp8\",video/webm; codecs=\"vp9\",video/webm; codecs=\"av1\",audio/webm; codecs=\"vorbis\",audio/webm; codecs=\"opus\",video/mp2t; codecs=\"avc1.42E01E\",video/mp2t; codecs=\"avc3.42E01E\",video/mp2t; codecs=\"hvc1.1.6.L93.90\",video/mp2t; codecs=\"mp4a.40.2\",video/mp2t; codecs=\"ac-3\",video/mp2t; codecs=\"ec-3\",video/mp2t; codecs=\"mp4a.40.2\",text/vtt,application/mp4; codecs=\"wvtt\",application/ttml+xml,application/mp4; codecs=\"stpp\"'.split(\",\").forEach(function(b){a[b]=!!R[b]||\nMediaSource.isTypeSupported(b);var c=b.split(\";\")[0];a[c]=a[c]||a[b]});return a}k=bd.prototype;k.o=function(){this.h=!0;var a=[],b;for(b in this.a){var c=this.a[b],d=c[0];this.a[b]=c.slice(0,1);d&&a.push(d.p[\"catch\"](C));for(d=1;d<c.length;++d)c[d].p[\"catch\"](C),c[d].p.reject()}this.b&&a.push(this.b.o());return Promise.all(a).then(function(){this.g.o();this.b=this.i=this.F=this.f=this.g=null;this.c={};this.a={}}.bind(this))};\nk.init=function(a,b){for(var c in a){var d=a[c];\"text\"==c?this.b=new wc(this.i,d,b):(d=this.F.addSourceBuffer(d),y(this.g,d,\"error\",this.$c.bind(this,c)),y(this.g,d,\"updateend\",this.xa.bind(this,c)),this.c[c]=d,this.a[c]=[])}};function dd(a,b){var c;\"text\"==b?c=a.b.b:(c=ed(a,b),c=!c||1==c.length&&1E-6>c.end(0)-c.start(0)?null:1==c.length&&0>c.start(0)?0:c.length?c.start(0):null);return c}\nfunction fd(a,b,c,d){\"text\"==b?(b=Ac(a.b,c),!b&&d&&(b=Ac(a.b,c+d))&&(b+=d)):(a=ed(a,b),b=ad(a,c,d||0));return b}function ed(a,b){try{return a.c[b].buffered}catch(c){return null}}function gd(a,b,c,d,e){return\"text\"==b?zc(a.b,c,d,e):hd(a,b,a.Zc.bind(a,b,c))}k.remove=function(a,b,c){return\"text\"==a?this.b.remove(b,c):hd(this,a,this.Gb.bind(this,a,b,c))};function id(a,b){return\"text\"==b?a.b.remove(0,Infinity):hd(a,b,a.Gb.bind(a,b,0,a.F.duration))}\nfunction jd(a,b,c){return\"text\"==b?(a.b.h=c,Promise.resolve()):hd(a,b,a.Pc.bind(a,b,c))}function kd(a,b,c){return\"text\"==b?(a.b.f=c,Promise.resolve()):Promise.all([hd(a,b,a.Pb.bind(a,b)),hd(a,b,a.Nc.bind(a,b,c))])}k.endOfStream=function(a){return ld(this,function(){a?this.F.endOfStream(a):this.F.endOfStream()}.bind(this))};k.Aa=function(a){return ld(this,function(){this.F.duration=a}.bind(this))};k.ea=function(){return this.F.duration};k.Zc=function(a,b){this.c[a].appendBuffer(b)};\nk.Gb=function(a,b,c){c<=b?this.xa(a):this.c[a].remove(b,c)};k.Pb=function(a){var b=this.c[a].appendWindowEnd;this.c[a].abort();this.c[a].appendWindowEnd=b;this.xa(a)};k.Yb=function(a){this.f.currentTime-=.001;this.xa(a)};k.Pc=function(a,b){this.c[a].timestampOffset=b;this.xa(a)};k.Nc=function(a,b){this.c[a].appendWindowEnd=b+.04;this.xa(a)};k.$c=function(a){this.a[a][0].p.reject(new v(3,3014,this.f.error?this.f.error.code:0))};k.xa=function(a){var b=this.a[a][0];b&&(b.p.resolve(),nd(this,a))};\nfunction hd(a,b,c){if(a.h)return Promise.reject();c={start:c,p:new w};a.a[b].push(c);if(1==a.a[b].length)try{c.start()}catch(d){\"QuotaExceededError\"==d.name?c.p.reject(new v(3,3017,b)):c.p.reject(new v(3,3015,d)),nd(a,b)}return c.p}\nfunction ld(a,b){if(a.h)return Promise.reject();var c=[],d;for(d in a.c){var e=new w,f={start:function(a){a.resolve()}.bind(null,e),p:e};a.a[d].push(f);c.push(e);1==a.a[d].length&&f.start()}return Promise.all(c).then(function(){var a,c;try{b()}catch(l){c=Promise.reject(new v(3,3015,l))}for(a in this.c)nd(this,a);return c}.bind(a),function(){return Promise.reject()}.bind(a))}function nd(a,b){a.a[b].shift();var c=a.a[b][0];if(c)try{c.start()}catch(d){c.p.reject(new v(3,3015,d)),nd(a,b)}};function od(a,b,c){var d=!1;a.streamSets.forEach(function(a){a.streams.forEach(function(e){var f=e.allowedByApplication;e.allowedByApplication=!0;if(\"video\"==a.type){if(e.width<b.minWidth||e.width>b.maxWidth||e.width>c.width||e.height<b.minHeight||e.height>b.maxHeight||e.height>c.height||e.width*e.height<b.minPixels||e.width*e.height>b.maxPixels||e.bandwidth<b.minVideoBandwidth||e.bandwidth>b.maxVideoBandwidth)e.allowedByApplication=!1}else\"audio\"==a.type&&(e.bandwidth<b.minAudioBandwidth||e.bandwidth>\nb.maxAudioBandwidth)&&(e.allowedByApplication=!1);f!=e.allowedByApplication&&(d=!0)})});return d}\nfunction pd(a,b,c){var d=\"\",e=null;a&&a.B&&(d=a.keySystem(),e=a.s);for(a=0;a<c.streamSets.length;++a){var f=c.streamSets[a];if(d&&f.drmInfos.length&&!f.drmInfos.some(function(a){return a.keySystem==d}))c.streamSets.splice(a,1),--a;else{for(var g=b[f.type],h=0;h<f.streams.length;++h){var l=f.streams[h],n=qd(l.mimeType,l.codecs);R[n]||MediaSource.isTypeSupported(n)?e&&l.encrypted&&0>e.indexOf(n)?(f.streams.splice(h,1),--h):!g||l.mimeType==g.mimeType&&l.codecs.split(\".\")[0]==g.codecs.split(\".\")[0]||\n(f.streams.splice(h,1),--h):(f.streams.splice(h,1),--h)}f.streams.length||(c.streamSets.splice(a,1),--a)}}}function rd(a,b){return a.streamSets.map(function(a){var c=b?b[a.type]:null;return a.streams.filter(function(a){return a.allowedByApplication&&a.allowedByKeySystem}).map(function(b){return{id:b.id,active:c==b,type:a.type,bandwidth:b.bandwidth,language:a.language,kind:b.kind||null,width:b.width||null,height:b.height||null,frameRate:b.frameRate||void 0,codecs:b.codecs||null}})}).reduce(B,[])}\nfunction sd(a,b){for(var c=0;c<a.streamSets.length;c++)for(var d=a.streamSets[c],e=0;e<d.streams.length;e++){var f=d.streams[e];if(f.id==b.id)return{stream:f,bd:d}}return null}function td(a){return a.streams.some(function(a){return a.allowedByApplication&&a.allowedByKeySystem})}\nfunction ud(a,b,c){var d={};a.streamSets.forEach(function(a){!td(a)||a.type in d||(d[a.type]=a)});var e=0;a.streamSets.forEach(function(a){if(td(a)&&\"video\"==a.type){var b=vd(a);b>e?(e=b,d.video=a):b==e&&wd(a)<wd(d.video)&&(d.video=a)}});a.streamSets.forEach(function(a){td(a)&&a.primary&&(d[a.type].primary?wd(a)<wd(d[a.type])&&(d[a.type]=a):d[a.type]=a)});[Dc,Cc,0].forEach(function(e){a.streamSets.forEach(function(a){if(td(a)){var f;\"audio\"==a.type?f=b.preferredAudioLanguage:\"text\"==a.type&&(f=b.preferredTextLanguage);\nif(f){f=Ec(f);var g=Ec(a.language);Bc(e,f,g)&&(a.language==d[a.type].language?wd(a)<wd(d[a.type])&&(d[a.type]=a):d[a.type]=a,c&&(c[a.type]=!0))}}})});return d}function wd(a){var b=0;if(!a||1>a.streams.length)return b;a.streams.forEach(function(a){b+=a.bandwidth});return b/a.streams.length}function vd(a){var b=0;if(!a)return b;a.streams.forEach(function(a){a.height>b&&(b=a.height)});return b}function qd(a,b){var c=a;b&&(c+='; codecs=\"'+b+'\"');return c};function xd(){this.m=this.l=this.j=this.c=this.a=null;this.g=[];this.b=null;this.h=[];this.v=1;this.i={};this.s=0;this.f=null;this.La=this.La.bind(this)}m(\"shaka.dash.DashParser\",xd);k=xd.prototype;k.configure=function(a){this.c=a};k.start=function(a,b,c,d,e){this.g=[a];this.a=b;this.j=c;this.l=d;this.m=e;return yd(this).then(function(){this.a&&zd(this,0);return this.b}.bind(this))};\nk.stop=function(){this.a&&this.a.Ob(this.La);this.c=this.m=this.l=this.j=this.a=null;this.g=[];this.b=null;this.h=[];this.i={};null!=this.f&&(window.clearTimeout(this.f),this.f=null);return Promise.resolve()};function yd(a){return a.a.request(0,rc(a.g,a.c.retryParameters)).then(function(a){if(this.a)return Ad(this,a.data,a.uri)}.bind(a))}\nfunction Ad(a,b,c){var d=Eb(b),e=new DOMParser,f=null;b=null;try{f=e.parseFromString(d,\"text/xml\")}catch(X){}f&&\"MPD\"==f.documentElement.tagName&&(b=f.documentElement);if(!b)throw new v(4,4001);c=[c];d=G(b,\"Location\").map(Wa).filter(Ka);0<d.length&&(c=a.g=d);d=G(b,\"BaseURL\").map(Wa);c=K(c,d);var g=H(b,\"minBufferTime\",I);a.s=H(b,\"minimumUpdatePeriod\",I,-1);var h=H(b,\"availabilityStartTime\",Xa),d=H(b,\"timeShiftBufferDepth\",I),l=H(b,\"suggestedPresentationDelay\",I),e=H(b,\"maxSegmentDuration\",I),f=b.getAttribute(\"type\")||\n\"static\",n;if(a.b)n=a.b.presentationTimeline;else{var r=Math.max(10,1.5*g);n=new Q(h,null!=l?l:r)}var h=Bd(a,{Sa:\"static\"!=f,presentationTimeline:n,L:null,I:null,R:null,u:null,bandwidth:void 0,tb:!1},c,b),l=h.duration,u=h.periods;n.Mb(\"static\"==f);n.Aa(l||Infinity);n.Lb(null!=d?d:Infinity);n.$a(e||1);if(a.b)return Promise.resolve();b=G(b,\"UTCTiming\");d=n.S();h.ca&&a.a.Eb(a.La);return Cd(a,c,b,d).then(function(a){this.a&&(n.Kb(a),this.b={presentationTimeline:n,periods:u,offlineSessionIds:[],minBufferTime:g||\n0})}.bind(a))}\nfunction Bd(a,b,c,d){var e=H(d,\"mediaPresentationDuration\",I),f=!1,g=[],h=0;d=G(d,\"Period\");for(var l=0;l<d.length;l++){var n=d[l],h=H(n,\"start\",I,h),r=H(n,\"duration\",I);if(null==r)if(l+1!=d.length){var u=H(d[l+1],\"start\",I);null!=u&&(r=u-h)}else null!=e&&(r=e-h);u={start:h,duration:r,node:n,ca:!1};n=Dd(a,b,c,u);g.push(n);f=f||u.ca;u=b.L.id;a.h.every(La(u))&&(a.j(n),a.h.push(u),a.b&&a.b.periods.push(n));if(null==r){h=null;break}h+=r}return null!=e?{periods:g,duration:e,ca:f}:{periods:g,duration:h,\nca:f}}function Dd(a,b,c,d){b.L=Ed(d.node,null,c);b.I=d;b.L.id||(b.L.id=\"__shaka_period_\"+d.start);a=G(d.node,\"AdaptationSet\").map(a.zc.bind(a,b)).filter(Ka);b=a.map(function(a){return a.Hc}).reduce(B,[]);c=b.filter(Ma);if(b.length!=c.length)throw new v(4,4018);if(!a.length)throw new v(4,4004);for(b=0;b<a.length;b++)a[b].ca&&(d.ca=!0);a=Fd(a);return{startTime:d.start,streamSets:a}}\nk.zc=function(a,b){a.R=Ed(b,a.L,null);var c=!1,d=G(b,\"Role\"),e=void 0;\"text\"==a.R.contentType&&(e=\"subtitle\");for(var f=0;f<d.length;f++){var g=d[f].getAttribute(\"schemeIdUri\");if(null==g||\"urn:mpeg:dash:role:2011\"==g)switch(g=d[f].getAttribute(\"value\"),g){case \"main\":c=!0;break;case \"caption\":case \"subtitle\":e=g}}var d=Gd(b),h=[];G(b,\"SupplementalProperty\").forEach(function(a){var b=a.getAttribute(\"schemeIdUri\");(\"urn:mpeg:dash:adaptation-set-switching:2016\"==b||\"http://dashif.org/guidelines/AdaptationSetSwitching\"==\nb||\"http://dashif.org/descriptor/AdaptationSetSwitching\"==b)&&(a=a.getAttribute(\"value\"))&&h.push.apply(h,a.split(\",\"))});var l=null,n=!1;G(b,\"EssentialProperty\").forEach(function(a){\"http://dashif.org/guidelines/trickmode\"==a.getAttribute(\"schemeIdUri\")?l=a.getAttribute(\"value\"):n=!0});if(null!=l||n)return null;var f=G(b,\"ContentProtection\"),f=eb(f,this.c.dash.customScheme),g=Ec(b.getAttribute(\"lang\")||\"und\"),r=G(b,\"Representation\"),e=r.map(this.Ac.bind(this,a,f,e,g)).filter(function(a){return!!a});\nif(!e.length)throw new v(4,4003);a.R.contentType||(a.R.contentType=Hd(e[0].mimeType,e[0].codecs));r=r.map(function(a){return a.getAttribute(\"id\")}).filter(Ka);return{id:a.R.id||\"__fake__\"+this.v++,contentType:a.R.contentType,language:g,hc:c,streams:e,drmInfos:f.drmInfos,dd:h,ca:d,Hc:r}};function Gd(a){if(Va(a,\"InbandEventStream\"))return!0;a=G(a,\"Representation\");var b;if(0<a.length)for(var c=0;c<a.length;c++)if(b=Va(a[c],\"InbandEventStream\"))return!0;return!1}\nk.Ac=function(a,b,c,d,e){a.u=Ed(e,a.R,null);if(!Id(a.u))return null;a.bandwidth=H(e,\"bandwidth\",$a)||void 0;var f;f=this.Ic.bind(this);if(a.u.Ia)f=dc(a,f);else if(a.u.$)f=gc(a,this.i);else if(a.u.Ja)f=kc(a,f,this.i,!!this.b);else{var g=a.u.N,h=a.I.duration||0;f={createSegmentIndex:Promise.resolve.bind(Promise),findSegmentPosition:function(a){return 0<=a&&a<h?1:null},getSegmentReference:function(a){return 1!=a?null:new J(1,0,h,function(){return g},0,null)},initSegmentReference:null,presentationTimeOffset:0}}e=\nG(e,\"ContentProtection\");e=ib(e,this.c.dash.customScheme,b);return{id:this.v++,createSegmentIndex:f.createSegmentIndex,findSegmentPosition:f.findSegmentPosition,getSegmentReference:f.getSegmentReference,initSegmentReference:f.initSegmentReference,presentationTimeOffset:f.presentationTimeOffset,mimeType:a.u.mimeType,codecs:a.u.codecs,frameRate:a.u.frameRate,bandwidth:a.bandwidth,width:a.u.width,height:a.u.height,kind:c,encrypted:0<b.drmInfos.length,keyId:e,language:d,allowedByApplication:!0,allowedByKeySystem:!0}};\nk.Yc=function(){this.f=null;var a=Date.now();yd(this).then(function(){this.a&&zd(this,(Date.now()-a)/1E3)}.bind(this))[\"catch\"](function(a){this.l(a);this.a&&zd(this,0)}.bind(this))};function zd(a,b){0>a.s||(a.f=window.setTimeout(a.Yc.bind(a),1E3*Math.max(Math.max(3,a.s)-b,0)))}\nfunction Ed(a,b,c){b=b||{contentType:\"\",mimeType:\"\",codecs:\"\",frameRate:void 0};c=c||b.N;var d=G(a,\"BaseURL\").map(Wa),e=a.getAttribute(\"contentType\")||b.contentType,f=a.getAttribute(\"mimeType\")||b.mimeType,g=a.getAttribute(\"codecs\")||b.codecs,h=H(a,\"frameRate\",cb)||b.frameRate;e||(e=Hd(f,g));return{N:K(c,d),Ia:Va(a,\"SegmentBase\")||b.Ia,$:Va(a,\"SegmentList\")||b.$,Ja:Va(a,\"SegmentTemplate\")||b.Ja,width:H(a,\"width\",bb)||b.width,height:H(a,\"height\",bb)||b.height,contentType:e,mimeType:f,codecs:g,frameRate:h,\nid:a.getAttribute(\"id\")}}\nfunction Fd(a){var b={};a.forEach(function(a){b[a.id]=[a]});a.forEach(function(a){var c=b[a.id];a.dd.forEach(function(a){(a=b[a])&&a!=c&&(c.push.apply(c,a),a.forEach(function(a){b[a.id]=c}))})});var c=[],d=[];F(b).forEach(function(a){if(!(0<=d.indexOf(a))){d.push(a);var b=new Ba;a.forEach(function(a){b.push(a.contentType||\"\",a)});b.keys().forEach(function(a){var d=new Ba;b.get(a).forEach(function(a){d.push(a.language,a)});d.keys().forEach(function(b){var e=d.get(b);b={language:b,type:a,primary:e.some(function(a){return a.hc}),\ndrmInfos:e.map(function(a){return a.drmInfos}).reduce(B,[]),streams:e.map(function(a){return a.streams}).reduce(B,[])};c.push(b)})})}});return c}function Id(a){var b;b=0+(a.Ia?1:0);b+=a.$?1:0;b+=a.Ja?1:0;if(!b)return\"text\"==a.contentType||\"application\"==a.contentType?!0:!1;1!=b&&(a.Ia&&(a.$=null),a.Ja=null);return!0}\nfunction Jd(a,b,c,d){b=K(b,[c]);b=rc(b,a.c.retryParameters);b.method=d;return a.a.request(0,b).then(function(a){if(\"HEAD\"==d){if(!a.headers||!a.headers.date)return 0;a=a.headers.date}else a=Eb(a.data);a=Date.parse(a);return isNaN(a)?0:a-Date.now()})}\nfunction Cd(a,b,c,d){c=c.map(function(a){return{scheme:a.getAttribute(\"schemeIdUri\"),value:a.getAttribute(\"value\")}});var e=a.c.dash.clockSyncUri;d&&!c.length&&e&&c.push({scheme:\"urn:mpeg:dash:utc:http-head:2014\",value:e});return Ja(c,function(a){var c=a.value;switch(a.scheme){case \"urn:mpeg:dash:utc:http-head:2014\":case \"urn:mpeg:dash:utc:http-head:2012\":return Jd(this,b,c,\"HEAD\");case \"urn:mpeg:dash:utc:http-xsdate:2014\":case \"urn:mpeg:dash:utc:http-iso:2014\":case \"urn:mpeg:dash:utc:http-xsdate:2012\":case \"urn:mpeg:dash:utc:http-iso:2012\":return Jd(this,\nb,c,\"GET\");case \"urn:mpeg:dash:utc:direct:2014\":case \"urn:mpeg:dash:utc:direct:2012\":return a=Date.parse(c),isNaN(a)?0:a-Date.now();case \"urn:mpeg:dash:utc:http-ntp:2014\":case \"urn:mpeg:dash:utc:ntp:2014\":case \"urn:mpeg:dash:utc:sntp:2014\":return Promise.reject();default:return Promise.reject()}}.bind(a))[\"catch\"](function(){return 0})}k.Ic=function(a,b,c){a=rc(a,this.c.retryParameters);null!=b&&(a.headers.Range=\"bytes=\"+b+\"-\"+(null!=c?c:\"\"));return this.a.request(1,a).then(function(a){return a.data})};\nk.La=function(a,b){if(1==a){var c=new Jb(new DataView(b.data)),d=Sb(1701671783,c);if(-1!=d){var e=c.a-8+d;N(c,4);d=Rb(c);if(\"urn:mpeg:dash:event:2012\"==d)yd(this);else{var f=Rb(c),g=M(c),h=M(c),l=M(c),n=M(c),c=Qb(c,e-c.a);this.m(new t(\"emsg\",{detail:{schemeIdUri:d,value:f,timescale:g,presentationTimeDelta:h,eventDuration:l,id:n,messageData:c}}))}}}};function Hd(a,b){return R[qd(a,b)]?\"text\":a.split(\"/\")[0]}tc.mpd=xd;sc[\"application/dash+xml\"]=xd;function S(a,b){var c=Eb(a),d=[],e=new DOMParser,f=null;try{f=e.parseFromString(c,\"text/xml\")}catch(r){throw new v(2,2005);}if(f){var g,h,l;if(e=f.getElementsByTagName(\"tt\")[0])f=e.getAttribute(\"ttp:frameRate\"),g=e.getAttribute(\"ttp:subFrameRate\"),h=e.getAttribute(\"ttp:frameRateMultiplier\"),l=e.getAttribute(\"ttp:tickRate\"),c=e.getAttribute(\"xml:space\")||\"default\";else throw new v(2,2006);if(\"default\"!=c&&\"preserve\"!=c)throw new v(2,2005);c=\"default\"==c;f=new Kd(f,g,h,l);g=S.b(e.getElementsByTagName(\"styling\")[0]);\nh=S.b(e.getElementsByTagName(\"layout\")[0]);e=S.b(e.getElementsByTagName(\"body\")[0]);for(l=0;l<e.length;l++){var n=S.c(e[l],b,f,g,h,c);n&&d.push(n)}}return d}m(\"shaka.media.TtmlTextParser\",S);S.m=/^(\\d{2,}):(\\d{2}):(\\d{2}):(\\d{2})\\.?(\\d+)?$/;S.v=/^(?:(\\d{2,}):)?(\\d{2}):(\\d{2})$/;S.s=/^(?:(\\d{2,}):)?(\\d{2}):(\\d{2}\\.\\d{2,})$/;S.A=/^(\\d*\\.?\\d*)f$/;S.C=/^(\\d*\\.?\\d*)t$/;S.B=/^(?:(\\d*\\.?\\d*)h)?(?:(\\d*\\.?\\d*)m)?(?:(\\d*\\.?\\d*)s)?(?:(\\d*\\.?\\d*)ms)?$/;S.l=/^(\\d{1,2}|100)% (\\d{1,2}|100)%$/;\nS.Ka={left:\"start\",center:\"center\",right:\"end\",start:\"start\",end:\"end\"};S.Ra={left:\"line-left\",center:\"center\",right:\"line-right\"};S.b=function(a){var b=[];if(!a)return b;for(var c=a.childNodes,d=0;d<c.length;d++){var e=\"span\"==c[d].nodeName&&\"p\"==a.nodeName;c[d].nodeType!=Node.ELEMENT_NODE||\"br\"==c[d].nodeName||e||(e=S.b(c[d]),b=b.concat(e))}b.length||b.push(a);return b};\nS.h=function(a,b){for(var c=a.childNodes,d=0;d<c.length;d++)if(\"br\"==c[d].nodeName&&0<d)c[d-1].textContent+=\"\\n\";else if(0<c[d].childNodes.length)S.h(c[d],b);else if(b){var e=c[d].textContent.trim(),e=e.replace(/\\s+/g,\" \");c[d].textContent=e}};\nS.c=function(a,b,c,d,e,f){if(!a.hasAttribute(\"begin\")&&!a.hasAttribute(\"end\")&&/^\\s*$/.test(a.textContent))return null;S.h(a,f);f=S.a(a.getAttribute(\"begin\"),c);var g=S.a(a.getAttribute(\"end\"),c);c=S.a(a.getAttribute(\"dur\"),c);var h=a.textContent;null==g&&null!=c&&(g=f+c);if(null==f||null==g)throw new v(2,2001);b=xc(f+b,g+b,h);if(!b)return null;e=S.i(a,\"region\",e);S.qa(b,a,e,d);return b};\nS.qa=function(a,b,c,d){var e,f=S.f(b,c,d,\"tts:extent\");f&&(e=S.l.exec(f))&&(a.size=Number(e[1]));e=S.f(b,c,d,\"tts:writingMode\");f=!0;\"tb\"==e||\"tblr\"==e?a.vertical=\"lr\":\"tbrl\"==e?a.vertical=\"rl\":f=!1;if(e=S.f(b,c,d,\"tts:origin\"))if(e=S.l.exec(e))f?(a.position=Number(e[2]),a.line=Number(e[1])):(a.position=Number(e[1]),a.line=Number(e[2])),a.snapToLines=!1;if(b=S.f(b,c,d,\"tts:textAlign\"))a.align=b,\"center\"==b&&(\"center\"!=a.align&&(a.align=\"middle\"),a.position=\"auto\"),a.positionAlign=S.Ra[b],a.lineAlign=\nS.Ka[b]};S.f=function(a,b,c,d){for(var e=S.b(b),f=0;f<e.length;f++){var g=e[f].getAttribute(d);if(g)return g}e=S.i;return(a=e(b,\"style\",c)||e(a,\"style\",c))?a.getAttribute(d):null};S.i=function(a,b,c){if(!a||1>c.length)return null;var d=null;if(a=S.ra(a,b))for(b=0;b<c.length;b++)if(c[b].getAttribute(\"xml:id\")==a){d=c[b];break}return d};S.ra=function(a,b){for(var c=null;a&&!(c=a.getAttribute(b));){var d=a.parentNode;if(d instanceof Element)a=d;else break}return c};\nS.a=function(a,b){var c=null;S.m.test(a)?c=S.sa(b,a):S.v.test(a)?c=S.g(S.v,a):S.s.test(a)?c=S.g(S.s,a):S.A.test(a)?c=S.Ca(b,a):S.C.test(a)?c=S.Da(b,a):S.B.test(a)&&(c=S.g(S.B,a));return c};S.Ca=function(a,b){var c=S.A.exec(b);return Number(c[1])/a.frameRate};S.Da=function(a,b){var c=S.C.exec(b);return Number(c[1])/a.a};S.sa=function(a,b){var c=S.m.exec(b),d=Number(c[1]),e=Number(c[2]),f=Number(c[3]),g=Number(c[4]),g=g+(Number(c[5])||0)/a.b,f=f+g/a.frameRate;return f+60*e+3600*d};\nS.g=function(a,b){var c=a.exec(b);return c&&\"\"!=c[0]?(Number(c[4])||0)/1E3+(Number(c[3])||0)+60*(Number(c[2])||0)+3600*(Number(c[1])||0):null};function Kd(a,b,c,d){this.frameRate=Number(a)||30;this.b=Number(b)||1;this.a=Number(d);this.a||(this.a=a?this.frameRate*this.b:1);c&&(a=/^(\\d+) (\\d+)$/g.exec(c))&&(this.frameRate*=a[1]/a[2])}R[\"application/ttml+xml\"]=S;function Ld(a,b){var c=new Jb(new DataView(a)),d=Sb(1835295092,c);if(-1!=d)return S(Qb(c,d-8).buffer,b);if(-1!=Tb(a,Ld.U))return[];throw new v(2,2007);}m(\"shaka.media.Mp4TtmlParser\",Ld);Ld.U=1937010800;R['application/mp4; codecs=\"stpp\"']=Ld;function Md(a){this.b=a;this.a=0}function Nd(a,b){var c;b.lastIndex=a.a;c=(c=b.exec(a.b))?{position:c.index,length:c[0].length,Kc:c}:null;if(a.a==a.b.length||!c||c.position!=a.a)return null;a.a+=c.length;return c.Kc}function Od(a){return a.a==a.b.length?null:(a=Nd(a,/[^ \\t\\n]*/gm))?a[0]:null};function T(a,b,c,d,e){a=Eb(a);a=a.replace(/\\r\\n|\\r(?=[^\\n]|$)/gm,\"\\n\");a=a.split(/\\n{2,}/m);if(!/^WEBVTT($|[ \\t\\n])/m.test(a[0]))throw new v(2,2E3);d=[];for(var f=1;f<a.length;f++){var g=a[f].split(\"\\n\");(g=T.c(g,b,c,e))&&d.push(g)}return d}m(\"shaka.media.VttTextParser\",T);\nT.c=function(a,b,c,d){if(1==a.length&&!a[0]||/^NOTE($|[ \\t])/.test(a[0]))return null;var e=null;0>a[0].indexOf(\"--\\x3e\")&&(e=a[0],a.splice(0,1));var f=new Md(a[0]),g=T.a(f),h=Nd(f,/[ \\t]+--\\x3e[ \\t]+/g),l=T.a(f);if(null==g||!h||null==l)throw new v(2,2001);d?(g+=c,l+=c):(g+=b,l+=b);a=xc(g,l,a.slice(1).join(\"\\n\").trim());if(!a)return null;Nd(f,/[ \\t]+/gm);for(b=Od(f);b;)T.j(a,b),Nd(f,/[ \\t]+/gm),b=Od(f);null!=e&&(a.id=e);return a};\nT.j=function(a,b){var c;if(c=/^align:(start|middle|center|end|left|right)$/.exec(b))a.align=c[1],\"center\"==c[1]&&\"center\"!=a.align&&(a.position=\"auto\",a.align=\"middle\");else if(c=/^vertical:(lr|rl)$/.exec(b))a.vertical=c[1];else if(c=/^size:(\\d{1,2}|100)%$/.exec(b))a.size=Number(c[1]);else if(c=/^position:(\\d{1,2}|100)%(?:,(line-left|line-right|center|start|end))?$/.exec(b))a.position=Number(c[1]),c[2]&&(a.positionAlign=c[2]);else if(c=/^line:(\\d{1,2}|100)%(?:,(start|end|center))?$/.exec(b))a.snapToLines=\n!1,a.line=Number(c[1]),c[2]&&(a.lineAlign=c[2]);else if(c=/^line:(-?\\d+)(?:,(start|end|center))?$/.exec(b))a.snapToLines=!0,a.line=Number(c[1]),c[2]&&(a.lineAlign=c[2])};T.a=function(a){a=Nd(a,/(?:(\\d{1,}):)?(\\d{2}):(\\d{2})\\.(\\d{3})/g);if(!a)return null;var b=Number(a[2]),c=Number(a[3]);return 59<b||59<c?null:Number(a[4])/1E3+c+60*b+3600*(Number(a[1])||0)};R[\"text/vtt\"]=T;R['text/vtt; codecs=\"vtt\"']=T;function U(a,b,c,d){var e=new Jb(new DataView(a)),f=Sb(1835295092,e);if(-1!=f)return U.Ba(Qb(e,f-8).buffer,b,c,d);if(-1!=Tb(a,U.pa))return[];throw new v(2,2008);}m(\"shaka.media.Mp4VttParser\",U);U.Ba=function(a,b,c,d){a=new Jb(new DataView(a));c+=b;d+=b;for(b=[];Lb(a);){var e=Sb(U.oa,a);if(-1==e)break;(e=U.c(Qb(a,e-8).buffer,c,d))&&b.push(e)}return b};\nU.c=function(a,b,c){a=new Jb(new DataView(a));for(var d,e,f;Lb(a);){var g=M(a),h=M(a),l=Eb(Qb(a,g-8).buffer);1==g&&Pb(a);switch(h){case U.K:d=l;break;case U.H:f=l;break;case U.Y:e=l}}if(!d)throw new v(2,2008);b=xc(b,c,d);if(!b)return null;f&&(b.id=f);if(e)for(e=new Md(e),f=Od(e);f;)T.j(b,f),Nd(e,/[ \\t]+/gm),f=Od(e);return b};U.pa=2004251764;U.oa=1987343459;U.K=1885436268;U.H=1768187247;U.Y=1937011815;R['application/mp4; codecs=\"wvtt\"']=U;function Pd(a,b,c,d,e,f){this.a=a;this.c=b;this.j=c;this.s=d;this.l=e;this.m=f;this.b=new x;this.g=!1;this.h=1;this.i=this.f=null;0<a.readyState?this.xb():y(this.b,a,\"loadedmetadata\",this.xb.bind(this));y(this.b,a,\"ratechange\",this.qc.bind(this));Qd(this)}k=Pd.prototype;k.o=function(){var a=this.b.o();this.b=null;Rd(this);null!=this.f&&(window.clearInterval(this.f),this.f=null);this.m=this.l=this.c=this.a=null;return a};function Sd(a){return 0<a.a.readyState?Td(a,a.a.currentTime):Ud(a)}\nfunction Ud(a){return a.s?Td(a,a.s):Infinity>a.c.ea()?a.c.ta():Math.max(a.c.Va(),a.c.ta())}function Vd(a,b){b!=a.g&&(a.g=b,Wd(a,a.h),a.l(b))}function Qd(a){Rd(a);a.i=window.setTimeout(a.uc.bind(a),250)}function Rd(a){a.i&&(window.clearTimeout(a.i),a.i=null)}k.uc=function(){this.i=null;Qd(this);var a=ad(this.a.buffered,this.a.currentTime,.1),b=Zc(this.a.buffered)>=(this.c.S()?this.c.Z()-.1:this.a.duration-.1)||this.a.ended;this.g?(b||a>=this.j)&&Vd(this,!1):!b&&.5>a&&Vd(this,!0)};k.Ua=function(){return this.h};\nfunction Wd(a,b){null!=a.f&&(window.clearInterval(a.f),a.f=null);a.h=b;a.a.playbackRate=a.g||0>b?0:b;!a.g&&0>b&&(a.f=window.setInterval(function(){this.a.currentTime+=b/4}.bind(a),250))}k.qc=function(){this.a.playbackRate!=(this.g||0>this.h?0:this.h)&&Wd(this,this.a.playbackRate)};\nk.xb=function(){this.b.la(this.a,\"loadedmetadata\");var a=Ud(this);.001>Math.abs(this.a.currentTime-a)?(y(this.b,this.a,\"seeking\",this.zb.bind(this)),y(this.b,this.a,\"playing\",this.yb.bind(this))):(y(this.b,this.a,\"seeking\",this.sc.bind(this)),this.a.currentTime=a)};k.sc=function(){this.b.la(this.a,\"seeking\");y(this.b,this.a,\"seeking\",this.zb.bind(this));y(this.b,this.a,\"playing\",this.yb.bind(this))};k.zb=function(){var a=this.a.currentTime,b=Xd(this,a);.001<Math.abs(b-a)?Yd(this,a,b):this.m()};\nk.yb=function(){var a=this.a.currentTime,b=Xd(this,a);.001<Math.abs(b-a)&&Yd(this,a,b)};function Xd(a,b){var c=a.c,d=c.ta(),e=c.Z();if(!c.S()||Infinity==c.c)return b<d?d:b>e?e:b;c=d+1;d=c+a.j;return b>=d&&b<=e||$c(a.a.buffered,b)&&b>=c&&b<=e?b:b>e?e:e<d&&b>=c&&b<=e?b:Math.min(d+2,e)}function Yd(a,b,c){a.a.currentTime=c;var d=0,e=function(){!this.a||10<=d++||this.a.currentTime!=b||(this.a.currentTime=c,setTimeout(e,100))}.bind(a);setTimeout(e,100)}\nfunction Td(a,b){var c=a.c.ta();if(b<c)return c;c=a.c.Z();return b>c?c:b};function Zd(a,b,c,d,e,f,g,h,l){this.m=a;this.f=b;this.U=c;this.a=d;this.H=e;this.v=f;this.j=g;this.A=h||null;this.B=l||null;this.g=null;this.i=1;this.C=Promise.resolve();this.h=[];this.l={};this.b={};this.c=this.s=this.K=!1}Zd.prototype.o=function(){for(var a in this.b)$d(this.b[a]);this.g=this.b=this.l=this.h=this.B=this.A=this.j=this.v=this.H=this.C=this.a=this.U=this.f=this.m=null;this.c=!0;return Promise.resolve()};\nZd.prototype.configure=function(a){this.g=a;this.m.j=this.i*Math.max(this.a.minBufferTime||0,this.g.rebufferingGoal)};Zd.prototype.init=function(){var a=this.H(this.a.periods[ae(this,Sd(this.m))]);return Na(a)?Promise.reject(new v(5,5005)):be(this,a).then(function(){this.A&&this.A()}.bind(this))};function ce(a){return a.a.periods[ae(a,Sd(a.m))]}function de(a){return Oa(a.b,function(a){return a.stream})}function ee(a,b){var c={};c.text=b;return be(a,c)}\nfunction fe(a,b,c,d){var e=a.b[b];!e&&\"text\"==b&&a.g.ignoreTextStreamFailures?ee(a,c):e&&(b=a.h[ge(a,c)])&&b.za&&(b=a.l[c.id])&&b.za&&e.stream!=c&&(e.stream=c,e.Ma=!0,d&&(e.ba?e.Qa=!0:e.ga?(e.na=!0,e.Qa=!0):($d(e),he(a,e,!0))))}function ie(a){var b=Sd(a.m);if(!Object.keys(a.b).every(function(a){return 0<fd(this.f,a,b)}.bind(a)))for(var c in a.b){var d=a.b[c];d.ba||d.na||(d.ga?d.na=!0:null==dd(a.f,c)?null==d.aa&&je(a,d,0):($d(d),he(a,d,!1)))}}\nfunction be(a,b,c){var d=ae(a,Sd(a.m)),e=Oa(b,function(a){return qd(a.mimeType,a.codecs)});a.f.init(e,a.g.useRelativeCueTimestamps);ke(a);e=F(b);return le(a,e).then(function(){if(!this.c)for(var a in b){var e=b[a];this.b[a]||(this.b[a]={stream:e,type:a,va:null,W:null,Ma:!0,Ga:d,endOfStream:!1,ga:!1,aa:null,na:!1,Qa:!1,ba:!1,eb:!1,Xa:!1,Hb:c||0},je(this,this.b[a],0))}}.bind(a))}\nfunction me(a,b){var c=a.h[b];if(c)return c.J;c={J:new w,za:!1};a.h[b]=c;var d=a.a.periods[b].streamSets.map(function(a){return a.streams}).reduce(B,[]);a.C=a.C.then(function(){if(!this.c)return le(this,d)}.bind(a)).then(function(){this.c||(this.h[b].J.resolve(),this.h[b].za=!0)}.bind(a))[\"catch\"](function(a){this.c||(this.h[b].J.reject(),delete this.h[b],this.j(a))}.bind(a));return c.J}\nfunction le(a,b){for(var c=[],d=0;d<b.length;++d){var e=b[d],f=a.l[e.id];f?c.push(f.J):(a.l[e.id]={J:new w,za:!1},c.push(e.createSegmentIndex()))}return Promise.all(c).then(function(){if(!this.c)for(var a=0;a<b.length;++a){var c=this.l[b[a].id];c.za||(c.J.resolve(),c.za=!0)}}.bind(a))[\"catch\"](function(a){if(!this.c)return this.l[e.id].J.reject(),delete this.l[e.id],Promise.reject(a)}.bind(a))}function ke(a){var b=a.a.presentationTimeline.ea();Infinity>b?a.f.Aa(b):a.f.Aa(Math.pow(2,32))}\nZd.prototype.Y=function(a){if(!this.c&&!a.ga&&null!=a.aa&&!a.ba)if(a.aa=null,a.na)he(this,a,a.Qa);else{try{var b=ne(this,a);null!=b&&(je(this,a,b),a.Xa=!1)}catch(c){this.j(c);return}b=F(this.b);oe(this,a);b.every(function(a){return a.endOfStream})&&this.f.endOfStream()}};\nfunction ne(a,b){var c=Sd(a.m),d,e=a.f;d=b.type;d=\"text\"==d?e.b.a:Zc(ed(e,d));var f=b.va&&b.W?a.a.periods[ge(a,b.va)].startTime+b.W.endTime:Math.max(c,b.Hb);b.Hb=0;var e=ge(a,b.stream),g=ae(a,f),h=fd(a.f,b.type,c,.1),l=Math.max(a.i*Math.max(a.a.minBufferTime||0,a.g.rebufferingGoal),a.i*a.g.bufferingGoal);if(f>=a.a.presentationTimeline.ea())return b.endOfStream=!0,null;b.endOfStream=!1;b.Ga=g;if(g!=e)return null;if(h>=l)return.5;b.W&&b.stream==b.va?(f=b.W.position+1,d=pe(a,b,e,f)):(f=b.W?b.stream.findSegmentPosition(Math.max(0,\na.a.periods[ge(a,b.va)].startTime+b.W.endTime-a.a.periods[e].startTime)):b.stream.findSegmentPosition(Math.max(0,(d||c)-a.a.periods[e].startTime)),null==f?d=null:(g=null,null==d&&(g=pe(a,b,e,Math.max(0,f-1))),d=g||pe(a,b,e,f)));if(!d)return 1;qe(a,b,c,e,d);return null}function pe(a,b,c,d){c=a.a.periods[c];b=b.stream.getSegmentReference(d);if(!b)return null;a=a.a.presentationTimeline;d=a.Z();return c.startTime+b.endTime<a.ua()||c.startTime+b.startTime>d?null:b}\nfunction qe(a,b,c,d,e){var f=a.a.periods[d],g=b.stream,h=a.a.periods[d+1],l=null,l=h?h.startTime:a.a.presentationTimeline.ea();d=re(a,b,d,l);b.ga=!0;b.Ma=!1;h=se(a,e);Promise.all([d,h]).then(function(a){if(!this.c&&!this.s)return te(this,b,c,f,g,e,a[1])}.bind(a)).then(function(){this.c||this.s||(b.ga=!1,b.eb=!1,je(this,b,0),ue(this,g))}.bind(a))[\"catch\"](function(a){this.c||this.s||(b.ga=!1,1001==a.code||1002==a.code||1003==a.code?\"text\"==b.type&&this.g.ignoreTextStreamFailures&&1001==a.code?delete this.b.text:\n(this.j(a),je(this,b,4)):3017==a.code?ve(this,b,a):\"text\"==b.type&&this.g.ignoreTextStreamFailures?delete this.b.text:(b.Xa=!0,this.j(a)))}.bind(a))}function ve(a,b,c){if(!F(a.b).some(function(a){return a!=b&&a.eb})){var d=Math.round(100*a.i);if(20<d)a.i-=.2;else if(4<d)a.i-=.04;else{b.Xa=!0;a.s=!0;a.j(c);return}b.eb=!0}je(a,b,4)}\nfunction re(a,b,c,d){if(!b.Ma)return Promise.resolve();c=jd(a.f,b.type,a.a.periods[c].startTime-b.stream.presentationTimeOffset);d=null!=d?kd(a.f,b.type,d):Promise.resolve();if(!b.stream.initSegmentReference)return Promise.all([c,d]);a=se(a,b.stream.initSegmentReference).then(function(a){if(!this.c)return gd(this.f,b.type,a,null,null)}.bind(a))[\"catch\"](function(a){b.Ma=!0;return Promise.reject(a)});return Promise.all([c,d,a])}\nfunction te(a,b,c,d,e,f,g){return we(a,b,c).then(function(){if(!this.c)return gd(this.f,b.type,g,f.startTime+d.startTime,f.endTime+d.startTime)}.bind(a)).then(function(){if(!this.c)return b.va=e,b.W=f,Promise.resolve()}.bind(a))}function we(a,b,c){var d=dd(a.f,b.type);if(null==d)return Promise.resolve();c=c-d-a.g.bufferBehind;return 0>=c?Promise.resolve():a.f.remove(b.type,d,d+c).then(function(){}.bind(a))}\nfunction ue(a,b){if(!a.K&&(a.K=F(a.b).every(function(a){return\"text\"==a.type?!0:!a.na&&!a.ba&&a.W}),a.K)){var c=ge(a,b);a.h[c]||me(a,c).then(function(){this.v()}.bind(a))[\"catch\"](C);for(c=0;c<a.a.periods.length;++c)me(a,c)[\"catch\"](C);a.B&&a.B()}}\nfunction oe(a,b){if(b.Ga!=ge(a,b.stream)){var c=b.Ga,d=F(a.b);d.every(function(a){return a.Ga==c})&&d.every(xe)&&me(a,c).then(function(){if(!this.c&&d.every(function(a){var b=ge(this,a.stream);return xe(a)&&a.Ga==c&&b!=c}.bind(this))){var a=this.a.periods[c],b=this.H(a),g;for(g in this.b)if(!b[g]&&\"text\"!=g){this.j(new v(5,5005));return}for(g in b)if(!this.b[g])if(\"text\"==g)be(this,{text:b.text},a.startTime),delete b[g];else{this.j(new v(5,5005));return}for(g in this.b)(a=b[g])?(fe(this,g,a,!1),je(this,\nthis.b[g],0)):delete this.b[g];this.v()}}.bind(a))[\"catch\"](C)}}function xe(a){return!a.ga&&null==a.aa&&!a.na&&!a.ba}function ae(a,b){for(var c=a.a.periods.length-1;0<c;--c)if(b>=a.a.periods[c].startTime)return c;return 0}function ge(a,b){for(var c=0;c<a.a.periods.length;++c)for(var d=a.a.periods[c],e=0;e<d.streamSets.length;++e)if(0<=d.streamSets[e].streams.indexOf(b))return c;return-1}\nfunction se(a,b){var c=rc(b.a(),a.g.retryParameters);if(b.M||null!=b.D){var d=\"bytes=\"+b.M+\"-\";null!=b.D&&(d+=b.D);c.headers.Range=d}return a.U.request(1,c).then(function(a){return a.data})}function he(a,b,c){b.na=!1;b.Qa=!1;b.ba=!0;id(a.f,b.type).then(function(){if(!this.c&&c){var a=this.f,e=b.type;return\"text\"==e?Promise.resolve():hd(a,e,a.Yb.bind(a,e))}}.bind(a)).then(function(){this.c||(b.va=null,b.W=null,b.ba=!1,je(this,b,0))}.bind(a))}\nfunction je(a,b,c){b.aa=window.setTimeout(a.Y.bind(a,b),1E3*c)}function $d(a){null!=a.aa&&(window.clearTimeout(a.aa),a.aa=null)};function ye(a){return new Promise(function(b){var c=a.split(\":\");if(2>c.length||\"data\"!=c[0])throw new v(1,1004,a);c=c.slice(1).join(\":\").split(\",\");if(2>c.length)throw new v(1,1004,a);var d=c[0],c=window.decodeURIComponent(c.slice(1).join(\",\")),d=d.split(\";\"),e=null;1<d.length&&(e=d[1]);if(\"base64\"==e)c=Ra(c).buffer;else{if(e)throw new v(1,1005,a);c=Ib(c)}b({uri:a,data:c,headers:{\"content-type\":d[0]}})})}m(\"shaka.net.DataUriPlugin\",ye);pc.data=ye;function ze(a,b){return new Promise(function(c,d){var e=new XMLHttpRequest;e.open(b.method,a,!0);e.responseType=\"arraybuffer\";e.timeout=b.retryParameters.timeout;e.withCredentials=b.allowCrossSiteCredentials;e.onload=function(b){b=b.target;var e=b.getAllResponseHeaders().split(\"\\r\\n\").reduce(function(a,b){var c=b.split(\": \");a[c[0].toLowerCase()]=c.slice(1).join(\": \");return a},{});if(200<=b.status&&299>=b.status&&202!=b.status)b.responseURL&&(a=b.responseURL),c({uri:a,data:b.response,headers:e,pd:!!e[\"x-shaka-from-cache\"]});\nelse{var f=null;try{f=Hb(b.response)}catch(n){}d(new v(1,1001,a,b.status,f,e))}};e.onerror=function(){d(new v(1,1002,a))};e.ontimeout=function(){d(new v(1,1003,a))};for(var f in b.headers)e.setRequestHeader(f,b.headers[f]);e.send(b.body)})}m(\"shaka.net.HttpPlugin\",ze);pc.http=ze;pc.https=ze;function Ae(){this.a=null;this.c=[];this.b={}}k=Ae.prototype;\nk.init=function(a){if(!window.indexedDB)return Promise.reject(new v(9,9E3));var b=window.indexedDB.open(\"shaka_offline_db\",1),c=new w;b.onupgradeneeded=function(b){b=b.target.result;for(var c in a)b.createObjectStore(c,{keyPath:a[c]})};b.onsuccess=function(a){this.a=a.target.result;c.resolve()}.bind(this);b.onerror=Be.bind(null,b,c);return c.then(function(){var b=Object.keys(a);return Promise.all(b.map(function(a){return Ce(this,a).then(function(b){this.b[a]=b}.bind(this))}.bind(this)))}.bind(this))};\nk.o=function(){return Promise.all(this.c.map(function(a){try{a.transaction.abort()}catch(b){}return a.J[\"catch\"](C)})).then(function(){this.a&&(this.a.close(),this.a=null)}.bind(this))};k.get=function(a,b){return De(this,a,\"readonly\",function(a){return a.get(b)})};k.forEach=function(a,b){return De(this,a,\"readonly\",function(a){return a.openCursor()},function(a){a&&(b(a.value),a[\"continue\"]())})};function Ee(a,b,c){return De(a,b,\"readwrite\",function(a){return a.put(c)})}\nk.remove=function(a,b){return De(this,a,\"readwrite\",function(a){return a[\"delete\"](b)})};function Fe(a,b){var c=[];return De(a,\"segment\",\"readwrite\",function(a){return a.openCursor()},function(a){if(a){if(b(a.value)){var d=a[\"delete\"](),f=new w;d.onsuccess=f.resolve;d.onerror=Be.bind(null,d,f);c.push(f)}a[\"continue\"]()}}).then(function(){return Promise.all(c)}).then(function(){return c.length})}\nfunction Ce(a,b){var c=0;return De(a,b,\"readonly\",function(a){return a.openCursor(null,\"prev\")},function(a){a&&(c=a.key+1)}).then(function(){return c})}\nfunction De(a,b,c,d,e){c=a.a.transaction([b],c);var f=d(c.objectStore(b)),g=new w;e&&(f.onsuccess=function(a){e(a.target.result)});f.onerror=Be.bind(null,f,g);var h={transaction:c,J:g};a.c.push(h);var l=function(){this.c.splice(this.c.indexOf(h),1)}.bind(a);c.oncomplete=function(){l();g.resolve(f.result)};c.onerror=function(a){l();Be(f,g,a)};return g}function Be(a,b,c){\"AbortError\"==a.error.name?b.reject(new v(9,9002)):b.reject(new v(9,9001,a.error));c.preventDefault()};var Ge={manifest:\"key\",segment:\"key\"};function He(a){return{offlineUri:\"offline:\"+a.key,originalManifestUri:a.originalManifestUri,duration:a.duration,size:a.size,tracks:a.periods[0].streams.map(function(a){return{id:a.id,active:!1,type:a.contentType,bandwidth:0,language:a.language,kind:a.kind||null,width:a.width,height:a.height,frameRate:a.frameRate,codecs:a.codecs}}),appMetadata:a.appMetadata}};function Ie(a,b,c){this.b={};this.i=c;this.m=a;this.l=b;this.j=this.a=null;this.f=this.g=this.h=this.c=0}Ie.prototype.o=function(){var a=this.j||Promise.resolve();this.b={};this.j=this.a=this.l=this.m=this.i=null;return a};function Je(a,b,c,d,e){a.b[b]=a.b[b]||[];a.b[b].push({uris:c.a(),M:c.M,D:c.D,mb:d,Ea:e})}\nfunction Ke(a,b){a.c=0;a.h=0;a.g=0;a.f=0;F(a.b).forEach(function(a){a.forEach(function(a){null!=a.D?this.c+=a.D-a.M+1:this.g+=a.mb}.bind(this))}.bind(a));a.a=b;a.a.size=a.c;var c=F(a.b).map(function(a){var b=0,c=function(){if(!this.i)return Promise.reject(new v(9,9002));if(b>=a.length)return Promise.resolve();var d=a[b++];return Le(this,d).then(c)}.bind(this);return c()}.bind(a));a.b={};return a.j=Promise.all(c)}\nfunction Le(a,b){var c=rc(b.uris,a.l);if(b.M||null!=b.D)c.headers.Range=\"bytes=\"+b.M+\"-\"+(null==b.D?\"\":b.D);var d;return a.m.request(1,c).then(function(a){if(!this.a)return Promise.reject(new v(9,9002));d=a.data.byteLength;return b.Ea(a.data)}.bind(a)).then(function(){if(!this.a)return Promise.reject(new v(9,9002));null==b.D?(this.a.size+=d,this.f+=b.mb):this.h+=d;var a=(this.h+this.f)/(this.c+this.g),c=He(this.a);this.i.progressCallback(c,a)}.bind(a))};function Me(){}Me.prototype.configure=function(){};Me.prototype.start=function(a){var b=/^offline:([0-9]+)$/.exec(a);if(!b)return Promise.reject(new v(1,9004,a));var c=Number(b[1]),d=new Ae;return d.init(Ge).then(function(){return d.get(\"manifest\",c)}).then(function(a){if(!a)throw new v(9,9003,c);return Ne(a)}).then(function(a){return d.o().then(function(){return a})},function(a){return d.o().then(function(){throw a;})})};Me.prototype.stop=function(){return Promise.resolve()};\nfunction Ne(a){var b=new Q(null,0);b.Aa(a.duration);var c=a.drmInfo?[a.drmInfo]:[];return{presentationTimeline:b,minBufferTime:10,offlineSessionIds:a.sessionIds,periods:a.periods.map(function(a){return{startTime:a.startTime,streamSets:a.streams.map(function(d){var e=d.segments.map(function(a,b){return new J(b,a.startTime,a.endTime,function(){return[a.uri]},0,null)});b.Ha(a.startTime,e);e=new O(e);return{language:d.language,type:d.contentType,primary:d.primary,drmInfos:c,streams:[{id:d.id,createSegmentIndex:Promise.resolve.bind(Promise),\nfindSegmentPosition:e.find.bind(e),getSegmentReference:e.get.bind(e),initSegmentReference:d.initSegmentUri?new yb(function(){return[d.initSegmentUri]},0,null):null,presentationTimeOffset:d.presentationTimeOffset,mimeType:d.mimeType,codecs:d.codecs,bandwidth:0,width:d.width||void 0,height:d.height||void 0,kind:d.kind,encrypted:d.encrypted,keyId:d.keyId,allowedByApplication:!0,allowedByKeySystem:!0}]}})}})}}sc[\"application/x-offline-manifest\"]=Me;function Oe(a){if(/^offline:([0-9]+)$/.exec(a)){var b={uri:a,data:new ArrayBuffer(0),headers:{\"content-type\":\"application/x-offline-manifest\"}};return Promise.resolve(b)}if(b=/^offline:[0-9]+\\/[0-9]+\\/([0-9]+)$/.exec(a)){var c=Number(b[1]),d=new Ae;return d.init(Ge).then(function(){return d.get(\"segment\",c)}).then(function(b){return d.o().then(function(){if(!b)throw new v(9,9003,c);return{uri:a,data:b.data,headers:{}}})})}return Promise.reject(new v(1,9004,a))}m(\"shaka.offline.OfflineScheme\",Oe);\npc.offline=Oe;function Pe(){this.a=Promise.resolve();this.c=this.b=this.f=!1;this.g=new Promise(function(a){this.h=a}.bind(this))}Pe.prototype.then=function(a){this.a=this.a.then(a).then(function(a){return this.c?(this.h(),Promise.reject(this.i)):Promise.resolve(a)}.bind(this));return this};function Qe(a){a.f||(a.a=a.a.then(function(a){this.b=!0;return Promise.resolve(a)}.bind(a),function(a){this.b=!0;return Promise.reject(a)}.bind(a)));a.f=!0;return a.a}\nPe.prototype.cancel=function(a){if(this.b)return Promise.resolve();this.c=!0;this.i=a;return this.g};function Re(a,b,c,d,e){var f=e in d,g;for(g in b){var h=e+\".\"+g,l=f?d[e]:c[g],n=!!{\".abr.manager\":!0}[h];if(f||g in a)void 0===b[g]?void 0===l||f?delete a[g]:a[g]=l:n?a[g]=b[g]:\"object\"==typeof a[g]&&\"object\"==typeof b[g]?Re(a[g],b[g],l,d,h):typeof b[g]==typeof l&&(a[g]=b[g])}};function V(a,b){p.call(this);this.A=!1;this.f=a;this.m=null;this.v=new x;this.Ka=new q;this.pa=this.c=this.l=this.b=this.i=this.qa=this.C=this.F=this.g=this.h=null;this.Ra=1E9;this.oa=[];this.Da=!1;this.sa=!0;this.H=this.j=null;this.s={};this.a=Se(this);this.Ca={width:Infinity,height:Infinity};this.B=[];this.Y=this.K=this.ra=0;b&&b(this);this.h=new P(this.Uc.bind(this));this.qa=Te(this);for(var c=0;c<this.f.textTracks.length;++c){var d=this.f.textTracks[c];d.mode=\"disabled\";\"Shaka Player TextTrack\"==\nd.label&&(this.m=d)}this.m||(this.m=this.f.addTextTrack(\"subtitles\",\"Shaka Player TextTrack\"));this.m.mode=\"hidden\";y(this.v,this.f,\"error\",this.tc.bind(this))}ba(V);m(\"shaka.Player\",V);V.prototype.o=function(){this.A=!0;var a=Promise.resolve();this.j&&(a=this.j.cancel(new v(7,7E3)));return a.then(function(){var a=Promise.all([this.H,Ue(this),this.v?this.v.o():null,this.h?this.h.o():null]);this.a=this.h=this.Ka=this.v=this.m=this.f=null;return a}.bind(this))};V.prototype.destroy=V.prototype.o;\nV.version=\"v2.0.8\";var Ve={};V.registerSupportPlugin=function(a,b){Ve[a]=b};V.isBrowserSupported=function(){return!!window.Promise&&!!window.Uint8Array&&!!Array.prototype.forEach&&!!window.MediaSource&&!!window.MediaKeys&&!!window.navigator&&!!window.navigator.requestMediaKeySystemAccess&&!!window.MediaKeySystemAccess&&!!window.MediaKeySystemAccess.prototype.getConfiguration};\nV.probeSupport=function(){return Xc().then(function(a){var b=uc(),c=cd();a={manifest:b,media:c,drm:a};for(var d in Ve)a[d]=Ve[d]();return a})};\nV.prototype.load=function(a,b,c){var d=this.kb(),e=new Pe;this.j=e;this.dispatchEvent(new t(\"loading\"));return Qe(e.then(function(){return d}).then(function(){return vc(a,this.h,this.a.manifest.retryParameters,c)}.bind(this)).then(function(b){this.l=new b;this.l.configure(this.a.manifest);return this.l.start(a,this.h,this.Na.bind(this),this.ia.bind(this),this.Rc.bind(this))}.bind(this)).then(function(b){if(0==b.periods.length)throw new v(4,4014);this.c=b;this.pa=a;this.g=new Jc(this.h,this.ia.bind(this),\nthis.Sc.bind(this));this.g.configure(this.a.drm);return this.g.init(b,!1)}.bind(this)).then(function(){this.c.periods.forEach(this.Na.bind(this));this.Y=Date.now()/1E3;return Promise.all([Mc(this.g,this.f),this.qa])}.bind(this)).then(function(){this.a.abr.manager.init(this.ib.bind(this));this.i=new Pd(this.f,this.c.presentationTimeline,1*Math.max(this.c.minBufferTime||0,this.a.streaming.rebufferingGoal),b||null,this.Nb.bind(this),this.Tc.bind(this));this.C=new bd(this.f,this.F,this.m);this.b=new Zd(this.i,\nthis.C,this.h,this.c,this.Qc.bind(this),this.Rb.bind(this),this.ia.bind(this));this.b.configure(this.a.streaming);return this.b.init()}.bind(this)).then(function(){this.c.periods.forEach(this.Na.bind(this));We(this);Xe(this);this.j=null}.bind(this)))[\"catch\"](function(a){this.j==e&&(this.j=null,this.dispatchEvent(new t(\"unloading\")));return Promise.reject(a)}.bind(this))};V.prototype.load=V.prototype.load;\nfunction Te(a){a.F=new MediaSource;var b=new w;y(a.v,a.F,\"sourceopen\",b.resolve);a.f.src=window.URL.createObjectURL(a.F);return b}V.prototype.configure=function(a){a.abr&&a.abr.manager&&a.abr.manager!=this.a.abr.manager&&(this.a.abr.manager.stop(),a.abr.manager.init(this.ib.bind(this)));Re(this.a,a,Se(this),Ye(),\"\");Ze(this)};V.prototype.configure=V.prototype.configure;\nfunction Ze(a){a.l&&a.l.configure(a.a.manifest);a.g&&a.g.configure(a.a.drm);if(a.b){a.b.configure(a.a.streaming);try{a.c.periods.forEach(a.Na.bind(a))}catch(b){a.ia(b)}$e(a,ce(a.b))}a.a.abr.enabled&&!a.sa?a.a.abr.manager.enable():a.a.abr.manager.disable();a.a.abr.manager.setDefaultEstimate(a.a.abr.defaultBandwidthEstimate)}V.prototype.getConfiguration=function(){var a=Se(this);Re(a,this.a,Se(this),Ye(),\"\");return a};V.prototype.getConfiguration=V.prototype.getConfiguration;\nV.prototype.Jc=function(){var a=Se(this);a.abr&&a.abr.manager&&a.abr.manager!=this.a.abr.manager&&(this.a.abr.manager.stop(),a.abr.manager.init(this.ib.bind(this)));this.a=Se(this);Ze(this)};V.prototype.resetConfiguration=V.prototype.Jc;V.prototype.$b=function(){return this.f};V.prototype.getMediaElement=V.prototype.$b;V.prototype.rb=function(){return this.h};V.prototype.getNetworkingEngine=V.prototype.rb;V.prototype.Zb=function(){return this.pa};V.prototype.getManifestUri=V.prototype.Zb;\nV.prototype.S=function(){return this.c?this.c.presentationTimeline.S():!1};V.prototype.isLive=V.prototype.S;V.prototype.fa=function(){return this.c?this.c.presentationTimeline.fa():!1};V.prototype.isInProgress=V.prototype.fa;V.prototype.Lc=function(){var a=0,b=0;this.c&&(b=this.c.presentationTimeline,a=b.ua(),b=b.Va());return{start:a,end:b}};V.prototype.seekRange=V.prototype.Lc;V.prototype.keySystem=function(){return this.g?this.g.keySystem():\"\"};V.prototype.keySystem=V.prototype.keySystem;\nV.prototype.drmInfo=function(){return this.g?this.g.b:null};V.prototype.drmInfo=V.prototype.drmInfo;V.prototype.dc=function(){return this.Da};V.prototype.isBuffering=V.prototype.dc;V.prototype.kb=function(){if(this.A)return Promise.resolve();this.dispatchEvent(new t(\"unloading\"));var a=Promise.resolve();this.j&&(a=this.j.cancel(new v(7,7E3)));return a.then(function(){this.H||(this.H=af(this).then(function(){this.H=null}.bind(this)));return this.H}.bind(this))};V.prototype.unload=V.prototype.kb;\nV.prototype.Ua=function(){return this.i?this.i.Ua():0};V.prototype.getPlaybackRate=V.prototype.Ua;V.prototype.ed=function(a){this.i&&Wd(this.i,a)};V.prototype.trickPlay=V.prototype.ed;V.prototype.Sb=function(){this.i&&Wd(this.i,1)};V.prototype.cancelTrickPlay=V.prototype.Sb;V.prototype.getTracks=function(){if(!this.b)return[];var a=de(this.b);return rd(ce(this.b),a).filter(function(a){return 0>this.oa.indexOf(a.id)}.bind(this))};V.prototype.getTracks=V.prototype.getTracks;\nV.prototype.Mc=function(a,b){if(this.b){var c=sd(ce(this.b),a);if(c){var d=c.stream;d.allowedByApplication&&d.allowedByKeySystem&&(this.B.push({timestamp:Date.now()/1E3,id:d.id,type:a.type,fromAdaptation:!1}),c={},c[a.type]=d,\"text\"!=a.type&&(d=de(this.b).text,this.configure({abr:{enabled:!1}}),d&&(c.text=d)),bf(this,c,b))}}};V.prototype.selectTrack=V.prototype.Mc;V.prototype.gc=function(){return\"showing\"==this.m.mode};V.prototype.isTextTrackVisible=V.prototype.gc;\nV.prototype.Oc=function(a){this.m.mode=a?\"showing\":\"hidden\";cf(this)};V.prototype.setTextTrackVisibility=V.prototype.Oc;\nV.prototype.getStats=function(){df(this);var a={},b={},c=this.f&&this.f.getVideoPlaybackQuality?this.f.getVideoPlaybackQuality():{};this.b&&(b=de(this.b),a=b.video||{},b=b.audio||{});return{width:a.width||0,height:a.height||0,streamBandwidth:a.bandwidth+b.bandwidth||0,decodedFrames:Number(c.totalVideoFrames),droppedFrames:Number(c.droppedVideoFrames),estimatedBandwidth:this.a.abr.manager.getBandwidthEstimate(),playTime:this.ra,bufferingTime:this.K,switchHistory:this.B.slice(0)}};\nV.prototype.getStats=V.prototype.getStats;\nV.prototype.addTextTrack=function(a,b,c,d,e){if(!this.b)return Promise.reject();for(var f=ce(this.b),g,h=0;h<this.c.periods.length;h++)if(this.c.periods[h]==f){if(h==this.c.periods.length-1){if(g=this.c.presentationTimeline.ea()-f.startTime,Infinity==g)return Promise.reject()}else g=this.c.periods[h+1].startTime-f.startTime;break}var l={id:this.Ra++,createSegmentIndex:Promise.resolve.bind(Promise),findSegmentPosition:function(){return 1},getSegmentReference:function(b){return 1!=b?null:new J(1,0,\ng,function(){return[a]},0,null)},initSegmentReference:null,presentationTimeOffset:0,mimeType:d,codecs:e||\"\",bandwidth:0,kind:c,encrypted:!1,keyId:null,language:b,allowedByApplication:!0,allowedByKeySystem:!0};d={language:b,type:\"text\",primary:!1,drmInfos:[],streams:[l]};this.oa.push(l.id);f.streamSets.push(d);return ee(this.b,l).then(function(){if(!this.A)return this.oa.splice(this.oa.indexOf(l.id),1),$e(this,f),We(this),{id:l.id,active:!1,type:\"text\",bandwidth:0,language:b,kind:c,width:null,height:null}}.bind(this))};\nV.prototype.addTextTrack=V.prototype.addTextTrack;V.prototype.gb=function(a,b){this.Ca.width=a;this.Ca.height=b};V.prototype.setMaxHardwareResolution=V.prototype.gb;\nfunction Ue(a){a.v&&a.v.la(a.F,\"sourceopen\");a.f&&(a.f.removeAttribute(\"src\"),a.f.load());var b=Promise.all([a.a?a.a.abr.manager.stop():null,a.g?a.g.o():null,a.C?a.C.o():null,a.i?a.i.o():null,a.b?a.b.o():null,a.l?a.l.stop():null]);a.g=null;a.C=null;a.i=null;a.b=null;a.l=null;a.c=null;a.pa=null;a.qa=null;a.F=null;a.s={};a.B=[];a.ra=0;a.K=0;return b}function af(a){return a.l?Ue(a).then(function(){this.A||(this.Nb(!1),this.qa=Te(this))}.bind(a)):Promise.resolve()}\nfunction Ye(){return{\".drm.servers\":\"\",\".drm.clearKeys\":\"\",\".drm.advanced\":{distinctiveIdentifierRequired:!1,persistentStateRequired:!1,videoRobustness:\"\",audioRobustness:\"\",serverCertificate:null}}}\nfunction Se(a){return{drm:{retryParameters:qc(),servers:{},clearKeys:{},advanced:{}},manifest:{retryParameters:qc(),dash:{customScheme:function(a){if(a)return null},clockSyncUri:\"\"}},streaming:{retryParameters:qc(),rebufferingGoal:2,bufferingGoal:10,bufferBehind:30,ignoreTextStreamFailures:!1,useRelativeCueTimestamps:!1},abr:{manager:a.Ka,enabled:!0,defaultBandwidthEstimate:5E5},preferredAudioLanguage:\"\",preferredTextLanguage:\"\",restrictions:{minWidth:0,maxWidth:Infinity,minHeight:0,maxHeight:Infinity,\nminPixels:0,maxPixels:Infinity,minAudioBandwidth:0,maxAudioBandwidth:Infinity,minVideoBandwidth:0,maxVideoBandwidth:Infinity}}}k=V.prototype;k.Na=function(a){var b=this.b?de(this.b):{};pd(this.g,b,a);b=a.streamSets.some(td);od(a,this.a.restrictions,this.Ca)&&!this.j&&We(this);a=!a.streamSets.some(td);if(!b)throw new v(4,4011);if(a)throw new v(4,4012);};function bf(a,b,c){for(var d in b){var e=b[d],f=c||!1;\"text\"==d&&(f=!0);a.sa?a.s[d]={stream:e,Vb:f}:fe(a.b,d,e,f)}}\nfunction df(a){if(a.c){var b=Date.now()/1E3;a.Da?a.K+=b-a.Y:a.ra+=b-a.Y;a.Y=b}}k.Uc=function(a,b,c){this.a.abr.manager.segmentDownloaded(a,b,c)};k.Nb=function(a){df(this);this.Da=a;this.dispatchEvent(new t(\"buffering\",{buffering:a}))};k.Tc=function(){this.b&&ie(this.b)};\nfunction ef(a,b,c){if(!F(b).some(td))return a.ia(new v(4,4012)),{};var d={};if(c)[\"video\",\"audio\",\"text\"].forEach(function(a){a in b&&(d[a]=b[a])});else{c=de(a.b);for(var e in c){var f=c[e];f.allowedByApplication&&f.allowedByKeySystem&&b[e].language==f.language||(d[e]=b[e])}}if(Na(d))return{};ha(Object.keys(d));var g=a.a.abr.manager.chooseStreams(d);return Pa(d,function(a){return!!g[a]})?g:(a.ia(new v(4,4012)),{})}\nfunction $e(a,b){var c={audio:!1,text:!1},d=ud(b,a.a,c),e=ef(a,d),f;for(f in e)a.B.push({timestamp:Date.now()/1E3,id:e[f].id,type:f,fromAdaptation:!0});bf(a,e,!0);Xe(a);d.text&&d.audio&&c.text&&d.text.language!=d.audio.language&&(a.m.mode=\"showing\",cf(a))}k.Qc=function(a){this.sa=!0;this.a.abr.manager.disable();a=ud(a,this.a);a=ef(this,a,!0);for(var b in this.s)a[b]=this.s[b].stream;this.s={};for(b in a)this.B.push({timestamp:Date.now()/1E3,id:a[b].id,type:b,fromAdaptation:!0});this.j||We(this);return a};\nk.Rb=function(){this.sa=!1;this.a.abr.enabled&&this.a.abr.manager.enable();for(var a in this.s){var b=this.s[a];fe(this.b,a,b.stream,b.Vb)}this.s={}};k.ib=function(a,b){var c=de(this.b),d;for(d in a){var e=a[d];c[d]!=e?this.B.push({timestamp:Date.now()/1E3,id:e.id,type:d,fromAdaptation:!0}):delete a[d]}if(!Na(a)&&this.b){for(d in a)fe(this.b,d,a[d],b||!1);Xe(this)}};function Xe(a){Promise.resolve().then(function(){this.A||this.dispatchEvent(new t(\"adaptation\"))}.bind(a))}\nfunction We(a){Promise.resolve().then(function(){this.A||this.dispatchEvent(new t(\"trackschanged\"))}.bind(a))}function cf(a){a.dispatchEvent(new t(\"texttrackvisibility\"))}k.ia=function(a){this.dispatchEvent(new t(\"error\",{detail:a}))};k.Rc=function(a){this.dispatchEvent(a)};k.tc=function(){if(this.f.error){var a=this.f.error.code;if(1!=a){var b=this.f.error.msExtendedCode;b&&(0>b&&(b+=Math.pow(2,32)),b=b.toString(16));this.ia(new v(3,3016,a,b))}}};\nk.Sc=function(a){var b=[\"output-restricted\",\"internal-error\"],c=ce(this.b),d=!1;c.streamSets.forEach(function(c){c.streams.forEach(function(c){var e=c.allowedByKeySystem;c.keyId&&c.keyId in a&&(c.allowedByKeySystem=0>b.indexOf(a[c.keyId]));e!=c.allowedByKeySystem&&(d=!0)})});$e(this,c);d&&We(this)};function W(a){this.a=new Ae;this.c=a;this.j=ff(this);this.g=null;this.v=!1;this.i=null;this.l=[];this.f=-1;this.m=0;this.b=null;this.h=new Ie(a.h,a.getConfiguration().streaming.retryParameters,this.j)}m(\"shaka.offline.Storage\",W);function gf(){return!!window.indexedDB}W.support=gf;\nW.prototype.o=function(){var a=this.l,b=this.a,c=this.h?this.h.o()[\"catch\"](function(){}).then(function(){return Promise.all(a.map(function(a){return b.remove(\"segment\",a)}))}).then(function(){return b.o()}):Promise.resolve();this.j=this.c=this.h=this.a=null;return c};W.prototype.destroy=W.prototype.o;W.prototype.configure=function(a){Re(this.j,a,ff(this),{},\"\")};W.prototype.configure=W.prototype.configure;\nW.prototype.ad=function(a,b,c){function d(a){f=a}if(this.v)return Promise.reject(new v(9,9006));this.v=!0;var e,f=null;return hf(this).then(function(){Y(this);return jf(this,a,d,c)}.bind(this)).then(function(c){Y(this);this.b=c.manifest;this.g=c.Wb;if(this.b.presentationTimeline.S()||this.b.presentationTimeline.fa())throw new v(9,9005,a);this.b.periods.forEach(this.s.bind(this));this.f=this.a.b.manifest++;this.m=0;c=this.b.periods.map(this.A.bind(this));var d=this.g.b,f=Rc(this.g);if(d){if(!f.length)throw new v(9,\n9007,a);d.initData=[]}e={key:this.f,originalManifestUri:a,duration:this.m,size:0,periods:c,sessionIds:f,drmInfo:d,appMetadata:b};return Ke(this.h,e)}.bind(this)).then(function(){Y(this);if(f)throw f;return Ee(this.a,\"manifest\",e)}.bind(this)).then(function(){return kf(this)}.bind(this)).then(function(){return He(e)}.bind(this))[\"catch\"](function(a){return kf(this)[\"catch\"](C).then(function(){throw a;})}.bind(this))};W.prototype.store=W.prototype.ad;\nW.prototype.remove=function(a){function b(a){6013!=a.code&&(e=a)}var c=a.offlineUri,d=/^offline:([0-9]+)$/.exec(c);if(!d)return Promise.reject(new v(9,9004,c));var e=null,f,g,h=Number(d[1]);return hf(this).then(function(){Y(this);return this.a.get(\"manifest\",h)}.bind(this)).then(function(a){Y(this);if(!a)throw new v(9,9003,c);f=a;a=Ne(f);g=new Jc(this.c.h,b,function(){});g.configure(this.c.getConfiguration().drm);return g.init(a,!0)}.bind(this)).then(function(){return Oc(g,f.sessionIds)}.bind(this)).then(function(){return g.o()}.bind(this)).then(function(){Y(this);\nif(e)throw e;var b=f.periods.map(function(a){return a.streams.map(function(a){var b=a.segments.map(function(a){a=/^offline:[0-9]+\\/[0-9]+\\/([0-9]+)$/.exec(a.uri);return Number(a[1])});a.initSegmentUri&&(a=/^offline:[0-9]+\\/[0-9]+\\/([0-9]+)$/.exec(a.initSegmentUri),b.push(Number(a[1])));return b}).reduce(B,[])}).reduce(B,[]),c=0,d=b.length,g=this.j.progressCallback;return Fe(this.a,function(e){e=b.indexOf(e.key);0<=e&&(g(a,c/d),c++);return 0<=e}.bind(this))}.bind(this)).then(function(){Y(this);this.j.progressCallback(a,\n1);return this.a.remove(\"manifest\",h)}.bind(this))};W.prototype.remove=W.prototype.remove;W.prototype.list=function(){var a=[];return hf(this).then(function(){Y(this);return this.a.forEach(\"manifest\",function(b){a.push(He(b))})}.bind(this)).then(function(){return a})};W.prototype.list=W.prototype.list;\nfunction jf(a,b,c,d){function e(){}var f=a.c.h,g=a.c.getConfiguration(),h,l,n;return vc(b,f,g.manifest.retryParameters,d).then(function(a){Y(this);n=new a;n.configure(g.manifest);return n.start(b,f,this.s.bind(this),c)}.bind(a)).then(function(a){Y(this);h=a;l=new Jc(f,c,e);l.configure(g.drm);return l.init(h,!0)}.bind(a)).then(function(){Y(this);return lf(h)}.bind(a)).then(function(){Y(this);return Nc(l)}.bind(a)).then(function(){Y(this);return n.stop()}.bind(a)).then(function(){Y(this);return{manifest:h,\nWb:l}}.bind(a))[\"catch\"](function(a){if(n)return n.stop().then(function(){throw a;});throw a;})}\nW.prototype.B=function(a){var b=[],c=a.filter(function(a){return\"video\"==a.type&&480>=a.height});c.sort(function(a,b){return b.bandwidth-a.bandwidth});c.length&&b.push(c[0]);for(var d=Ec(this.c.getConfiguration().preferredAudioLanguage),c=[0,Cc,Dc],e=a.filter(function(a){return\"audio\"==a.type}),c=c.map(function(a){return e.filter(function(b){b=Ec(b.language);return Bc(a,d,b)})}),f=e,g=0;g<c.length;g++)c[g].length&&(f=c[g]);f.sort(function(a,b){return a.bandwidth-b.bandwidth});f.length&&b.push(f[Math.floor(f.length/\n2)]);var c=Ec(this.c.getConfiguration().preferredTextLanguage),h=Bc.bind(null,Dc,c);b.push.apply(b,a.filter(function(a){var b=Ec(a.language);return\"text\"==a.type&&h(b)}));return b};function ff(a){return{trackSelectionCallback:a.B.bind(a),progressCallback:function(a,c){if(a||c)return null}}}function hf(a){return a.a.a?Promise.resolve():a.a.init(Ge)}\nW.prototype.s=function(a){function b(a,b,c){b=b.filter(function(a){return a.type==c});return 0==b.length?null:sd(a,b[0]).stream}var c={};this.i&&(c={video:b(this.b.periods[0],this.i,\"video\"),audio:b(this.b.periods[0],this.i,\"audio\")});pd(this.g,c,a);od(a,this.c.getConfiguration().restrictions,{width:Infinity,height:Infinity})};function kf(a){var b=a.g?a.g.o():Promise.resolve();a.g=null;a.b=null;a.v=!1;a.i=null;a.l=[];a.f=-1;return b}\nfunction lf(a){a=a.periods.map(function(a){return a.streamSets}).reduce(B,[]).map(function(a){return a.streams}).reduce(B,[]);return Promise.all(a.map(function(a){return a.createSegmentIndex()}))}\nW.prototype.A=function(a){var b=rd(a,null),b=this.j.trackSelectionCallback(b);this.i||(this.i=b,this.b.periods.forEach(this.s.bind(this)));for(var c=b.length-1;0<c;--c){for(var d=!1,e=c-1;0<=e;--e)if(b[c].type==b[e].type&&b[c].kind==b[e].kind&&b[c].language==b[e].language){d=!0;break}if(d)break}b=b.map(function(b){b=sd(a,b);return mf(this,a,b.bd,b.stream)}.bind(this));return{startTime:a.startTime,streams:b}};\nfunction mf(a,b,c,d){for(var e=[],f=a.b.presentationTimeline.ta(),g=f,h=d.findSegmentPosition(f),l=null!=h?d.getSegmentReference(h):null;l;){var n=a.a.b.segment++;Je(a.h,c.type,l,(l.endTime-l.startTime)*d.bandwidth/8,function(a,b,c,d){b={key:a,data:d,manifestKey:this.f,streamNumber:c,segmentNumber:b};this.l.push(a);return Ee(this.a,\"segment\",b)}.bind(a,n,l.position,d.id));e.push({startTime:l.startTime,endTime:l.endTime,uri:\"offline:\"+a.f+\"/\"+d.id+\"/\"+n});g=l.endTime+b.startTime;l=d.getSegmentReference(++h)}a.m=\nMath.max(a.m,g-f);b=null;d.initSegmentReference&&(n=a.a.b.segment++,b=\"offline:\"+a.f+\"/\"+d.id+\"/\"+n,Je(a.h,c.type,d.initSegmentReference,0,function(a,b){var c={key:n,data:b,manifestKey:this.f,streamNumber:a,segmentNumber:-1};this.l.push(n);return Ee(this.a,\"segment\",c)}.bind(a,d.id)));return{id:d.id,primary:c.primary,presentationTimeOffset:d.presentationTimeOffset||0,contentType:c.type,mimeType:d.mimeType,codecs:d.codecs,frameRate:d.frameRate,kind:d.kind,language:c.language,width:d.width||null,height:d.height||\nnull,initSegmentUri:b,encrypted:d.encrypted,keyId:d.keyId,segments:e}}function Y(a){if(!a.c)throw new v(9,9002);}Ve.offline=gf;m(\"shaka.polyfill.installAll\",function(){for(var a=0;a<nf.length;++a)nf[a]()});var nf=[];function of(a){nf.push(a)}m(\"shaka.polyfill.register\",of);function pf(a){var b=a.type.replace(/^(webkit|moz|MS)/,\"\").toLowerCase(),b=new Event(b,a);a.target.dispatchEvent(b)}\nof(function(){if(window.Document){var a=Element.prototype;a.requestFullscreen=a.requestFullscreen||a.mozRequestFullScreen||a.msRequestFullscreen||a.webkitRequestFullscreen;a=Document.prototype;a.exitFullscreen=a.exitFullscreen||a.mozCancelFullScreen||a.msExitFullscreen||a.webkitExitFullscreen;\"fullscreenElement\"in document||(Object.defineProperty(document,\"fullscreenElement\",{get:function(){return document.mozFullScreenElement||document.msFullscreenElement||document.webkitFullscreenElement}}),Object.defineProperty(document,\n\"fullscreenEnabled\",{get:function(){return document.mozFullScreenEnabled||document.msFullscreenEnabled||document.webkitFullscreenEnabled}}));document.addEventListener(\"webkitfullscreenchange\",pf);document.addEventListener(\"webkitfullscreenerror\",pf);document.addEventListener(\"mozfullscreenchange\",pf);document.addEventListener(\"mozfullscreenerror\",pf);document.addEventListener(\"MSFullscreenChange\",pf);document.addEventListener(\"MSFullscreenError\",pf)}});of(function(){var a=navigator.userAgent;a&&0<=a.indexOf(\"CrKey\")&&delete window.indexedDB});function qf(a){this.c=[];this.b=[];this.a=[];for(a=new Jb(new DataView(a.buffer));Lb(a);){var b=Sb(1886614376,a);if(-1==b)break;var c=a.a-8,d=Mb(a);if(1<d)N(a,b-(a.a-c));else{N(a,3);var e=Ta(Qb(a,16)),f=[];if(0<d)for(var d=M(a),g=0;g<d;++g){var h=Ta(Qb(a,16));f.push(h)}d=M(a);N(a,d);this.b.push.apply(this.b,f);this.c.push(e);this.a.push({start:c,end:a.a-1});a.a!=c+b&&N(a,b-(a.a-c))}}};function rf(a,b){try{var c=new sf(a,b);return Promise.resolve(c)}catch(d){return Promise.reject(d)}}\nfunction sf(a,b){this.keySystem=a;for(var c=!1,d=0;d<b.length;++d){var e=b[d],f={audioCapabilities:[],videoCapabilities:[],persistentState:\"optional\",distinctiveIdentifier:\"optional\",initDataTypes:e.initDataTypes,sessionTypes:[\"temporary\"],label:e.label},g=!1;if(e.audioCapabilities)for(var h=0;h<e.audioCapabilities.length;++h){var l=e.audioCapabilities[h];if(l.contentType){var g=!0,n=l.contentType.split(\";\")[0];MSMediaKeys.isTypeSupported(this.keySystem,n)&&(f.audioCapabilities.push(l),c=!0)}}if(e.videoCapabilities)for(h=\n0;h<e.videoCapabilities.length;++h)l=e.videoCapabilities[h],l.contentType&&(g=!0,n=l.contentType.split(\";\")[0],MSMediaKeys.isTypeSupported(this.keySystem,n)&&(f.videoCapabilities.push(l),c=!0));g||(c=MSMediaKeys.isTypeSupported(this.keySystem,\"video/mp4\"));\"required\"==e.persistentState&&(f.persistentState=\"required\",f.sessionTypes=[\"persistent-license\"]);if(c){this.a=f;return}}c=Error(\"Unsupported keySystem\");c.name=\"NotSupportedError\";c.code=DOMException.NOT_SUPPORTED_ERR;throw c;}\nsf.prototype.createMediaKeys=function(){var a=new tf(this.keySystem);return Promise.resolve(a)};sf.prototype.getConfiguration=function(){return this.a};function uf(a){var b=this.mediaKeys;b&&b!=a&&vf(b,null);delete this.mediaKeys;return(this.mediaKeys=a)?vf(a,this):Promise.resolve()}function tf(a){this.a=new MSMediaKeys(a);this.b=new x}tf.prototype.createSession=function(a){if(\"temporary\"!=(a||\"temporary\"))throw new TypeError(\"Session type \"+a+\" is unsupported on this platform.\");return new wf(this.a)};\ntf.prototype.setServerCertificate=function(){return Promise.reject(Error(\"setServerCertificate not supported on this platform.\"))};function vf(a,b){function c(){b.msSetMediaKeys(d.a);b.removeEventListener(\"loadedmetadata\",c)}Ca(a.b);if(!b)return Promise.resolve();y(a.b,b,\"msneedkey\",xf);var d=a;try{return 1<=b.readyState?b.msSetMediaKeys(a.a):b.addEventListener(\"loadedmetadata\",c),Promise.resolve()}catch(e){return Promise.reject(e)}}\nfunction wf(a){p.call(this);this.c=null;this.g=a;this.b=this.a=null;this.f=new x;this.sessionId=\"\";this.expiration=NaN;this.closed=new w;this.keyStatuses=new yf}ba(wf);k=wf.prototype;k.generateRequest=function(a,b){this.a=new w;try{this.c=this.g.createSession(\"video/mp4\",new Uint8Array(b),null),y(this.f,this.c,\"mskeymessage\",this.pc.bind(this)),y(this.f,this.c,\"mskeyadded\",this.nc.bind(this)),y(this.f,this.c,\"mskeyerror\",this.oc.bind(this)),zf(this,\"status-pending\")}catch(c){this.a.reject(c)}return this.a};\nk.load=function(){return Promise.reject(Error(\"MediaKeySession.load not yet supported\"))};k.update=function(a){this.b=new w;try{this.c.update(new Uint8Array(a))}catch(b){this.b.reject(b)}return this.b};k.close=function(){try{this.c.close(),this.closed.resolve(),Ca(this.f)}catch(a){this.closed.reject(a)}return this.closed};k.remove=function(){return Promise.reject(Error(\"MediaKeySession.remove is only applicable for persistent licenses, which are not supported on this platform\"))};\nfunction xf(a){var b=document.createEvent(\"CustomEvent\");b.initCustomEvent(\"encrypted\",!1,!1,null);b.initDataType=\"cenc\";if(a=a.initData){var c=new qf(a);if(!(1>=c.a.length)){for(var d=[],e=0;e<c.a.length;e++)d.push(a.subarray(c.a[e].start,c.a[e].end+1));e=Af;a=[];for(c=0;c<d.length;++c){for(var f=!1,g=0;g<a.length&&!(f=e?e(d[c],a[g]):d[c]===a[g]);++g);f||a.push(d[c])}for(e=d=0;e<a.length;e++)d+=a[e].length;d=new Uint8Array(d);for(e=c=0;e<a.length;e++)d.set(a[e],c),c+=a[e].length;a=d}}b.initData=\na;this.dispatchEvent(b)}function Af(a,b){return Ua(a,b)}k.pc=function(a){this.a&&(this.a.resolve(),this.a=null);this.dispatchEvent(new t(\"message\",{messageType:void 0==this.keyStatuses.Wa()?\"licenserequest\":\"licenserenewal\",message:a.message.buffer}))};k.nc=function(){this.a?(zf(this,\"usable\"),this.a.resolve(),this.a=null):this.b&&(zf(this,\"usable\"),this.b.resolve(),this.b=null)};\nk.oc=function(){var a=Error(\"EME PatchedMediaKeysMs key error\");a.errorCode=this.c.error;if(this.a)this.a.reject(a),this.a=null;else if(this.b)this.b.reject(a),this.b=null;else switch(this.c.error.code){case MSMediaKeyError.MS_MEDIA_KEYERR_OUTPUT:case MSMediaKeyError.MS_MEDIA_KEYERR_HARDWARECHANGE:zf(this,\"output-not-allowed\");default:zf(this,\"internal-error\")}};function zf(a,b){a.keyStatuses.hb(b);a.dispatchEvent(new t(\"keystatuseschange\"))}function yf(){this.size=0;this.a=void 0}var Bf;k=yf.prototype;\nk.hb=function(a){this.size=void 0==a?0:1;this.a=a};k.Wa=function(){return this.a};k.forEach=function(a){this.a&&a(this.a,Bf)};k.get=function(a){if(this.has(a))return this.a};k.has=function(a){var b=Bf;return this.a&&Ua(new Uint8Array(a),new Uint8Array(b))?!0:!1};k.keys=function(){};function Cf(){return Promise.reject(Error(\"The key system specified is not supported.\"))}function Df(a){return a?Promise.reject(Error(\"MediaKeys not supported.\")):Promise.resolve()}function Ef(){throw new TypeError(\"Illegal constructor.\");}Ef.prototype.createSession=function(){};Ef.prototype.setServerCertificate=function(){};function Ff(){throw new TypeError(\"Illegal constructor.\");}Ff.prototype.getConfiguration=function(){};Ff.prototype.createMediaKeys=function(){};var Gf=\"\";function Hf(a){Gf=a;If=(new Uint8Array([0])).buffer;navigator.requestMediaKeySystemAccess=Jf;delete HTMLMediaElement.prototype.mediaKeys;HTMLMediaElement.prototype.mediaKeys=null;HTMLMediaElement.prototype.setMediaKeys=Kf;window.MediaKeys=Lf;window.MediaKeySystemAccess=Mf}function Nf(a){var b=Gf;return b?b+a.charAt(0).toUpperCase()+a.slice(1):a}function Jf(a,b){try{var c=new Mf(a,b);return Promise.resolve(c)}catch(d){return Promise.reject(d)}}\nfunction Kf(a){var b=this.mediaKeys;b&&b!=a&&Of(b,null);delete this.mediaKeys;(this.mediaKeys=a)&&Of(a,this);return Promise.resolve()}\nfunction Mf(a,b){this.a=this.keySystem=a;var c=!0;\"org.w3.clearkey\"==a&&(this.a=\"webkit-org.w3.clearkey\",c=!1);var d=!1,e;e=document.getElementsByTagName(\"video\");e=e.length?e[0]:document.createElement(\"video\");for(var f=0;f<b.length;++f){var g=b[f],h={audioCapabilities:[],videoCapabilities:[],persistentState:\"optional\",distinctiveIdentifier:\"optional\",initDataTypes:g.initDataTypes,sessionTypes:[\"temporary\"],label:g.label},l=!1;if(g.audioCapabilities)for(var n=0;n<g.audioCapabilities.length;++n){var r=\ng.audioCapabilities[n];if(r.contentType){var l=!0,u=r.contentType.split(\";\")[0];e.canPlayType(u,this.a)&&(h.audioCapabilities.push(r),d=!0)}}if(g.videoCapabilities)for(n=0;n<g.videoCapabilities.length;++n)r=g.videoCapabilities[n],r.contentType&&(l=!0,e.canPlayType(r.contentType,this.a)&&(h.videoCapabilities.push(r),d=!0));l||(d=e.canPlayType(\"video/mp4\",this.a)||e.canPlayType(\"video/webm\",this.a));\"required\"==g.persistentState&&(c?(h.persistentState=\"required\",h.sessionTypes=[\"persistent-license\"]):\nd=!1);if(d){this.b=h;return}}c=\"Unsupported keySystem\";if(\"org.w3.clearkey\"==a||\"com.widevine.alpha\"==a)c=\"None of the requested configurations were supported.\";c=Error(c);c.name=\"NotSupportedError\";c.code=DOMException.NOT_SUPPORTED_ERR;throw c;}Mf.prototype.createMediaKeys=function(){var a=new Lf(this.a);return Promise.resolve(a)};Mf.prototype.getConfiguration=function(){return this.b};function Lf(a){this.g=a;this.b=null;this.a=new x;this.c=[];this.f={}}\nfunction Of(a,b){a.b=b;Ca(a.a);var c=Gf;b&&(y(a.a,b,c+\"needkey\",a.yc.bind(a)),y(a.a,b,c+\"keymessage\",a.xc.bind(a)),y(a.a,b,c+\"keyadded\",a.vc.bind(a)),y(a.a,b,c+\"keyerror\",a.wc.bind(a)))}k=Lf.prototype;k.createSession=function(a){var b=a||\"temporary\";if(\"temporary\"!=b&&\"persistent-license\"!=b)throw new TypeError(\"Session type \"+a+\" is unsupported on this platform.\");a=this.b||document.createElement(\"video\");a.src||(a.src=\"about:blank\");b=new Pf(a,this.g,b);this.c.push(b);return b};\nk.setServerCertificate=function(){return Promise.reject(Error(\"setServerCertificate not supported on this platform.\"))};k.yc=function(a){var b=document.createEvent(\"CustomEvent\");b.initCustomEvent(\"encrypted\",!1,!1,null);b.initDataType=\"webm\";b.initData=a.initData;this.b.dispatchEvent(b)};k.xc=function(a){var b=Qf(this,a.sessionId);b&&(a=new t(\"message\",{messageType:void 0==b.keyStatuses.Wa()?\"licenserequest\":\"licenserenewal\",message:a.message}),b.b&&(b.b.resolve(),b.b=null),b.dispatchEvent(a))};\nk.vc=function(a){if(a=Qf(this,a.sessionId))Rf(a,\"usable\"),a.a&&a.a.resolve(),a.a=null};\nk.wc=function(a){var b=Qf(this,a.sessionId);if(b){var c=Error(\"EME v0.1b key error\");c.errorCode=a.errorCode;c.errorCode.systemCode=a.systemCode;!a.sessionId&&b.b?(c.method=\"generateRequest\",45==a.systemCode&&(c.message=\"Unsupported session type.\"),b.b.reject(c),b.b=null):a.sessionId&&b.a?(c.method=\"update\",b.a.reject(c),b.a=null):(c=a.systemCode,a.errorCode.code==MediaKeyError.MEDIA_KEYERR_OUTPUT?Rf(b,\"output-restricted\"):1==c?Rf(b,\"expired\"):Rf(b,\"internal-error\"))}};\nfunction Qf(a,b){var c=a.f[b];return c?c:(c=a.c.shift())?(c.sessionId=b,a.f[b]=c):null}function Pf(a,b,c){p.call(this);this.f=a;this.h=!1;this.a=this.b=null;this.c=b;this.g=c;this.sessionId=\"\";this.expiration=NaN;this.closed=new w;this.keyStatuses=new Sf}ba(Pf);\nfunction Tf(a,b,c){if(a.h)return Promise.reject(Error(\"The session is already initialized.\"));a.h=!0;var d;try{if(\"persistent-license\"==a.g)if(c)d=new Uint8Array(Ib(\"LOAD_SESSION|\"+c));else{var e=Ib(\"PERSISTENT|\"),f=new Uint8Array(e.byteLength+b.byteLength);f.set(new Uint8Array(e),0);f.set(new Uint8Array(b),e.byteLength);d=f}else d=new Uint8Array(b)}catch(h){return Promise.reject(h)}a.b=new w;var g=Nf(\"generateKeyRequest\");try{a.f[g](a.c,d)}catch(h){if(\"InvalidStateError\"!=h.name)return a.b=null,\nPromise.reject(h);setTimeout(function(){try{this.f[g](this.c,d)}catch(l){this.b.reject(l),this.b=null}}.bind(a),10)}return a.b}k=Pf.prototype;\nk.jb=function(a,b){if(this.a)this.a.then(this.jb.bind(this,a,b))[\"catch\"](this.jb.bind(this,a,b));else{this.a=a;var c,d;\"webkit-org.w3.clearkey\"==this.c?(c=Eb(b),d=JSON.parse(c),\"oct\"!=d.keys[0].kty&&(this.a.reject(Error(\"Response is not a valid JSON Web Key Set.\")),this.a=null),c=Ra(d.keys[0].k),d=Ra(d.keys[0].kid)):(c=new Uint8Array(b),d=null);var e=Nf(\"addKey\");try{this.f[e](this.c,c,d,this.sessionId)}catch(f){this.a.reject(f),this.a=null}}};\nfunction Rf(a,b){a.keyStatuses.hb(b);a.dispatchEvent(new t(\"keystatuseschange\"))}k.generateRequest=function(a,b){return Tf(this,b,null)};k.load=function(a){return\"persistent-license\"==this.g?Tf(this,null,a):Promise.reject(Error(\"Not a persistent session.\"))};k.update=function(a){var b=new w;this.jb(b,a);return b};\nk.close=function(){if(\"persistent-license\"!=this.g){if(!this.sessionId)return this.closed.reject(Error(\"The session is not callable.\")),this.closed;var a=Nf(\"cancelKeyRequest\");try{this.f[a](this.c,this.sessionId)}catch(b){}}this.closed.resolve();return this.closed};k.remove=function(){return\"persistent-license\"!=this.g?Promise.reject(Error(\"Not a persistent session.\")):this.close()};function Sf(){this.size=0;this.a=void 0}var If;k=Sf.prototype;k.hb=function(a){this.size=void 0==a?0:1;this.a=a};\nk.Wa=function(){return this.a};k.forEach=function(a){this.a&&a(this.a,If)};k.get=function(a){if(this.has(a))return this.a};k.has=function(a){var b=If;return this.a&&Ua(new Uint8Array(a),new Uint8Array(b))?!0:!1};k.keys=function(){};of(function(){!window.HTMLVideoElement||navigator.requestMediaKeySystemAccess&&MediaKeySystemAccess.prototype.getConfiguration||(HTMLMediaElement.prototype.webkitGenerateKeyRequest?Hf(\"webkit\"):HTMLMediaElement.prototype.generateKeyRequest?Hf(\"\"):window.MSMediaKeys?(Bf=(new Uint8Array([0])).buffer,delete HTMLMediaElement.prototype.mediaKeys,HTMLMediaElement.prototype.mediaKeys=null,HTMLMediaElement.prototype.setMediaKeys=uf,window.MediaKeys=tf,window.MediaKeySystemAccess=sf,navigator.requestMediaKeySystemAccess=\nrf):(navigator.requestMediaKeySystemAccess=Cf,delete HTMLMediaElement.prototype.mediaKeys,HTMLMediaElement.prototype.mediaKeys=null,HTMLMediaElement.prototype.setMediaKeys=Df,window.MediaKeys=Ef,window.MediaKeySystemAccess=Ff))});function Uf(){var a=MediaSource.prototype.addSourceBuffer;MediaSource.prototype.addSourceBuffer=function(){var b=a.apply(this,arguments);b.abort=function(){};return b}}\nfunction Vf(){var a=MediaSource.prototype.endOfStream;MediaSource.prototype.endOfStream=function(){for(var b=0,d=0;d<this.sourceBuffers.length;++d)var e=this.sourceBuffers[d],e=e.buffered.end(e.buffered.length-1),b=Math.max(b,e);if(!isNaN(this.duration)&&b<this.duration)for(this.sb=!0,d=0;d<this.sourceBuffers.length;++d)e=this.sourceBuffers[d],e.ob=!1;return a.apply(this,arguments)};var b=MediaSource.prototype.addSourceBuffer;MediaSource.prototype.addSourceBuffer=function(){var a=b.apply(this,arguments);\na.F=this;a.addEventListener(\"updateend\",Wf,!1);this.a||(this.addEventListener(\"sourceclose\",Xf,!1),this.a=!0);return a}}function Wf(a){var b=a.target,c=b.F;if(c.sb){a.preventDefault();a.stopPropagation();a.stopImmediatePropagation();b.ob=!0;for(a=0;a<c.sourceBuffers.length;++a)if(0==c.sourceBuffers[a].ob)return;c.sb=!1}}function Xf(a){a=a.target;for(var b=0;b<a.sourceBuffers.length;++b)a.sourceBuffers[b].removeEventListener(\"updateend\",Wf,!1);a.removeEventListener(\"sourceclose\",Xf,!1)}\nof(function(){if(window.MediaSource){var a=navigator.vendor,b=navigator.appVersion;!a||!b||0>a.indexOf(\"Apple\")||(0<=b.indexOf(\"Version/8\")?window.MediaSource=null:0<=b.indexOf(\"Version/9\")?Uf():0<=b.indexOf(\"Version/10\")&&(Uf(),Vf()))}});function Z(a){this.c=[];this.b=[];this.ka=Yf;if(a)try{a(this.X.bind(this),this.a.bind(this))}catch(b){this.a(b)}}var Yf=0;function Zf(a){var b=new Z;b.X(void 0);return b.then(function(){return a})}function $f(a){var b=new Z;b.a(a);return b}function ag(a){function b(a,b,c){a.ka==Yf&&(e[b]=c,d++,d==e.length&&a.X(e))}var c=new Z;if(!a.length)return c.X([]),c;for(var d=0,e=Array(a.length),f=c.a.bind(c),g=0;g<a.length;++g)a[g]&&a[g].then?a[g].then(b.bind(null,c,g),f):b(c,g,a[g]);return c}\nfunction bg(a){for(var b=new Z,c=b.X.bind(b),d=b.a.bind(b),e=0;e<a.length;++e)a[e]&&a[e].then?a[e].then(c,d):c(a[e]);return b}Z.prototype.then=function(a,b){var c=new Z;switch(this.ka){case 1:cg(this,c,a);break;case 2:cg(this,c,b);break;case Yf:this.c.push({J:c,Ea:a}),this.b.push({J:c,Ea:b})}return c};Z.prototype[\"catch\"]=function(a){return this.then(void 0,a)};\nZ.prototype.X=function(a){if(this.ka==Yf){this.Pa=a;this.ka=1;for(a=0;a<this.c.length;++a)cg(this,this.c[a].J,this.c[a].Ea);this.c=[];this.b=[]}};Z.prototype.a=function(a){if(this.ka==Yf){this.Pa=a;this.ka=2;for(a=0;a<this.b.length;++a)cg(this,this.b[a].J,this.b[a].Ea);this.c=[];this.b=[]}};\nfunction cg(a,b,c){dg.push(function(){if(c&&\"function\"==typeof c){try{var a=c(this.Pa)}catch(f){b.a(f);return}var e;try{e=a&&a.then}catch(f){b.a(f);return}a instanceof Z?a==b?b.a(new TypeError(\"Chaining cycle detected\")):a.then(b.X.bind(b),b.a.bind(b)):e?eg(a,e,b):b.X(a)}else 1==this.ka?b.X(this.Pa):b.a(this.Pa)}.bind(a));null==fg&&(fg=gg(hg))}\nfunction eg(a,b,c){try{var d=!1;b.call(a,function(a){if(!d){d=!0;var b;try{b=a&&a.then}catch(g){c.a(g);return}b?eg(a,b,c):c.X(a)}},c.a.bind(c))}catch(e){c.a(e)}}function hg(){for(;dg.length;){null!=fg&&(ig(fg),fg=null);var a=dg;dg=[];for(var b=0;b<a.length;++b)a[b]()}}function gg(){return 0}function ig(){}var fg=null,dg=[];\nof(function(a){window.setImmediate?(gg=function(a){return window.setImmediate(a)},ig=function(a){return window.clearImmediate(a)}):(gg=function(a){return window.setTimeout(a,0)},ig=function(a){return window.clearTimeout(a)});if(!window.Promise||a)window.Promise=Z,window.Promise.resolve=Zf,window.Promise.reject=$f,window.Promise.all=ag,window.Promise.race=bg,window.Promise.prototype.then=Z.prototype.then,window.Promise.prototype[\"catch\"]=Z.prototype[\"catch\"]});function jg(){return{droppedVideoFrames:this.webkitDroppedFrameCount,totalVideoFrames:this.webkitDecodedFrameCount,corruptedVideoFrames:0,creationTime:NaN,totalFrameDelay:0}}of(function(){if(window.HTMLVideoElement){var a=HTMLVideoElement.prototype;!a.getVideoPlaybackQuality&&\"webkitDroppedFrameCount\"in a&&(a.getVideoPlaybackQuality=jg)}});function kg(a,b,c){return new window.TextTrackCue(a,b,c)}function lg(a,b,c){return new window.TextTrackCue(a+\"-\"+b+\"-\"+c,a,b,c)}of(function(){if(!window.VTTCue&&window.TextTrackCue){var a=TextTrackCue.length;if(3==a)window.VTTCue=kg;else if(6==a)window.VTTCue=lg;else{var b;try{b=!!kg(1,2,\"\")}catch(c){b=!1}b&&(window.VTTCue=kg)}}});}.call(g,this));\nif (typeof(module)!=\"undefined\"&&module.exports)module.exports=g.shaka;\nelse if (typeof(define)!=\"undefined\" && define.amd)define(function(){return g.shaka});\nelse this.shaka=g.shaka;\n})();\n\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/karma.conf.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Karma configuration\n// Install required modules by running \"npm install\"\n\nmodule.exports = function(config) {\n  config.set({\n    // base path that will be used to resolve all patterns (eg. files, exclude)\n    basePath: '.',\n\n    // frameworks to use\n    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter\n    frameworks: [\n      'jasmine-ajax', 'jasmine',\n      'sprintf-js',\n    ],\n\n    plugins: [\n      'karma-*',  // default\n      frameworkPluginForModule('sprintf-js'),\n    ],\n\n    // list of files / patterns to load in the browser\n    files: [\n      // closure base first\n      'third_party/closure/goog/base.js',\n\n      // deps next\n      'dist/deps.js',\n      'shaka-player.uncompiled.js',\n\n      // requirejs next\n      'node_modules/requirejs/require.js',\n\n      // bootstrapping for the test suite\n      'test/test/boot.js',\n\n      // test utils next\n      'test/test/util/*.js',\n\n      // list of test assets next\n      'demo/assets.js',\n\n      // unit tests last\n      'test/**/*_unit.js',\n\n      // if --quick is not present, we will add integration tests.\n\n      // source files - these are only watched and served\n      {pattern: 'lib/**/*.js', included: false},\n      {pattern: 'third_party/closure/goog/**/*.js', included: false},\n      {pattern: 'test/test/assets/*', included: false},\n      {pattern: 'dist/shaka-player.compiled.js', included: false},\n    ],\n\n    // NOTE: Do not use proxies at all!  They cannot be used with the --hostname\n    // option, which is necessary for some of our lab testing.\n    proxies: {},\n\n    preprocessors: {\n      // Don't compute coverage over lib/debug/ or lib/polyfill/\n      'lib/!(debug|polyfill)/*.js': 'coverage',\n      // Player is not matched by the above, so add it explicitly\n      'lib/player.js': 'coverage',\n    },\n\n    // to avoid DISCONNECTED messages on Safari:\n    browserDisconnectTimeout: 10 * 1000,  // 10s to reconnect\n    browserDisconnectTolerance: 1,  // max of 1 disconnect is OK\n    browserNoActivityTimeout: 5 * 60 * 1000,  // disconnect after 5m silence\n    captureTimeout: 1 * 60 * 1000,  // give up if startup takes 1m\n    // https://support.saucelabs.com/customer/en/portal/articles/2440724\n\n    client: {\n      // don't capture the client's console logs\n      captureConsole: false,\n      // |args| must be an array; pass a key-value map as the sole client\n      // argument.\n      args: [{}],\n    },\n\n    // enable / disable colors in the output (reporters and logs)\n    colors: true,\n\n    // level of logging\n    // possible values: config.LOG_DISABLE || config.LOG_ERROR ||\n    //                  config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG\n    logLevel: config.LOG_WARN,\n\n    // do not execute tests whenever any file changes\n    autoWatch: false,\n\n    // do a single run of the tests on captured browsers and then quit\n    singleRun: true,\n\n    coverageReporter: {\n      includeAllSources: true,\n      reporters: [\n        { type: 'text' },\n      ],\n    },\n\n    specReporter: {\n      suppressSkipped: true,\n    },\n  });\n\n  if (flagPresent('html-coverage-report')) {\n    // Wipe out any old coverage reports to avoid confusion.\n    var rimraf = require('rimraf');\n    rimraf.sync('coverage', {});  // Like rm -rf\n\n    config.set({\n      reporters: [ 'coverage', 'progress' ],\n      coverageReporter: {\n        reporters: [\n          { type: 'html', dir: 'coverage' },\n          { type: 'cobertura', dir: 'coverage', file: 'coverage.xml' },\n        ],\n      },\n    });\n  }\n\n  if (!flagPresent('quick')) {\n    // If --quick is present, we don't serve integration tests.\n    var files = config.files;\n    files.push('test/**/*_integration.js');\n    // We just modified the config in-place.  No need for config.set().\n  }\n\n  var logLevel = getFlagValue('enable-logging');\n  if (logLevel !== null) {\n    if (logLevel === '')\n      logLevel = 3;  // INFO\n\n    config.set({\n      reporters: ['spec'],\n    });\n    // Setting |config.client| using config.set will remove the\n    // |config.client.args| member.\n    config.client.captureConsole = true;\n    setClientArg(config, 'logLevel', logLevel);\n  }\n\n  if (flagPresent('external')) {\n    // Run Player integration tests against external assets.\n    // Skipped by default.\n    setClientArg(config, 'external', true);\n  }\n\n  if (flagPresent('quarantined')) {\n    // Run quarantined tests which do not consistently pass.\n    // Skipped by default.\n    setClientArg(config, 'quarantined', true);\n  }\n\n  if (flagPresent('uncompiled')) {\n    // Run Player integration tests with uncompiled code for debugging.\n    setClientArg(config, 'uncompiled', true);\n  }\n\n  if (flagPresent('random')) {\n    // Run tests in a random order.\n    setClientArg(config, 'random', true);\n\n    // If --seed was specified use that value, else generate a seed so that the\n    // exact order can be reproduced if it catches an issue.\n    var seed = getFlagValue('seed') || new Date().getTime();\n    setClientArg(config, 'seed', seed);\n\n    console.log(\"Using a random test order (--random) with --seed=\" + seed);\n  }\n\n  if (flagPresent('specFilter')) {\n    setClientArg(config, 'specFilter', getFlagValue('specFilter'));\n  }\n};\n\n// Sets the value of an argument passed to the client.\nfunction setClientArg(config, name, value) {\n  config.client.args[0][name] = value;\n}\n\n// Find a custom command-line flag that has a value (e.g. --option=12).\n// Returns:\n// * string value  --option=12\n// * empty string  --option= or --option\n// * null          not present\nfunction getFlagValue(name) {\n  var re = /^--([^=]+)(?:=(.*))?$/;\n  for (var i = 0; i < process.argv.length; i++) {\n    var match = re.exec(process.argv[i]);\n    if (match && match[1] == name) {\n      if (match[2] !== undefined)\n        return match[2];\n      else\n        return '';\n    }\n  }\n\n  return null;\n}\n\n// Find custom command-line flags.\nfunction flagPresent(name) {\n  return getFlagValue(name) !== null;\n}\n\n// Construct framework plugins on-the-fly for arbitrary node modules.\n// A call to this must be placed in the config in the 'plugins' array,\n// and the module name must be added to the config in the 'frameworks' array.\nfunction frameworkPluginForModule(name) {\n  // The framework injects files into the client which runs the tests.\n  var framework = function(files) {\n    // Locate the main file for the node module.\n    var path = require('path');\n    var mainFile = path.resolve(require.resolve(name));\n\n    // Add a file entry to the list of files to be served.\n    // This follows the same syntax as above in config.set({files: ...}).\n    files.unshift({\n      pattern: mainFile, included: true, served: true, watched: false\n    });\n  };\n\n  // The framework factory function takes one argument, which is the list of\n  // files from the karma config.\n  framework.$inject = ['config.files'];\n\n  // This is the plugin interface to register a new framework.  Adding this to\n  // the list of plugins makes the named module available as a framework.  That\n  // framework then injects the module into the client.\n  var obj = {};\n  obj['framework:' + name] = ['factory', framework];\n  return obj;\n}\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/shaka-player.uncompiled.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Require all exported classes an app might use.\n * @suppress {extraRequire}\n */\n\ngoog.require('shaka.Player');\ngoog.require('shaka.abr.SimpleAbrManager');\ngoog.require('shaka.cast.CastProxy');\ngoog.require('shaka.cast.CastReceiver');\ngoog.require('shaka.dash.DashParser');\ngoog.require('shaka.log');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.ManifestParser');\ngoog.require('shaka.media.Mp4TtmlParser');\ngoog.require('shaka.media.Mp4VttParser');\ngoog.require('shaka.media.PresentationTimeline');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.media.TextEngine');\ngoog.require('shaka.media.TtmlTextParser');\ngoog.require('shaka.media.VttTextParser');\ngoog.require('shaka.net.DataUriPlugin');\ngoog.require('shaka.net.HttpPlugin');\ngoog.require('shaka.offline.OfflineManifestParser');\ngoog.require('shaka.offline.OfflineScheme');\ngoog.require('shaka.offline.Storage');\ngoog.require('shaka.polyfill.Fullscreen');\ngoog.require('shaka.polyfill.IndexedDB');\ngoog.require('shaka.polyfill.MediaKeys');\ngoog.require('shaka.polyfill.MediaSource');\ngoog.require('shaka.polyfill.Promise');\ngoog.require('shaka.polyfill.VTTCue');\ngoog.require('shaka.polyfill.VideoPlaybackQuality');\ngoog.require('shaka.polyfill.installAll');\ngoog.require('shaka.util.Error');\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/demo/configuration_section.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Shaka Player demo, main section.\n *\n * @suppress {visibility} to work around compiler errors until we can\n *   refactor the demo into classes that talk via public method.  TODO\n */\n\n\n/** @suppress {duplicate} */\nvar shakaDemo = shakaDemo || {};\n\n\n/** @private */\nshakaDemo.setupConfiguration_ = function() {\n  document.getElementById('preferredAudioLanguage').addEventListener(\n      'keyup', shakaDemo.onConfigKeyUp_);\n  document.getElementById('preferredTextLanguage').addEventListener(\n      'keyup', shakaDemo.onConfigKeyUp_);\n  document.getElementById('showTrickPlay').addEventListener(\n      'change', shakaDemo.onTrickPlayChange_);\n  document.getElementById('enableAdaptation').addEventListener(\n      'change', shakaDemo.onAdaptationChange_);\n};\n\n\n/**\n * @param {!Event} event\n * @private\n */\nshakaDemo.onConfigKeyUp_ = function(event) {\n  // Update the configuration if the user presses enter.\n  if (event.keyCode != 13) return;\n\n  shakaDemo.player_.configure(/** @type {shakaExtern.PlayerConfiguration} */({\n    preferredAudioLanguage:\n        document.getElementById('preferredAudioLanguage').value,\n    preferredTextLanguage:\n        document.getElementById('preferredTextLanguage').value\n  }));\n};\n\n\n/**\n * @param {!Event} event\n * @private\n */\nshakaDemo.onAdaptationChange_ = function(event) {\n  // Update adaptation config.\n  shakaDemo.player_.configure(/** @type {shakaExtern.PlayerConfiguration} */({\n    abr: { enabled: event.target.checked }\n  }));\n};\n\n\n/**\n * @param {!Event} event\n * @private\n */\nshakaDemo.onTrickPlayChange_ = function(event) {\n  // Show/hide trick play controls.\n  shakaDemo.controls_.showTrickPlay(event.target.checked);\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/demo/controls.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * A container for custom video controls.\n * @constructor\n * @suppress {missingProvide}\n */\nfunction ShakaControls() {\n  /** @private {shaka.cast.CastProxy} */\n  this.castProxy_ = null;\n\n  /** @private {boolean} */\n  this.castAllowed_ = true;\n\n  /** @private {?function(!shaka.util.Error)} */\n  this.onError_ = null;\n\n  /** @private {HTMLMediaElement} */\n  this.video_ = null;\n\n  /** @private {shaka.Player} */\n  this.player_ = null;\n\n  /** @private {Element} */\n  this.videoContainer_ = document.getElementById('videoContainer');\n\n  /** @private {Element} */\n  this.controls_ = document.getElementById('controls');\n\n  /** @private {Element} */\n  this.playPauseButton_ = document.getElementById('playPauseButton');\n\n  /** @private {Element} */\n  this.seekBar_ = document.getElementById('seekBar');\n\n  /** @private {Element} */\n  this.muteButton_ = document.getElementById('muteButton');\n\n  /** @private {Element} */\n  this.volumeBar_ = document.getElementById('volumeBar');\n\n  /** @private {Element} */\n  this.captionButton_ = document.getElementById('captionButton');\n\n  /** @private {Element} */\n  this.fullscreenButton_ = document.getElementById('fullscreenButton');\n\n  /** @private {Element} */\n  this.currentTime_ = document.getElementById('currentTime');\n\n  /** @private {Element} */\n  this.rewindButton_ = document.getElementById('rewindButton');\n\n  /** @private {Element} */\n  this.fastForwardButton_ = document.getElementById('fastForwardButton');\n\n  /** @private {Element} */\n  this.castButton_ = document.getElementById('castButton');\n\n  /** @private {Element} */\n  this.castReceiverName_ = document.getElementById('castReceiverName');\n\n  /** @private {Element} */\n  this.bufferingSpinner_ = document.getElementById('bufferingSpinner');\n\n  /** @private {Element} */\n  this.giantPlayButtonContainer_ =\n      document.getElementById('giantPlayButtonContainer');\n\n  /** @private {boolean} */\n  this.isSeeking_ = false;\n\n  /** @private {number} */\n  this.trickPlayRate_ = 1;\n\n  /** @private {?number} */\n  this.seekTimeoutId_ = null;\n\n  /** @private {?number} */\n  this.mouseStillTimeoutId_ = null;\n\n  /** @private {?number} */\n  this.lastTouchEventTime_ = null;\n}\n\n\n/**\n * Initializes the player controls.\n * @param {shaka.cast.CastProxy} castProxy\n * @param {function(!shaka.util.Error)} onError\n * @param {function(boolean)} notifyCastStatus\n */\nShakaControls.prototype.init = function(castProxy, onError, notifyCastStatus) {\n  this.castProxy_ = castProxy;\n  this.onError_ = onError;\n  this.notifyCastStatus_ = notifyCastStatus;\n  this.initMinimal(castProxy.getVideo(), castProxy.getPlayer());\n\n  // IE11 doesn't treat the 'input' event correctly.\n  // https://connect.microsoft.com/IE/Feedback/Details/856998\n  // If you know a better way than a userAgent check to handle this, please\n  // send a patch.\n  var sliderInputEvent = 'input';\n  // This matches IE11, but not Edge.  Edge does not have this problem.\n  if (navigator.userAgent.indexOf('Trident/') >= 0) {\n    sliderInputEvent = 'change';\n  }\n\n  this.playPauseButton_.addEventListener(\n      'click', this.onPlayPauseClick_.bind(this));\n  this.video_.addEventListener(\n      'play', this.onPlayStateChange_.bind(this));\n  this.video_.addEventListener(\n      'pause', this.onPlayStateChange_.bind(this));\n\n  this.seekBar_.addEventListener(\n      'mousedown', this.onSeekStart_.bind(this));\n  this.seekBar_.addEventListener(\n      'touchstart', this.onSeekStart_.bind(this));\n  this.seekBar_.addEventListener(\n      sliderInputEvent, this.onSeekInput_.bind(this));\n  this.seekBar_.addEventListener(\n      'touchend', this.onSeekEnd_.bind(this));\n  this.seekBar_.addEventListener(\n      'mouseup', this.onSeekEnd_.bind(this));\n\n  this.muteButton_.addEventListener(\n      'click', this.onMuteClick_.bind(this));\n\n  this.volumeBar_.addEventListener(\n      sliderInputEvent, this.onVolumeInput_.bind(this));\n  this.video_.addEventListener(\n      'volumechange', this.onVolumeStateChange_.bind(this));\n  // initialize volume display with a fake event\n  this.onVolumeStateChange_();\n\n  this.captionButton_.addEventListener(\n      'click', this.onCaptionClick_.bind(this));\n  this.player_.addEventListener(\n      'texttrackvisibility', this.onCaptionStateChange_.bind(this));\n  this.player_.addEventListener(\n      'trackschanged', this.onTracksChange_.bind(this));\n  // initialize caption state with a fake event\n  this.onCaptionStateChange_();\n\n  this.fullscreenButton_.addEventListener(\n      'click', this.onFullscreenClick_.bind(this));\n\n  this.currentTime_.addEventListener(\n      'click', this.onCurrentTimeClick_.bind(this));\n\n  this.rewindButton_.addEventListener(\n      'click', this.onRewindClick_.bind(this));\n  this.fastForwardButton_.addEventListener(\n      'click', this.onFastForwardClick_.bind(this));\n\n  this.castButton_.addEventListener(\n      'click', this.onCastClick_.bind(this));\n\n  this.videoContainer_.addEventListener(\n      'touchstart', this.onContainerTouch_.bind(this));\n  this.videoContainer_.addEventListener(\n      'click', this.onPlayPauseClick_.bind(this));\n\n  // Clicks in the controls should not propagate up to the video container.\n  this.controls_.addEventListener(\n      'click', function(event) { event.stopPropagation(); });\n\n  this.videoContainer_.addEventListener(\n      'mousemove', this.onMouseMove_.bind(this));\n  this.videoContainer_.addEventListener(\n      'touchmove', this.onMouseMove_.bind(this));\n  this.videoContainer_.addEventListener(\n      'touchend', this.onMouseMove_.bind(this));\n  this.videoContainer_.addEventListener(\n      'mouseout', this.onMouseOut_.bind(this));\n\n  this.castProxy_.addEventListener(\n      'caststatuschanged', this.onCastStatusChange_.bind(this));\n};\n\n\n/**\n * Initializes minimal player controls.  Used on both sender (indirectly) and\n * receiver (directly).\n * @param {HTMLMediaElement} video\n * @param {shaka.Player} player\n */\nShakaControls.prototype.initMinimal = function(video, player) {\n  this.video_ = video;\n  this.player_ = player;\n  this.player_.addEventListener(\n      'buffering', this.onBufferingStateChange_.bind(this));\n  window.setInterval(this.updateTimeAndSeekRange_.bind(this), 125);\n};\n\n\n/**\n * This allows the application to inhibit casting.\n *\n * @param {boolean} allow\n */\nShakaControls.prototype.allowCast = function(allow) {\n  this.castAllowed_ = allow;\n  this.onCastStatusChange_(null);\n};\n\n\n/**\n * Used by the application to notify the controls that a load operation is\n * complete.  This allows the controls to recalculate play/paused state, which\n * is important for platforms like Android where autoplay is disabled.\n */\nShakaControls.prototype.loadComplete = function() {\n  // If we are on Android or if autoplay is false, video.paused should be true.\n  // Otherwise, video.paused is false and the content is autoplaying.\n  this.onPlayStateChange_();\n};\n\n\n/**\n * Hiding the cursor when the mouse stops moving seems to be the only decent UX\n * in fullscreen mode.  Since we can't use pure CSS for that, we use events both\n * in and out of fullscreen mode.\n * @param {!Event} event\n * @private\n */\nShakaControls.prototype.onMouseMove_ = function(event) {\n  if (event.type == 'touchstart' || event.type == 'touchmove' ||\n      event.type == 'touchend') {\n    this.lastTouchEventTime_ = Date.now();\n  } else if (this.lastTouchEventTime_ + 1000 < Date.now()) {\n    // It has been a while since the last touch event, this is probably a real\n    // mouse moving, so treat it like a mouse.\n    this.lastTouchEventTime_ = null;\n  }\n\n  // Use the cursor specified in the CSS file.\n  this.videoContainer_.style.cursor = '';\n  // Show the controls.\n  this.controls_.style.opacity = 1;\n  this.updateTimeAndSeekRange_();\n\n  // Hide the cursor when the mouse stops moving.\n  // Only applies while the cursor is over the video container.\n  if (this.mouseStillTimeoutId_) {\n    // Reset the timer.\n    window.clearTimeout(this.mouseStillTimeoutId_);\n  }\n\n  // Only start a timeout on 'touchend' or for 'mousemove' with no touch events.\n  if (event.type == 'touchend' || !this.lastTouchEventTime_) {\n    this.mouseStillTimeoutId_ = window.setTimeout(\n        this.onMouseStill_.bind(this), 3000);\n  }\n};\n\n\n/** @private */\nShakaControls.prototype.onMouseOut_ = function() {\n  // Expire the timer early.\n  if (this.mouseStillTimeoutId_) {\n    window.clearTimeout(this.mouseStillTimeoutId_);\n  }\n  // Run the timeout callback to hide the controls.\n  // If we don't, the opacity style we set in onMouseMove_ will continue to\n  // override the opacity in CSS and force the controls to stay visible.\n  this.onMouseStill_();\n};\n\n\n/** @private */\nShakaControls.prototype.onMouseStill_ = function() {\n  // The mouse has stopped moving.\n  this.mouseStillTimeoutId_ = null;\n  // Hide the cursor.  (NOTE: not supported on IE)\n  this.videoContainer_.style.cursor = 'none';\n  // Revert opacity control to CSS.  Hovering directly over the controls will\n  // keep them showing, even in fullscreen mode. Unless there were touch events,\n  // then override the hover and hide the controls.\n  this.controls_.style.opacity = this.lastTouchEventTime_ ? '0' : '';\n};\n\n\n/**\n * @param {!Event} event\n * @private\n */\nShakaControls.prototype.onContainerTouch_ = function(event) {\n  if (!this.video_.duration) {\n    // Can't play yet.  Ignore.\n    return;\n  }\n\n  if (this.controls_.style.opacity == 1) {\n    this.lastTouchEventTime_ = Date.now();\n    // The controls are showing.\n    // Let this event continue and become a click.\n  } else {\n    // The controls are hidden, so show them.\n    this.onMouseMove_(event);\n    // Stop this event from becoming a click event.\n    event.preventDefault();\n  }\n};\n\n\n/** @private */\nShakaControls.prototype.onPlayPauseClick_ = function() {\n  if (!this.video_.duration) {\n    // Can't play yet.  Ignore.\n    return;\n  }\n\n  this.player_.cancelTrickPlay();\n  this.trickPlayRate_ = 1;\n\n  if (this.video_.paused) {\n    this.video_.play();\n  } else {\n    this.video_.pause();\n  }\n};\n\n\n/** @private */\nShakaControls.prototype.onPlayStateChange_ = function() {\n  // Video is paused during seek, so don't show the play arrow while seeking:\n  if (this.video_.paused && !this.isSeeking_) {\n    this.playPauseButton_.textContent = 'play_arrow';\n    this.giantPlayButtonContainer_.style.display = 'inline';\n  } else {\n    this.playPauseButton_.textContent = 'pause';\n    this.giantPlayButtonContainer_.style.display = 'none';\n  }\n};\n\n\n/** @private */\nShakaControls.prototype.onSeekStart_ = function() {\n  this.isSeeking_ = true;\n  this.video_.pause();\n};\n\n\n/** @private */\nShakaControls.prototype.onSeekInput_ = function() {\n  if (!this.video_.duration) {\n    // Can't seek yet.  Ignore.\n    return;\n  }\n\n  // Update the UI right away.\n  this.updateTimeAndSeekRange_();\n\n  // Collect input events and seek when things have been stable for 125ms.\n  if (this.seekTimeoutId_ != null) {\n    window.clearTimeout(this.seekTimeoutId_);\n  }\n  this.seekTimeoutId_ = window.setTimeout(\n      this.onSeekInputTimeout_.bind(this), 125);\n};\n\n\n/** @private */\nShakaControls.prototype.onSeekInputTimeout_ = function() {\n  this.seekTimeoutId_ = null;\n  this.video_.currentTime = parseFloat(this.seekBar_.value);\n};\n\n\n/** @private */\nShakaControls.prototype.onSeekEnd_ = function() {\n  if (this.seekTimeoutId_ != null) {\n    // They just let go of the seek bar, so end the timer early.\n    window.clearTimeout(this.seekTimeoutId_);\n    this.onSeekInputTimeout_();\n  }\n\n  this.isSeeking_ = false;\n  this.video_.play();\n};\n\n\n/** @private */\nShakaControls.prototype.onMuteClick_ = function() {\n  this.video_.muted = !this.video_.muted;\n};\n\n\n/**\n * Updates the controls to reflect volume changes.\n * @private\n */\nShakaControls.prototype.onVolumeStateChange_ = function() {\n  if (this.video_.muted) {\n    this.muteButton_.textContent = 'volume_off';\n    this.volumeBar_.value = 0;\n  } else {\n    this.muteButton_.textContent = 'volume_up';\n    this.volumeBar_.value = this.video_.volume;\n  }\n\n  var gradient = ['to right'];\n  gradient.push('#ccc ' + (this.volumeBar_.value * 100) + '%');\n  gradient.push('#000 ' + (this.volumeBar_.value * 100) + '%');\n  gradient.push('#000 100%');\n  this.volumeBar_.style.background =\n      'linear-gradient(' + gradient.join(',') + ')';\n};\n\n\n/** @private */\nShakaControls.prototype.onVolumeInput_ = function() {\n  this.video_.volume = parseFloat(this.volumeBar_.value);\n  this.video_.muted = false;\n};\n\n\n/** @private */\nShakaControls.prototype.onCaptionClick_ = function() {\n  this.player_.setTextTrackVisibility(!this.player_.isTextTrackVisible());\n};\n\n\n/** @private */\nShakaControls.prototype.onTracksChange_ = function() {\n  var hasText = this.player_.getTracks().some(function(track) {\n    return track.type == 'text';\n  });\n  this.captionButton_.style.display = hasText ? 'inherit' : 'none';\n};\n\n\n/** @private */\nShakaControls.prototype.onCaptionStateChange_ = function() {\n  if (this.player_.isTextTrackVisible()) {\n    this.captionButton_.style.color = 'white';\n  } else {\n    // Make the button look darker to show that the text track is inactive.\n    this.captionButton_.style.color = 'rgba(255, 255, 255, 0.3)';\n  }\n};\n\n\n/** @private */\nShakaControls.prototype.onFullscreenClick_ = function() {\n  if (document.fullscreenElement) {\n    document.exitFullscreen();\n  } else {\n    this.videoContainer_.requestFullscreen();\n  }\n};\n\n\n/** @private */\nShakaControls.prototype.onCurrentTimeClick_ = function() {\n  // Jump to LIVE if the user clicks on the current time.\n  if (this.player_.isLive()) {\n    this.video_.currentTime = this.seekBar_.max;\n  }\n};\n\n\n/**\n * Cycles trick play rate between -1, -2, -4, and -8.\n * @private\n */\nShakaControls.prototype.onRewindClick_ = function() {\n  if (!this.video_.duration) {\n    return;\n  }\n\n  this.trickPlayRate_ = (this.trickPlayRate_ > 0 || this.trickPlayRate_ < -4) ?\n      -1 : this.trickPlayRate_ * 2;\n  this.player_.trickPlay(this.trickPlayRate_);\n};\n\n\n/**\n * Cycles trick play rate between 1, 2, 4, and 8.\n * @private\n */\nShakaControls.prototype.onFastForwardClick_ = function() {\n  if (!this.video_.duration) {\n    return;\n  }\n\n  this.trickPlayRate_ = (this.trickPlayRate_ < 0 || this.trickPlayRate_ > 4) ?\n      1 : this.trickPlayRate_ * 2;\n  this.player_.trickPlay(this.trickPlayRate_);\n};\n\n\n/** @private */\nShakaControls.prototype.onCastClick_ = function() {\n  if (this.castProxy_.isCasting()) {\n    this.castProxy_.suggestDisconnect();\n  } else {\n    this.castButton_.disabled = true;\n    this.castProxy_.cast().then(function() {\n      this.castButton_.disabled = false;\n      // Success!\n    }.bind(this), function(error) {\n      this.castButton_.disabled = false;\n      if (error.code != shaka.util.Error.Code.CAST_CANCELED_BY_USER) {\n        this.onError_(error);\n      }\n    }.bind(this));\n  }\n};\n\n\n/**\n * @param {Event} event\n * @private\n */\nShakaControls.prototype.onCastStatusChange_ = function(event) {\n  var canCast = this.castProxy_.canCast() && this.castAllowed_;\n  var isCasting = this.castProxy_.isCasting();\n\n  this.notifyCastStatus_(isCasting);\n  this.castButton_.style.display = canCast ? 'inherit' : 'none';\n  this.castButton_.textContent = isCasting ? 'cast_connected' : 'cast';\n  this.castReceiverName_.style.display =\n      isCasting ? 'inherit' : 'none';\n  this.castReceiverName_.textContent =\n      isCasting ? 'Casting to ' + this.castProxy_.receiverName() : '';\n  this.controls_.classList.toggle('casting', this.castProxy_.isCasting());\n};\n\n\n/**\n * @param {Event} event\n * @private\n */\nShakaControls.prototype.onBufferingStateChange_ = function(event) {\n  this.bufferingSpinner_.style.display =\n      event.buffering ? 'inherit' : 'none';\n};\n\n\n/**\n * @param {boolean} show True to show trick play controls, false to show seek\n *   bar.\n */\nShakaControls.prototype.showTrickPlay = function(show) {\n  this.seekBar_.parentElement.style.width = show ? 'auto' : '100%';\n  this.seekBar_.style.display = show ? 'none' : 'flex';\n  this.rewindButton_.style.display = show ? 'inline' : 'none';\n  this.fastForwardButton_.style.display = show ? 'inline' : 'none';\n};\n\n\n/**\n * @return {boolean}\n * @private\n */\nShakaControls.prototype.isOpaque_ = function() {\n  var parentElement = this.controls_.parentElement;\n  // The controls are opaque if either:\n  //   1. We have explicitly made them so in JavaScript\n  //   2. The browser has made them so via css and the hover state\n  return (this.controls_.style.opacity == 1 ||\n          parentElement.querySelector('#controls:hover') == this.controls_);\n};\n\n\n/**\n * Called when the seek range or current time need to be updated.\n * @private\n */\nShakaControls.prototype.updateTimeAndSeekRange_ = function() {\n  // Suppress updates if the controls are hidden.\n  if (!this.isOpaque_()) {\n    return;\n  }\n\n  var displayTime = this.isSeeking_ ?\n      this.seekBar_.value : this.video_.currentTime;\n  var duration = this.video_.duration;\n  var bufferedLength = this.video_.buffered.length;\n  var bufferedStart = bufferedLength ? this.video_.buffered.start(0) : 0;\n  var bufferedEnd = bufferedLength ? this.video_.buffered.end(0) : 0;\n  var seekRange = this.player_.seekRange();\n\n  this.seekBar_.min = seekRange.start;\n  this.seekBar_.max = seekRange.end;\n\n  if (this.player_.isLive()) {\n    // The amount of time we are behind the live edge.\n    var behindLive = Math.floor(seekRange.end - displayTime);\n    displayTime = Math.max(0, behindLive);\n    var showHour = (seekRange.end - seekRange.start) >= 3600;\n\n    // Consider \"LIVE\" when less than 1 second behind the live-edge.  Always\n    // show the full time string when seeking, including the leading '-';\n    // otherwise, the time string \"flickers\" near the live-edge.\n    if ((displayTime >= 1) || this.isSeeking_) {\n      this.currentTime_.textContent =\n          '- ' + this.buildTimeString_(displayTime, showHour);\n      this.currentTime_.style.cursor = 'pointer';\n    } else {\n      this.currentTime_.textContent = 'LIVE';\n      this.currentTime_.style.cursor = '';\n    }\n\n    if (!this.isSeeking_) {\n      this.seekBar_.value = seekRange.end - displayTime;\n    }\n  } else {\n    var showHour = duration >= 3600;\n    this.currentTime_.textContent =\n        this.buildTimeString_(displayTime, showHour);\n\n    if (!this.isSeeking_) {\n      this.seekBar_.value = displayTime;\n    }\n\n    this.currentTime_.style.cursor = '';\n  }\n\n  var gradient = ['to right'];\n  if (bufferedLength == 0) {\n    gradient.push('#000 0%');\n  } else {\n    // NOTE: the fallback to zero eliminates NaN.\n    var bufferStartFraction = (bufferedStart / duration) || 0;\n    var bufferEndFraction = (bufferedEnd / duration) || 0;\n    var playheadFraction = (displayTime / duration) || 0;\n\n    if (this.player_.isLive()) {\n      var bufferStart = Math.max(bufferedStart, seekRange.start);\n      var bufferEnd = Math.min(bufferedEnd, seekRange.end);\n      var seekRangeSize = seekRange.end - seekRange.start;\n      var bufferStartDistance = bufferStart - seekRange.start;\n      var bufferEndDistance = bufferEnd - seekRange.start;\n      var playheadDistance = displayTime - seekRange.start;\n      bufferStartFraction = (bufferStartDistance / seekRangeSize) || 0;\n      bufferEndFraction = (bufferEndDistance / seekRangeSize) || 0;\n      playheadFraction = (playheadDistance / seekRangeSize) || 0;\n    }\n\n    gradient.push('#000 ' + (bufferStartFraction * 100) + '%');\n    gradient.push('#ccc ' + (bufferStartFraction * 100) + '%');\n    gradient.push('#ccc ' + (playheadFraction * 100) + '%');\n    gradient.push('#444 ' + (playheadFraction * 100) + '%');\n    gradient.push('#444 ' + (bufferEndFraction * 100) + '%');\n    gradient.push('#000 ' + (bufferEndFraction * 100) + '%');\n  }\n  this.seekBar_.style.background =\n      'linear-gradient(' + gradient.join(',') + ')';\n};\n\n\n/**\n * Builds a time string, e.g., 01:04:23, from |displayTime|.\n *\n * @param {number} displayTime\n * @param {boolean} showHour\n * @return {string}\n * @private\n */\nShakaControls.prototype.buildTimeString_ = function(displayTime, showHour) {\n  var h = Math.floor(displayTime / 3600);\n  var m = Math.floor((displayTime / 60) % 60);\n  var s = Math.floor(displayTime % 60);\n  if (s < 10) s = '0' + s;\n  var text = m + ':' + s;\n  if (showHour) {\n    if (m < 10) text = '0' + text;\n    text = h + ':' + text;\n  }\n  return text;\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/demo/demo_utils.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/** @namespace */\nvar ShakaDemoUtils = {};\n\n\n/**\n * @param {shakaAssets.AssetInfo} asset\n * @param {shaka.Player} player\n */\nShakaDemoUtils.setupAssetMetadata = function(asset, player) {\n  var config = /** @type {shakaExtern.PlayerConfiguration} */(\n      { drm: {}, manifest: { dash: {} } });\n\n  // Add config from this asset.\n  if (asset.licenseServers)\n    config.drm.servers = asset.licenseServers;\n  if (asset.drmCallback)\n    config.manifest.dash.customScheme = asset.drmCallback;\n  if (asset.clearKeys)\n    config.drm.clearKeys = asset.clearKeys;\n  player.configure(config);\n\n  // Configure network filters.\n  var networkingEngine = player.getNetworkingEngine();\n  networkingEngine.clearAllRequestFilters();\n  networkingEngine.clearAllResponseFilters();\n\n  if (asset.licenseRequestHeaders) {\n    var filter = ShakaDemoUtils.addLicenseRequestHeaders_.bind(\n        null, asset.licenseRequestHeaders);\n    networkingEngine.registerRequestFilter(filter);\n  }\n\n  if (asset.requestFilter)\n    networkingEngine.registerRequestFilter(asset.requestFilter);\n  if (asset.responseFilter)\n    networkingEngine.registerResponseFilter(asset.responseFilter);\n  if (asset.extraConfig)\n    player.configure(/** @type {shakaExtern.PlayerConfiguration} */(\n        asset.extraConfig));\n};\n\n\n/**\n * @param {!Object.<string, string>} headers\n * @param {shaka.net.NetworkingEngine.RequestType} requestType\n * @param {shakaExtern.Request} request\n * @private\n */\nShakaDemoUtils.addLicenseRequestHeaders_ =\n    function(headers, requestType, request) {\n  if (requestType != shaka.net.NetworkingEngine.RequestType.LICENSE) return;\n\n  // Add these to the existing headers.  Do not clobber them!\n  // For PlayReady, there will already be headers in the request.\n  for (var k in headers) {\n    request.headers[k] = headers[k];\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/demo/info_section.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Shaka Player demo, main section.\n *\n * @suppress {visibility} to work around compiler errors until we can\n *   refactor the demo into classes that talk via public method.  TODO\n */\n\n\n/** @suppress {duplicate} */\nvar shakaDemo = shakaDemo || {};\n\n\n/** @private */\nshakaDemo.setupInfo_ = function() {\n  window.setInterval(shakaDemo.updateDebugInfo_, 125);\n  shakaDemo.player_.addEventListener(\n      'trackschanged', shakaDemo.onTracksChanged_);\n  shakaDemo.player_.addEventListener(\n      'adaptation', shakaDemo.onAdaptation_);\n  document.getElementById('videoTracks').addEventListener(\n      'change', shakaDemo.onTrackSelected_);\n  document.getElementById('audioTracks').addEventListener(\n      'change', shakaDemo.onTrackSelected_);\n  document.getElementById('textTracks').addEventListener(\n      'change', shakaDemo.onTrackSelected_);\n};\n\n\n/**\n * @param {!Event} event\n * @private\n */\nshakaDemo.onTracksChanged_ = function(event) {\n  // Update the track lists.\n  var lists = {\n    video: document.getElementById('videoTracks'),\n    audio: document.getElementById('audioTracks'),\n    text: document.getElementById('textTracks')\n  };\n  var formatters = {\n    video: function(track) {\n      return track.width + 'x' + track.height + ', ' +\n             track.bandwidth + ' bits/s';\n    },\n    audio: function(track) {\n      return 'language: ' + track.language + ', ' +\n             track.bandwidth + ' bits/s';\n    },\n    text: function(track) {\n      return 'language: ' + track.language + ' ' +\n             '(' + track.kind + ')';\n    }\n  };\n\n  // Clear the old track lists.\n  Object.keys(lists).forEach(function(type) {\n    var list = lists[type];\n    while (list.firstChild) {\n      list.removeChild(list.firstChild);\n    }\n  });\n\n  // Populate with the new tracks.\n  var tracks = shakaDemo.player_.getTracks();\n  tracks.sort(function(t1, t2) {\n    // Sort by language, then by bandwidth.\n    if (t1.language) {\n      var ret = t1.language.localeCompare(t2.language);\n      if (ret) return ret;\n    }\n    return t1.bandwidth - t2.bandwidth;\n  });\n  tracks.forEach(function(track) {\n    var list = lists[track.type];\n    if (!list) return;\n    var option = document.createElement('option');\n    option.textContent = formatters[track.type](track);\n    option.track = track;\n    option.value = track.id;\n    option.selected = track.active;\n    list.appendChild(option);\n  });\n};\n\n\n/**\n * @param {!Event} event\n * @private\n */\nshakaDemo.onAdaptation_ = function(event) {\n  var lists = {\n    video: document.getElementById('videoTracks'),\n    audio: document.getElementById('audioTracks'),\n    text: document.getElementById('textTracks')\n  };\n\n  // Find the rows for the active tracks and select them.\n  var tracks = shakaDemo.player_.getTracks();\n  tracks.forEach(function(track) {\n    if (!track.active) return;\n\n    var list = lists[track.type];\n    for (var i = 0; i < list.options.length; ++i) {\n      var option = list.options[i];\n      if (option.value == track.id) {\n        option.selected = true;\n        break;\n      }\n    }\n  });\n};\n\n\n/**\n * @param {!Event} event\n * @private\n */\nshakaDemo.onTrackSelected_ = function(event) {\n  var list = event.target;\n  var option = list.options[list.selectedIndex];\n  var track = option.track;\n  var player = shakaDemo.player_;\n\n  player.selectTrack(track, /* clearBuffer */ true);\n\n  // Adaptation might have been changed by calling selectTrack().\n  // Update the adaptation checkbox.\n  var enableAdaptation = player.getConfiguration().abr.enabled;\n  document.getElementById('enableAdaptation').checked = enableAdaptation;\n};\n\n\n/** @private */\nshakaDemo.updateDebugInfo_ = function() {\n  var video = shakaDemo.video_;\n\n  document.getElementById('videoResDebug').textContent =\n      video.videoWidth + ' x ' + video.videoHeight;\n\n  var behind = 0;\n  var ahead = 0;\n\n  var currentTime = video.currentTime;\n  var buffered = video.buffered;\n  for (var i = 0; i < buffered.length; ++i) {\n    if (buffered.start(i) <= currentTime && buffered.end(i) >= currentTime) {\n      ahead = buffered.end(i) - currentTime;\n      behind = currentTime - buffered.start(i);\n      break;\n    }\n  }\n\n  document.getElementById('bufferedDebug').textContent =\n      '- ' + behind.toFixed(0) + 's / ' + '+ ' + ahead.toFixed(0) + 's';\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/demo/load.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * Loads the library.  Chooses compiled or debug version of the library based\n * on the presence or absence of the URL parameter \"compiled\".\n *\n * This dynamic loading process is not necessary in a production environment,\n * but greatly simplifies the process of switching between compiled and\n * uncompiled mode during development.\n *\n * This is used in the provided demo app, but can also be used to load the\n * uncompiled version of the library into your own application environment.\n */\n(function() {  // anonymous namespace\n  // The sources may be in a different folder from the app.\n  // Compute the base URL for all library sources.\n  var currentScript = document.currentScript ||\n                      document.scripts[document.scripts.length - 1];\n  var loaderSrc = currentScript.src;\n  var baseUrl = loaderSrc.split('/').slice(0, -1).join('/') + '/';\n\n  function loadScript(src) {\n    // This does not seem like it would be the best way to do this, but the\n    // timing is different than creating a new script element and appending\n    // it to the head element.  This way, all script loading happens before\n    // DOMContentLoaded.  This is also compatible with goog.require's loading\n    // mechanism, whereas appending an element to head isn't.\n    document.write('<script src=\"' + baseUrl + src + '\"></script>');\n  }\n\n  var fields = location.search.split('?').slice(1).join('?');\n  fields = fields ? fields.split(';') : [];\n\n  // Very old browsers do not have Array.prototype.indexOf.\n  var compiledMode = false;\n  for (var i = 0; i < fields.length; ++i) {\n    if (fields[i] == 'compiled') {\n      compiledMode = true;\n      break;\n    }\n  }\n\n  if (compiledMode) {\n    // This contains the entire library, compiled in debug mode.\n    loadScript('../dist/shaka-player.compiled.debug.js');\n  } else {\n    // In non-compiled mode, we load the closure library and the generated deps\n    // file to bootstrap the system.  goog.require will load the rest.\n    loadScript('../third_party/closure/goog/base.js');\n    loadScript('../dist/deps.js');\n    // This file contains goog.require calls for all exported classes.\n    loadScript('../shaka-player.uncompiled.js');\n  }\n})();  // anonymous namespace\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/demo/main.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Shaka Player demo, main section.\n *\n * @suppress {visibility} to work around compiler errors until we can\n *   refactor the demo into classes that talk via public method.  TODO\n */\n\n\n/** @suppress {duplicate} */\nvar shakaDemo = shakaDemo || {};\n\n\n/** @private {shaka.cast.CastProxy} */\nshakaDemo.castProxy_ = null;\n\n\n/** @private {HTMLMediaElement} */\nshakaDemo.video_ = null;\n\n\n/** @private {shaka.Player} */\nshakaDemo.player_ = null;\n\n\n/** @private {shaka.Player} */\nshakaDemo.localPlayer_ = null;\n\n\n/** @private {shakaExtern.SupportType} */\nshakaDemo.support_;\n\n\n/** @private {ShakaControls} */\nshakaDemo.controls_ = null;\n\n\n/**\n * The registered ID of the v2 Chromecast receiver demo.\n * @const {string}\n * @private\n */\nshakaDemo.CC_APP_ID_ = '4E839F3A';\n\n\n/**\n * Initialize the application.\n */\nshakaDemo.init = function() {\n  document.getElementById('errorDisplayCloseButton').addEventListener(\n      'click', shakaDemo.closeError);\n\n  // Display the version number.\n  document.getElementById('version').textContent = shaka.Player.version;\n\n  // Fill in the language preferences based on browser config, if available.\n  var language = navigator.language || 'en-us';\n  document.getElementById('preferredAudioLanguage').value = language;\n  document.getElementById('preferredTextLanguage').value = language;\n\n  // Read URL parameters.\n  var fields = location.search.split('?').slice(1).join('?');\n  fields = fields ? fields.split(';') : [];\n  var params = {};\n  for (var i = 0; i < fields.length; ++i) {\n    var kv = fields[i].split('=');\n    params[kv[0]] = kv.slice(1).join('=');\n  }\n\n  if ('lang' in params) {\n    document.getElementById('preferredAudioLanguage').value = params['lang'];\n    document.getElementById('preferredTextLanguage').value = params['lang'];\n  }\n  if ('asset' in params) {\n    document.getElementById('manifestInput').value = params['asset'];\n  }\n  if ('license' in params) {\n    document.getElementById('licenseServerInput').value = params['license'];\n  }\n  if ('logtoscreen' in params) {\n    document.getElementById('logToScreen').checked = true;\n  }\n  if ('noinput' in params) {\n    // Both the content container and body need different styles in this mode.\n    document.getElementById('container').className = 'noinput';\n    document.body.className = 'noinput';\n  }\n\n  if ('vv' in params && shaka.log) {\n    shaka.log.setLevel(shaka.log.Level.V2);\n  } else if ('v' in params && shaka.log) {\n    shaka.log.setLevel(shaka.log.Level.V1);\n  } else if ('debug' in params && shaka.log) {\n    shaka.log.setLevel(shaka.log.Level.DEBUG);\n  }\n\n  shakaDemo.setupLogging_();\n\n  shaka.polyfill.installAll();\n\n  if (!shaka.Player.isBrowserSupported()) {\n    var errorDisplayLink = document.getElementById('errorDisplayLink');\n    var error = 'Your browser is not supported!';\n\n    // IE8 and other very old browsers don't have textContent.\n    if (errorDisplayLink.textContent === undefined) {\n      errorDisplayLink.innerText = error;\n    } else {\n      errorDisplayLink.textContent = error;\n    }\n\n    // Disable the load button.\n    var loadButton = document.getElementById('loadButton');\n    loadButton.disabled = true;\n\n    // Hide the error message's close button.\n    var errorDisplayCloseButton =\n        document.getElementById('errorDisplayCloseButton');\n    errorDisplayCloseButton.style.display = 'none';\n\n    // Make sure the error is seen.\n    errorDisplayLink.style.fontSize = '250%';\n\n    // TODO: Link to docs about browser support.  For now, disable link.\n    errorDisplayLink.href = '#';\n    // Disable for newer browsers:\n    errorDisplayLink.style.pointerEvents = 'none';\n    // Disable for older browsers:\n    errorDisplayLink.style.textDecoration = 'none';\n    errorDisplayLink.style.cursor = 'default';\n    errorDisplayLink.onclick = function() { return false; };\n\n    var errorDisplay = document.getElementById('errorDisplay');\n    errorDisplay.style.display = 'block';\n  } else {\n    shaka.Player.probeSupport().then(function(support) {\n      shakaDemo.support_ = support;\n\n      var localVideo =\n          /** @type {!HTMLVideoElement} */(document.getElementById('video'));\n      var localPlayer = new shaka.Player(localVideo);\n      shakaDemo.castProxy_ = new shaka.cast.CastProxy(\n          localVideo, localPlayer, shakaDemo.CC_APP_ID_);\n\n      shakaDemo.video_ = shakaDemo.castProxy_.getVideo();\n      shakaDemo.player_ = shakaDemo.castProxy_.getPlayer();\n      shakaDemo.player_.addEventListener('error', shakaDemo.onErrorEvent_);\n      shakaDemo.localPlayer_ = localPlayer;\n\n      shakaDemo.setupAssets_();\n      shakaDemo.setupOffline_();\n      shakaDemo.setupConfiguration_();\n      shakaDemo.setupInfo_();\n\n      shakaDemo.controls_ = new ShakaControls();\n      shakaDemo.controls_.init(shakaDemo.castProxy_, shakaDemo.onError_,\n                               shakaDemo.onCastStatusChange_);\n\n      // If a custom asset was given in the URL, select it now.\n      if ('asset' in params) {\n        var assetList = document.getElementById('assetList');\n        var customAsset = document.getElementById('customAsset');\n        assetList.selectedIndex = assetList.options.length - 1;\n        customAsset.style.display = 'block';\n      }\n\n      if ('play' in params) {\n        shakaDemo.load();\n      }\n    });\n  }\n};\n\n\n/**\n * @param {!Event} event\n * @private\n */\nshakaDemo.onErrorEvent_ = function(event) {\n  var error = event.detail;\n  shakaDemo.onError_(error);\n};\n\n\n/**\n * @param {!shaka.util.Error} error\n * @private\n */\nshakaDemo.onError_ = function(error) {\n  console.error('Player error', error);\n  var message = error.message || ('Error code ' + error.code);\n  var link = document.getElementById('errorDisplayLink');\n  link.href = '../docs/api/shaka.util.Error.html#value:' + error.code;\n  link.textContent = message;\n  // Make the link clickable only if we have an error code.\n  link.style.pointerEvents = error.code ? 'auto' : 'none';\n  document.getElementById('errorDisplay').style.display = 'block';\n};\n\n\n/**\n * Closes the error bar.\n */\nshakaDemo.closeError = function() {\n  document.getElementById('errorDisplay').style.display = 'none';\n  var link = document.getElementById('errorDisplayLink');\n  link.href = '';\n  link.textContent = '';\n};\n\n\n// IE 9 fires DOMContentLoaded, and enters the \"interactive\"\n// readyState, before document.body has been initialized, so wait\n// for window.load.\nif (document.readyState == 'loading' ||\n    document.readyState == 'interactive') {\n  if (window.attachEvent) {\n    // IE8\n    window.attachEvent('onload', shakaDemo.init);\n  } else {\n    window.addEventListener('load', shakaDemo.init);\n  }\n} else {\n  shakaDemo.init();\n}\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/demo/offline_section.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Shaka Player demo, main section.\n *\n * @suppress {visibility} to work around compiler errors until we can\n *   refactor the demo into classes that talk via public method.  TODO\n */\n\n\n/** @suppress {duplicate} */\nvar shakaDemo = shakaDemo || {};\n\n\n/** @private {?HTMLOptGroupElement} */\nshakaDemo.offlineOptGroup_ = null;\n\n\n/** @private {boolean} */\nshakaDemo.offlineOperationInProgress_ = false;\n\n\n/**\n * @param {boolean} canHide True to hide the progress value if there isn't an\n *   operation going.\n * @private\n */\nshakaDemo.updateButtons_ = function(canHide) {\n  var assetList = document.getElementById('assetList');\n  var inProgress = shakaDemo.offlineOperationInProgress_;\n\n  document.getElementById('progressDiv').style.display =\n      canHide && !inProgress ? 'none' : 'block';\n\n  var option = assetList.options[assetList.selectedIndex];\n  var storedContent = option.storedContent;\n  // True if there is no DRM or if the browser supports persistent licenses for\n  // any given DRM system.\n  var supportsDrm = !option.asset || !option.asset.drm ||\n      !option.asset.drm.length || option.asset.drm.some(function(drm) {\n        return shakaDemo.support_.drm[drm] &&\n            shakaDemo.support_.drm[drm].persistentState;\n      });\n\n  // Only show when the custom asset option is selected.\n  document.getElementById('offlineNameDiv').style.display =\n      option.asset ? 'none' : 'block';\n\n  var button = document.getElementById('storeDelete');\n  button.disabled = (inProgress || !supportsDrm || option.isStored);\n  button.innerText = storedContent ? 'Delete' : 'Store';\n  if (inProgress)\n    button.title = 'There is already an operation in progress';\n  else if (!supportsDrm)\n    button.title = 'This browser does not support persistent licenses';\n  else if (button.disabled)\n    button.title = 'Selected asset is already stored offline';\n  else\n    button.title = '';\n};\n\n\n/** @private */\nshakaDemo.setupOffline_ = function() {\n  document.getElementById('storeDelete')\n      .addEventListener('click', shakaDemo.storeDeleteAsset_);\n  document.getElementById('assetList')\n      .addEventListener('change', shakaDemo.updateButtons_.bind(null, true));\n  shakaDemo.updateButtons_(true);\n};\n\n\n/**\n * @return {!Promise}\n * @private\n */\nshakaDemo.setupOfflineAssets_ = function() {\n  var Storage = shaka.offline.Storage;\n  if (!Storage.support()) {\n    var section = document.getElementById('offlineSection');\n    section.style.display = 'none';\n    return Promise.resolve();\n  }\n\n  /** @type {!HTMLOptGroupElement} */\n  var group;\n  var assetList = document.getElementById('assetList');\n  if (!shakaDemo.offlineOptGroup_) {\n    group =\n        /** @type {!HTMLOptGroupElement} */ (\n            document.createElement('optgroup'));\n    shakaDemo.offlineOptGroup_ = group;\n    group.label = 'Offline';\n    assetList.appendChild(group);\n  } else {\n    group = shakaDemo.offlineOptGroup_;\n  }\n\n  var db = new Storage(shakaDemo.localPlayer_);\n  return db.list().then(function(storedContents) {\n    storedContents.forEach(function(storedContent) {\n      for (var i = 0; i < assetList.options.length; i++) {\n        var option = assetList.options[i];\n        if (option.asset &&\n            option.asset.manifestUri == storedContent.originalManifestUri) {\n          option.isStored = true;\n          break;\n        }\n      }\n      var asset = {manifestUri: storedContent.offlineUri};\n\n      var option = document.createElement('option');\n      option.textContent =\n          storedContent.appMetadata ? storedContent.appMetadata.name : '';\n      option.asset = asset;\n      option.storedContent = storedContent;\n      group.appendChild(option);\n    });\n\n    shakaDemo.updateButtons_(true);\n    return db.destroy();\n  });\n};\n\n\n/** @private */\nshakaDemo.storeDeleteAsset_ = function() {\n  shakaDemo.closeError();\n  shakaDemo.offlineOperationInProgress_ = true;\n  shakaDemo.updateButtons_(false);\n\n  var assetList = document.getElementById('assetList');\n  var progress = document.getElementById('progress');\n  var option = assetList.options[assetList.selectedIndex];\n\n  progress.textContent = '0';\n\n  var storage = new shaka.offline.Storage(shakaDemo.player_);\n  storage.configure(/** @type {shakaExtern.OfflineConfiguration} */ ({\n    progressCallback: function(data, percent) {\n      progress.textContent = (percent * 100).toFixed(2);\n    }\n  }));\n\n  var p;\n  if (option.storedContent) {\n    var originalManifestUri = option.storedContent.originalManifestUri;\n    p = storage.remove(option.storedContent).then(function() {\n      for (var i = 0; i < assetList.options.length; i++) {\n        var option = assetList.options[i];\n        if (option.asset && option.asset.manifestUri == originalManifestUri)\n          option.isStored = false;\n      }\n      shakaDemo.refreshAssetList_();\n    });\n  } else {\n    var asset = shakaDemo.preparePlayer_(option.asset);\n    var nameField = document.getElementById('offlineName').value;\n    var assetName = asset.name ? asset.name + ' (offline)' : null;\n    var metadata = {name: assetName || nameField || asset.manifestUri};\n    p = storage.store(asset.manifestUri, metadata).then(function() {\n      shakaDemo.refreshAssetList_();\n      if (option.asset)\n        option.isStored = true;\n    });\n  }\n\n  p.catch(function(reason) {\n    var error = /** @type {!shaka.util.Error} */(reason);\n    shakaDemo.onError_(error);\n  }).then(function() {\n    shakaDemo.offlineOperationInProgress_ = false;\n    shakaDemo.updateButtons_(false);\n    return storage.destroy();\n  });\n};\n\n\n/** @private */\nshakaDemo.refreshAssetList_ = function() {\n  // Remove all child elements.\n  var group = shakaDemo.offlineOptGroup_;\n  while (group.firstChild) {\n    group.removeChild(group.firstChild);\n  }\n\n  shakaDemo.setupOfflineAssets_();\n};\n\n\n/**\n * @param {boolean} connected\n * @private\n */\nshakaDemo.onCastStatusChange_ = function(connected) {\n  if (!shakaDemo.offlineOptGroup_) {\n    // No offline support.\n    return;\n  }\n\n  // When we are casting, offline assets become unavailable.\n  shakaDemo.offlineOptGroup_.disabled = connected;\n\n  if (connected) {\n    var assetList = document.getElementById('assetList');\n    var option = assetList.options[assetList.selectedIndex];\n    if (option.storedContent) {\n      // This is an offline asset.  Select something else.\n      assetList.selectedIndex = 0;\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/demo/receiver_app.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * A Chromecast receiver demo app.\n * @constructor\n * @suppress {missingProvide}\n */\nfunction ShakaReceiver() {\n  /** @private {HTMLMediaElement} */\n  this.video_ = null;\n\n  /** @private {shaka.Player} */\n  this.player_ = null;\n\n  /** @private {shaka.cast.CastReceiver} */\n  this.receiver_ = null;\n\n  /** @private {Element} */\n  this.pauseIcon_ = null;\n\n  /** @private {Element} */\n  this.controlsElement_ = null;\n\n  /** @private {ShakaControls} */\n  this.controlsUi_ = null;\n\n  /** @private {?number} */\n  this.controlsTimerId_ = null;\n\n  /** @private {Element} */\n  this.idle_ = null;\n\n  /** @private {?number} */\n  this.idleTimerId_ = null;\n\n  /**\n   * In seconds.\n   * @const\n   * @private {number}\n   */\n  this.idleTimeout_ = 300;\n}\n\n\n/**\n * Initialize the application.\n */\nShakaReceiver.prototype.init = function() {\n  shaka.polyfill.installAll();\n\n  this.video_ =\n      /** @type {!HTMLMediaElement} */(document.getElementById('video'));\n  this.player_ = new shaka.Player(this.video_);\n\n  this.controlsUi_ = new ShakaControls();\n  this.controlsUi_.initMinimal(this.video_, this.player_);\n\n  this.controlsElement_ = document.getElementById('controls');\n  this.pauseIcon_ = document.getElementById('pauseIcon');\n  this.idle_ = document.getElementById('idle');\n\n  this.video_.addEventListener(\n      'play', this.onPlayStateChange_.bind(this));\n  this.video_.addEventListener(\n      'pause', this.onPlayStateChange_.bind(this));\n  this.video_.addEventListener(\n      'seeking', this.onPlayStateChange_.bind(this));\n  this.video_.addEventListener(\n      'emptied', this.onPlayStateChange_.bind(this));\n\n  this.receiver_ = new shaka.cast.CastReceiver(\n      this.video_, this.player_, this.appDataCallback_.bind(this));\n  this.receiver_.addEventListener(\n      'caststatuschanged', this.checkIdle_.bind(this));\n\n  this.startIdleTimer_();\n};\n\n\n/**\n * @param {Object} appData\n * @private\n */\nShakaReceiver.prototype.appDataCallback_ = function(appData) {\n  // appData is null if we start the app without any media loaded.\n  if (!appData) return;\n\n  var asset = /** @type {shakaAssets.AssetInfo} */(appData['asset']);\n  // Patch in non-transferable callbacks for YT DRM:\n  if (appData['isYtDrm']) {\n    asset.drmCallback = shakaAssets.YouTubeCallback;\n    asset.requestFilter = shakaAssets.YouTubeRequestFilter;\n    asset.responseFilter = shakaAssets.YouTubeResponseFilter;\n  }\n  ShakaDemoUtils.setupAssetMetadata(asset, this.player_);\n};\n\n\n/** @private */\nShakaReceiver.prototype.checkIdle_ = function() {\n  console.debug('status changed',\n                'idle=', this.receiver_.isIdle());\n\n  // If the app is idle, show the idle card and set a timer to close the app.\n  // Otherwise, hide the idle card and cancel the timer.\n  if (this.receiver_.isIdle()) {\n    this.idle_.style.display = 'block';\n    this.startIdleTimer_();\n  } else {\n    this.idle_.style.display = 'none';\n    this.cancelIdleTimer_();\n  }\n};\n\n\n/** @private */\nShakaReceiver.prototype.startIdleTimer_ = function() {\n  this.cancelIdleTimer_();\n\n  this.idleTimerId_ = window.setTimeout(\n      window.close.bind(window), this.idleTimeout_ * 1000.0);\n};\n\n\n/** @private */\nShakaReceiver.prototype.cancelIdleTimer_ = function() {\n  if (this.idleTimerId_ != null) {\n    window.clearTimeout(this.idleTimerId_);\n    this.idleTimerId_ = null;\n  }\n};\n\n\n/** @private */\nShakaReceiver.prototype.onPlayStateChange_ = function() {\n  if (this.controlsTimerId_ != null) {\n    window.clearTimeout(this.controlsTimerId_);\n  }\n\n  if (this.video_.paused) {\n    this.pauseIcon_.textContent = 'pause';\n  } else {\n    this.pauseIcon_.textContent = 'play_arrow';\n  }\n\n  if (this.video_.paused && this.video_.readyState > 0) {\n    // Show controls.\n    this.controlsElement_.style.opacity = 1;\n  } else {\n    // Show controls for 3 seconds.\n    this.controlsElement_.style.opacity = 1;\n    this.controlsTimerId_ = window.setTimeout(function() {\n      this.controlsElement_.style.opacity = 0;\n    }.bind(this), 3000);\n  }\n};\n\n\n/**\n * Initialize the receiver app by instantiating ShakaReceiver.\n */\nfunction receiverAppInit() {\n  window.receiver = new ShakaReceiver();\n  window.receiver.init();\n}\n\n\nif (document.readyState == 'loading' ||\n    document.readyState == 'interactive') {\n  window.addEventListener('load', receiverAppInit);\n} else {\n  receiverAppInit();\n}\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/externs/chromecast.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Google Cast API externs.\n * Based on the {@link https://goo.gl/psEjEh Google Cast API}.\n * @externs\n */\n\n\n/** @type {function(boolean)} */\nvar __onGCastApiAvailable;\n\n\n/** @const */\nvar cast = {};\n\n\n/** @const */\ncast.receiver = {};\n\n\n/** @const */\ncast.receiver.system = {};\n\n\n\n/**\n * @constructor\n * @struct\n */\ncast.receiver.system.SystemVolumeData = function() {};\n\n\n/** @type {number} */\ncast.receiver.system.SystemVolumeData.prototype.level;\n\n\n/** @type {boolean} */\ncast.receiver.system.SystemVolumeData.prototype.muted;\n\n\n\n/**\n * @constructor\n * @struct\n */\ncast.receiver.CastMessageBus = function() {};\n\n\n/** @param {*} message */\ncast.receiver.CastMessageBus.prototype.broadcast = function(message) {};\n\n\n/**\n * @param {string} senderId\n * @return {!cast.receiver.CastChannel}\n */\ncast.receiver.CastMessageBus.prototype.getCastChannel = function(senderId) {};\n\n\n/** @type {Function} */\ncast.receiver.CastMessageBus.prototype.onMessage;\n\n\n\n/**\n * @constructor\n * @struct\n */\ncast.receiver.CastMessageBus.Event = function() {};\n\n\n/** @type {?} */\ncast.receiver.CastMessageBus.Event.prototype.data;\n\n\n/** @type {string} */\ncast.receiver.CastMessageBus.Event.prototype.senderId;\n\n\n\n/**\n * @constructor\n * @struct\n */\ncast.receiver.CastChannel = function() {};\n\n\n/** @param {*} message */\ncast.receiver.CastChannel.prototype.send = function(message) {};\n\n\n\n/**\n * @constructor\n * @struct\n */\ncast.receiver.CastReceiverManager = function() {};\n\n\n/** @return {cast.receiver.CastReceiverManager} */\ncast.receiver.CastReceiverManager.getInstance = function() {};\n\n\n/**\n * @param {string} namespace\n * @param {string=} opt_messageType\n * @return {cast.receiver.CastMessageBus}\n */\ncast.receiver.CastReceiverManager.prototype.getCastMessageBus = function(\n    namespace, opt_messageType) {};\n\n\n/** @return {Array.<string>} */\ncast.receiver.CastReceiverManager.prototype.getSenders = function() {};\n\n\ncast.receiver.CastReceiverManager.prototype.start = function() {};\n\n\ncast.receiver.CastReceiverManager.prototype.stop = function() {};\n\n\n/** @return {?cast.receiver.system.SystemVolumeData} */\ncast.receiver.CastReceiverManager.prototype.getSystemVolume = function() {};\n\n\n/** @param {number} level */\ncast.receiver.CastReceiverManager.prototype.setSystemVolumeLevel =\n    function(level) {};\n\n\n/** @param {number} muted */\ncast.receiver.CastReceiverManager.prototype.setSystemVolumeMuted =\n    function(muted) {};\n\n\n/** @return {boolean} */\ncast.receiver.CastReceiverManager.prototype.isSystemReady = function() {};\n\n\n/** @type {Function} */\ncast.receiver.CastReceiverManager.prototype.onSenderConnected;\n\n\n/** @type {Function} */\ncast.receiver.CastReceiverManager.prototype.onSenderDisconnected;\n\n\n/** @type {Function} */\ncast.receiver.CastReceiverManager.prototype.onSystemVolumeChanged;\n\n\n/** @const */\ncast.__platform__;\n\n\n/**\n * @param {string} type\n * @return {boolean}\n */\ncast.__platform__.canDisplayType = function(type) {};\n\n\n/** @const */\nchrome.cast = {};\n\n\n/** @type {boolean} */\nchrome.cast.isAvailable;\n\n\n/**\n * @param {chrome.cast.ApiConfig} apiConfig\n * @param {Function} successCallback\n * @param {Function} errorCallback\n */\nchrome.cast.initialize = function(apiConfig, successCallback, errorCallback) {};\n\n\n/**\n * @param {Function} successCallback\n * @param {Function} errorCallback\n * @param {chrome.cast.SessionRequest=} opt_sessionRequest\n */\nchrome.cast.requestSession = function(\n    successCallback, errorCallback, opt_sessionRequest) {};\n\n\n\n/**\n * @param {chrome.cast.SessionRequest} sessionRequest\n * @param {Function} sessionListener\n * @param {Function} receiverListener\n * @param {string=} opt_autoJoinPolicy\n * @param {string=} opt_defaultActionPolicy\n * @constructor\n * @struct\n */\nchrome.cast.ApiConfig = function(\n    sessionRequest,\n    sessionListener,\n    receiverListener,\n    opt_autoJoinPolicy,\n    opt_defaultActionPolicy) {};\n\n\n\n/**\n * @param {string} code\n * @param {string=} opt_description\n * @param {Object=} opt_details\n * @constructor\n * @struct\n */\nchrome.cast.Error = function(code, opt_description, opt_details) {};\n\n\n/** @type {string} */\nchrome.cast.Error.prototype.code;\n\n\n/** @type {?string} */\nchrome.cast.Error.prototype.description;\n\n\n/** @type {Object} */\nchrome.cast.Error.prototype.details;\n\n\n\n/**\n * @constructor\n * @struct\n */\nchrome.cast.Receiver = function() {};\n\n\n/** @const {string} */\nchrome.cast.Receiver.prototype.friendlyName;\n\n\n\n/**\n * @constructor\n * @struct\n */\nchrome.cast.Session = function() {};\n\n\n/** @type {string} */\nchrome.cast.Session.prototype.sessionId;\n\n\n/** @type {string} */\nchrome.cast.Session.prototype.status;\n\n\n/** @type {chrome.cast.Receiver} */\nchrome.cast.Session.prototype.receiver;\n\n\n/**\n * @param {string} namespace\n * @param {Function} listener\n */\nchrome.cast.Session.prototype.addMessageListener = function(\n    namespace, listener) {};\n\n\n/**\n * @param {Function} listener\n */\nchrome.cast.Session.prototype.addUpdateListener = function(listener) {};\n\n\n/**\n * @param {string} namespace\n * @param {!Object|string} message\n * @param {Function} successCallback\n * @param {Function} errorCallback\n */\nchrome.cast.Session.prototype.sendMessage = function(\n    namespace, message, successCallback, errorCallback) {};\n\n\n/**\n * @param {Function} successCallback\n * @param {Function} errorCallback\n */\nchrome.cast.Session.prototype.stop = function(\n    successCallback, errorCallback) {};\n\n\n\n/**\n * @param {string} appId\n * @constructor\n * @struct\n */\nchrome.cast.SessionRequest = function(appId) {};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/externs/fullscreen.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Externs for prefixed fullscreen methods.\n * @externs\n */\n\n\nDocument.prototype.msExitFullscreen = function() {};\n\n\nDocument.prototype.webkitExitFullscreen = function() {};\n\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/externs/jwk_set.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Externs for JWK set.\n * @externs\n */\n\n\n\n/**\n * A JSON Web Key set.\n *\n * @constructor\n * @struct\n */\nfunction JWKSet() {\n  /** @type {Array.<JWK>} */\n  this.keys = [];\n}\n\n\n\n/**\n * A JSON Web Key.\n *\n * @constructor\n * @struct\n */\nfunction JWK() {\n  /**\n   * A key ID.  Any ASCII string.\n   * @type {string}\n   */\n  this.kid = '';\n\n  /**\n   * A key type.  One of:\n   *   \"oct\" (symmetric key octect sequence)\n   *   \"RSA\" (RSA key)\n   *   \"EC\" (elliptical curve key)\n   * Use \"oct\" for clearkey.\n   * @type {string}\n   */\n  this.kty = '';\n\n  /**\n   * A key in base 64.  Used with kty=\"oct\".\n   * @type {string}\n   */\n  this.k = '';\n}\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/externs/mediakeys.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Externs for MediaKeys based on\n * {@link http://goo.gl/blgtZZ EME draft 12 March 2015}\n *\n * @externs\n */\n\n\n/**\n * @typedef {string}\n * 'optional', 'required', 'not-allowed'\n */\nvar MediaKeysRequirement;\n\n\n/**\n * @typedef {string}\n * 'temporary', 'persistent-license', 'persistent-usage-record'\n */\nvar MediaKeySessionType;\n\n\n/**\n * @typedef {{contentType: string, robustness: string}}\n * gjslint: disable=900\n */\nvar MediaKeySystemMediaCapability;\n\n\n/**\n * @typedef {{\n *   initDataTypes: (Array.<string>|undefined),\n *   audioCapabilities: (Array.<!MediaKeySystemMediaCapability>|undefined),\n *   videoCapabilities: (Array.<!MediaKeySystemMediaCapability>|undefined),\n *   distinctiveIdentifier: (MediaKeysRequirement|undefined),\n *   persistentState: (MediaKeysRequirement|undefined),\n *   sessionTypes: (Array.<MediaKeySessionType>|undefined),\n *   label: (string|undefined)\n * }}\n * gjslint: disable=900\n */\nvar MediaKeySystemConfiguration;\n\n\n/**\n * @param {string} keySystem\n * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n * @return {!Promise.<!MediaKeySystemAccess>}\n */\nNavigator.prototype.requestMediaKeySystemAccess =\n    function(keySystem, supportedConfigurations) {};\n\n\n/** @const {MediaKeys} */\nHTMLMediaElement.prototype.mediaKeys;\n\n\n/**\n * @param {MediaKeys} mediaKeys\n * @return {!Promise}\n */\nHTMLMediaElement.prototype.setMediaKeys = function(mediaKeys) {};\n\n\n\n/** @interface */\nfunction MediaKeySystemAccess() {}\n\n\n/** @return {!Promise.<!MediaKeys>} */\nMediaKeySystemAccess.prototype.createMediaKeys = function() {};\n\n\n/** @return {!MediaKeySystemConfiguration} */\nMediaKeySystemAccess.prototype.getConfiguration = function() {};\n\n\n/** @const {string} */\nMediaKeySystemAccess.prototype.keySystem;\n\n\n\n/** @interface */\nfunction MediaKeys() {}\n\n\n/**\n * @param {MediaKeySessionType=} opt_sessionType defaults to \"temporary\"\n * @return {!MediaKeySession}\n * @throws {TypeError} if opt_sessionType is invalid.\n */\nMediaKeys.prototype.createSession = function(opt_sessionType) {};\n\n\n/**\n * @param {?BufferSource} serverCertificate\n * @return {!Promise}\n */\nMediaKeys.prototype.setServerCertificate = function(serverCertificate) {};\n\n\n\n/**\n * @interface\n */\nfunction MediaKeyStatusMap() {}\n\n\n/** @const {number} */\nMediaKeyStatusMap.prototype.size;\n\n\n/**\n * The functor is called with each status and key ID.\n * @param {function(string, BufferSource)} fn\n */\nMediaKeyStatusMap.prototype.forEach = function(fn) {};\n\n\n/**\n * @param {BufferSource} keyId\n * @return {string|undefined}\n */\nMediaKeyStatusMap.prototype.get = function(keyId) {};\n\n\n/**\n * @param {BufferSource} keyId\n * @return {boolean}\n */\nMediaKeyStatusMap.prototype.has = function(keyId) {};\n\n\n\n/**\n * @interface\n * @extends {EventTarget}\n */\nfunction MediaKeySession() {}\n\n\n/** @const {string} */\nMediaKeySession.prototype.sessionId;\n\n\n/** @const {number} */\nMediaKeySession.prototype.expiration;\n\n\n/** @const {!Promise} */\nMediaKeySession.prototype.closed;\n\n\n/** @const {!MediaKeyStatusMap} */\nMediaKeySession.prototype.keyStatuses;\n\n\n/**\n * @param {string} initDataType\n * @param {!BufferSource} initData\n * @return {!Promise}\n */\nMediaKeySession.prototype.generateRequest = function(initDataType, initData) {};\n\n\n/**\n * @param {string} sessionId\n * @return {!Promise.<boolean>}}\n */\nMediaKeySession.prototype.load = function(sessionId) {};\n\n\n/**\n * @param {?BufferSource} response\n * @return {!Promise}\n */\nMediaKeySession.prototype.update = function(response) {};\n\n\n/** @return {!Promise} */\nMediaKeySession.prototype.close = function() {};\n\n\n/** @return {!Promise} */\nMediaKeySession.prototype.remove = function() {};\n\n\n/** @override */\nMediaKeySession.prototype.addEventListener =\n    function(type, listener, useCapture) {};\n\n\n/** @override */\nMediaKeySession.prototype.removeEventListener =\n    function(type, listener, useCapture) {};\n\n\n/** @override */\nMediaKeySession.prototype.dispatchEvent = function(evt) {};\n\n\n\n/**\n * @constructor\n * @param {string} type\n * @param {Object=} opt_eventInitDict\n * @extends {Event}\n */\nfunction MediaKeyMessageEvent(type, opt_eventInitDict) {}\n\n\n/** @const {string} */\nMediaKeyMessageEvent.prototype.messageType;\n\n\n/** @const {!ArrayBuffer} */\nMediaKeyMessageEvent.prototype.message;\n\n\n/** @const {!MediaKeySession} */\nMediaKeyMessageEvent.prototype.target;\n\n\n\n/**\n * @constructor\n * @param {string} type\n * @param {Object=} opt_eventInitDict\n * @extends {Event}\n */\nfunction MediaEncryptedEvent(type, opt_eventInitDict) {}\n\n\n/** @const {string} */\nMediaEncryptedEvent.prototype.initDataType;\n\n\n/** @const {ArrayBuffer} */\nMediaEncryptedEvent.prototype.initData;\n\n\n/** @const {!HTMLMediaElement} */\nMediaEncryptedEvent.prototype.target;\n\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/externs/mediasession.js":"/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * @fileoverview Externs for MediaSession based on\n * {@link https://goo.gl/8QS094 Editor's Draft, 12 January 2017}\n *\n * @externs\n */\n\n\n\n/**\n * @constructor\n */\nvar MediaMetadata = function(options) {};\n\n\n/** @type {string} */\nMediaMetadata.prototype.title;\n\n\n/** @type {MediaMetadata} */\nNavigator.prototype.mediaSession;\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/externs/msmediakeys.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Externs for prefixed EME v20140218 as supported by IE11/Edge\n * (http://www.w3.org/TR/2014/WD-encrypted-media-20140218).\n * @externs\n */\n\n\n\n/**\n * @constructor\n * @param {string} keySystem\n */\nfunction MSMediaKeys(keySystem) {}\n\n\n/**\n * @param {string} keySystem\n * @param {string} contentType\n * @return {boolean}\n */\nMSMediaKeys.isTypeSupported = function(keySystem, contentType) {};\n\n\n/**\n * @param {string} contentType\n * @param {Uint8Array} initData\n * @param {Uint8Array=} opt_cdmData\n * @return {!MSMediaKeySession}\n */\nMSMediaKeys.prototype.createSession =\n    function(contentType, initData, opt_cdmData) {};\n\n\n\n/**\n * @interface\n * @extends {EventTarget}\n */\nfunction MSMediaKeySession() {}\n\n\n/**\n * @param {Uint8Array} message\n */\nMSMediaKeySession.prototype.update = function(message) {};\n\n\nMSMediaKeySession.prototype.close = function() {};\n\n\n/** @type {MSMediaKeyError} */\nMSMediaKeySession.prototype.error;\n\n\n/** @override */\nMSMediaKeySession.prototype.addEventListener =\n    function(type, listener, useCapture) {};\n\n\n/** @override */\nMSMediaKeySession.prototype.removeEventListener =\n    function(type, listener, useCapture) {};\n\n\n/** @override */\nMSMediaKeySession.prototype.dispatchEvent = function(evt) {};\n\n\n/**\n * @param {MSMediaKeys} mediaKeys\n */\nHTMLMediaElement.prototype.msSetMediaKeys = function(mediaKeys) {};\n\n\n\n/** @constructor */\nfunction MSMediaKeyError() {}\n\n\n/** @type {number} */\nMSMediaKeyError.prototype.code;\n\n\n/** @type {number} */\nMSMediaKeyError.prototype.systemCode;\n\n\n/** @type {number} */\nMSMediaKeyError.MS_MEDIA_KEYERR_UNKNOWN;\n\n\n/** @type {number} */\nMSMediaKeyError.MS_MEDIA_KEYERR_CLIENT;\n\n\n/** @type {number} */\nMSMediaKeyError.MS_MEDIA_KEYERR_SERVICE;\n\n\n/** @type {number} */\nMSMediaKeyError.MS_MEDIA_KEYERR_OUTPUT;\n\n\n/** @type {number} */\nMSMediaKeyError.MS_MEDIA_KEYERR_HARDWARECHANGE;\n\n\n/** @type {number} */\nMSMediaKeyError.MS_MEDIA_KEYERR_DOMAIN;\n\n\n/** @type {number} */\nMediaError.prototype.msExtendedCode;\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/externs/prefixed_eme.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Externs for prefixed EME v0.1b.\n * @externs\n */\n\n\n/**\n * @param {string} keySystem\n * @param {Uint8Array} key\n * @param {Uint8Array} keyId\n * @param {string} sessionId\n */\nHTMLMediaElement.prototype.webkitAddKey =\n    function(keySystem, key, keyId, sessionId) {};\n\n\n/**\n * @param {string} keySystem\n * @param {string} sessionId\n */\nHTMLMediaElement.prototype.webkitCancelKeyRequest =\n    function(keySystem, sessionId) {};\n\n\n/**\n * @param {string} keySystem\n * @param {!Uint8Array} initData\n */\nHTMLMediaElement.prototype.webkitGenerateKeyRequest =\n    function(keySystem, initData) {};\n\n\n/**\n * @param {string} mimeType\n * @param {string=} opt_keySystem\n * @return {string} '', 'maybe', or 'probably'\n * @override the standard one-argument version\n */\nHTMLVideoElement.prototype.canPlayType =\n    function(mimeType, opt_keySystem) {};\n\n\n\n/**\n * @constructor\n * @param {string} type\n * @param {Object=} opt_eventInitDict\n * @extends {Event}\n */\nfunction MediaKeyEvent(type, opt_eventInitDict) {}\n\n\n/**\n * @type {string}\n * @const\n */\nMediaKeyEvent.prototype.keySystem;\n\n\n/**\n * @type {string}\n * @const\n */\nMediaKeyEvent.prototype.sessionId;\n\n\n/**\n * @type {Uint8Array}\n * @const\n */\nMediaKeyEvent.prototype.initData;\n\n\n/**\n * @type {Uint8Array}\n * @const\n */\nMediaKeyEvent.prototype.message;\n\n\n/**\n * @type {string}\n * @const\n */\nMediaKeyEvent.prototype.defaultURL;\n\n\n/**\n * @type {MediaKeyError}\n * @const\n */\nMediaKeyEvent.prototype.errorCode;\n\n\n/**\n * @type {number}\n * @const\n */\nMediaKeyEvent.prototype.systemCode;\n\n\n/**\n * @type {!HTMLMediaElement}\n * @const\n */\nMediaKeyEvent.prototype.target;\n\n\n\n/** @constructor */\nfunction MediaKeyError() {}\n\n\n/** @type {number} */\nMediaKeyError.prototype.code;\n\n\n/** @type {number} */\nMediaKeyError.prototype.systemCode;\n\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/externs/texttrack.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Externs for TextTrack and TextTrackCue which are\n * missing from the closure compiler.\n *\n * @externs\n */\n\n\n/** @type {string} */\nTextTrack.prototype.label;\n\n\n/** @type {string} */\nTextTrackCue.prototype.positionAlign;\n\n\n/** @type {string} */\nTextTrackCue.prototype.lineAlign;\n\n\n/** @type {number|null|string} */\nTextTrackCue.prototype.line;\n\n\n/** @type {string} */\nTextTrackCue.prototype.vertical;\n\n\n/** @type {boolean} */\nTextTrackCue.prototype.snapToLines;\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/externs/xmlhttprequest.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Externs for XMLHttpRequest which are missing from the closure\n * compiler.\n *\n * @externs\n */\n\n\n/** @type {number} */\nXMLHttpRequest.UNSENT;\n\n\n/** @type {number} */\nXMLHttpRequest.OPENED;\n\n\n/** @type {number} */\nXMLHttpRequest.HEADERS_RECEIVED;\n\n\n/** @type {number} */\nXMLHttpRequest.LOADING;\n\n\n/** @type {number} */\nXMLHttpRequest.DONE;\n\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/player.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.Player');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.abr.EwmaBandwidthEstimator');\ngoog.require('shaka.abr.SimpleAbrManager');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.media.ManifestParser');\ngoog.require('shaka.media.MediaSourceEngine');\ngoog.require('shaka.media.Playhead');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.media.StreamingEngine');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.CancelableChain');\ngoog.require('shaka.util.ConfigUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.MapUtils');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.StreamUtils');\n\n\n\n/**\n * Construct a Player.\n *\n * @param {!HTMLMediaElement} video Any existing TextTracks attached to this\n *   element that were not created by Shaka will be disabled.  A new TextTrack\n *   may be created to display captions or subtitles.\n * @param {function(shaka.Player)=} opt_dependencyInjector Optional callback\n *   which is called to inject mocks into the Player. Used for testing.\n *\n * @constructor\n * @struct\n * @implements {shaka.util.IDestroyable}\n * @extends {shaka.util.FakeEventTarget}\n * @export\n */\nshaka.Player = function(video, opt_dependencyInjector) {\n  shaka.util.FakeEventTarget.call(this);\n\n  /** @private {boolean} */\n  this.destroyed_ = false;\n\n  /** @private {HTMLMediaElement} */\n  this.video_ = video;\n\n  /** @private {TextTrack} */\n  this.textTrack_ = null;\n\n  /** @private {shaka.util.EventManager} */\n  this.eventManager_ = new shaka.util.EventManager();\n\n  /** @private {shakaExtern.AbrManager} */\n  this.defaultAbrManager_ = new shaka.abr.SimpleAbrManager();\n\n  /** @private {shaka.net.NetworkingEngine} */\n  this.networkingEngine_ = null;\n\n  /** @private {shaka.media.DrmEngine} */\n  this.drmEngine_ = null;\n\n  /** @private {MediaSource} */\n  this.mediaSource_ = null;\n\n  /** @private {shaka.media.MediaSourceEngine} */\n  this.mediaSourceEngine_ = null;\n\n  /** @private {Promise} */\n  this.mediaSourceOpen_ = null;\n\n  /** @private {shaka.media.Playhead} */\n  this.playhead_ = null;\n\n  /** @private {shaka.media.StreamingEngine} */\n  this.streamingEngine_ = null;\n\n  /** @private {shakaExtern.ManifestParser} */\n  this.parser_ = null;\n\n  /** @private {?shakaExtern.Manifest} */\n  this.manifest_ = null;\n\n  /** @private {?string} */\n  this.manifestUri_ = null;\n\n  /**\n   * Contains an ID for use with creating streams.  The manifest parser should\n   * start with small IDs, so this starts with a large one.\n   * @private {number}\n   */\n  this.nextExternalStreamId_ = 1e9;\n\n  /** @private {!Array.<number>} */\n  this.loadingTextStreamIds_ = [];\n\n  /** @private {boolean} */\n  this.buffering_ = false;\n\n  /** @private {boolean} */\n  this.switchingPeriods_ = true;\n\n  /** @private {shaka.util.CancelableChain} */\n  this.loadChain_ = null;\n\n  /** @private {Promise} */\n  this.unloadChain_ = null;\n\n  /**\n   * @private {!Object.<string, {\n   *   stream: shakaExtern.Stream,\n   *   clearBuffer: boolean\n   * }>}\n   */\n  this.deferredSwitches_ = {};\n\n  /** @private {?shakaExtern.PlayerConfiguration} */\n  this.config_ = this.defaultConfig_();\n\n  /** @private {{width: number, height: number}} */\n  this.maxHwRes_ = { width: Infinity, height: Infinity };\n\n  /** @private {!Array.<shakaExtern.StreamChoice>} */\n  this.switchHistory_ = [];\n\n  /** @private {number} */\n  this.playTime_ = 0;\n\n  /** @private {number} */\n  this.bufferingTime_ = 0;\n\n  /** @private {number} */\n  this.lastStatUpdateTimestamp_ = 0;\n\n  if (opt_dependencyInjector)\n    opt_dependencyInjector(this);\n\n  this.networkingEngine_ = this.createNetworkingEngine();\n  this.initialize_();\n};\ngoog.inherits(shaka.Player, shaka.util.FakeEventTarget);\n\n\n/**\n * After destruction, a Player object cannot be used again.\n *\n * @override\n * @export\n */\nshaka.Player.prototype.destroy = function() {\n  this.destroyed_ = true;\n\n  var cancelation = Promise.resolve();\n  if (this.loadChain_) {\n    // A load is in progress.  Cancel it.\n    cancelation = this.loadChain_.cancel(new shaka.util.Error(\n        shaka.util.Error.Category.PLAYER,\n        shaka.util.Error.Code.LOAD_INTERRUPTED));\n  }\n\n  return cancelation.then(function() {\n    var p = Promise.all([\n      // We need to destroy the current fields as well as waiting for an\n      // existing unload to complete.  It is fine to call destroyStreaming_ if\n      // there is an unload since it resets the fields immediately.\n      this.unloadChain_,\n      this.destroyStreaming_(),\n      this.eventManager_ ? this.eventManager_.destroy() : null,\n      this.networkingEngine_ ? this.networkingEngine_.destroy() : null\n    ]);\n\n    this.video_ = null;\n    this.textTrack_ = null;\n    this.eventManager_ = null;\n    this.defaultAbrManager_ = null;\n    this.networkingEngine_ = null;\n    this.config_ = null;\n\n    return p;\n  }.bind(this));\n};\n\n\n/**\n * @define {string} A version number taken from git at compile time.\n */\ngoog.define('GIT_VERSION', 'v2.0.8-debug');\n\n\n/**\n * @const {string}\n * @export\n */\nshaka.Player.version = GIT_VERSION;\n\n\n/**\n * @event shaka.Player.ErrorEvent\n * @description Fired when a playback error occurs.\n * @property {string} type\n *   'error'\n * @property {!shaka.util.Error} detail\n *   An object which contains details on the error.  The error's 'category' and\n *   'code' properties will identify the specific error that occured.  In an\n *   uncompiled build, you can also use the 'message' and 'stack' properties\n *   to debug.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.EmsgEvent\n * @description Fired when a non-typical emsg is found in a segment.\n * @property {string} type\n *   'emsg'\n * @property {shakaExtern.EmsgInfo} detail\n *   An object which contains the content of the emsg box.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.BufferingEvent\n * @description Fired when the player's buffering state changes.\n * @property {string} type\n *   'buffering'\n * @property {boolean} buffering\n *   True when the Player enters the buffering state.\n *   False when the Player leaves the buffering state.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.LoadingEvent\n * @description Fired when the player begins loading.\n *   Used by the Cast receiver to determine idle state.\n * @property {string} type\n *   'loading'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.UnloadingEvent\n * @description Fired when the player unloads or fails to load.\n *   Used by the Cast receiver to determine idle state.\n * @property {string} type\n *   'unloading'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TextTrackVisibilityEvent\n * @description Fired when text track visibility changes.\n * @property {string} type\n *   'texttrackvisibility'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TracksChangedEvent\n * @description Fired when the list of tracks changes.  For example, this will\n *   happen when changing periods or when track restrictions change.\n * @property {string} type\n *   'trackschanged'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.AdaptationEvent\n * @description Fired when an automatic adaptation causes the active tracks\n *   to change.  Does not fire when the application calls selectTrack().\n * @property {string} type\n *   'adaptation'\n * @exportDoc\n */\n\n\n/** @private {!Object.<string, function():*>} */\nshaka.Player.supportPlugins_ = {};\n\n\n/**\n * Registers a plugin callback that will be called with support().  The\n * callback will return the value that will be stored in the return value from\n * support().\n *\n * @param {string} name\n * @param {function():*} callback\n * @export\n */\nshaka.Player.registerSupportPlugin = function(name, callback) {\n  shaka.Player.supportPlugins_[name] = callback;\n};\n\n\n/**\n * Return whether the browser provides basic support. If this returns false,\n * Shaka Player cannot be used at all. In this case, do not construct a Player\n * instance and do not use the library.\n *\n * @return {boolean}\n * @export\n */\nshaka.Player.isBrowserSupported = function() {\n  // Basic features needed for the library to be usable.\n  var basic = !!window.Promise && !!window.Uint8Array &&\n              !!Array.prototype.forEach;\n\n  return basic &&\n      shaka.media.MediaSourceEngine.isBrowserSupported() &&\n      shaka.media.DrmEngine.isBrowserSupported();\n};\n\n\n/**\n * Probes the browser to determine what features are supported.  This makes a\n * number of requests to EME/MSE/etc which may result in user prompts.  This\n * should only be used for diagnostics.\n *\n * NOTE: This may show a request to the user for permission.\n *\n * @see https://goo.gl/ovYLvl\n * @return {!Promise.<shakaExtern.SupportType>}\n * @export\n */\nshaka.Player.probeSupport = function() {\n  goog.asserts.assert(shaka.Player.isBrowserSupported(),\n                      'Must have basic support');\n  return shaka.media.DrmEngine.probeSupport().then(function(drm) {\n    var manifest = shaka.media.ManifestParser.probeSupport();\n    var media = shaka.media.MediaSourceEngine.probeSupport();\n    var ret = {\n      manifest: manifest,\n      media: media,\n      drm: drm\n    };\n\n    var plugins = shaka.Player.supportPlugins_;\n    for (var name in plugins) {\n      ret[name] = plugins[name]();\n    }\n\n    return ret;\n  });\n};\n\n\n/**\n * Load a manifest.\n *\n * @param {string} manifestUri\n * @param {number=} opt_startTime Optional start time, in seconds, to begin\n *   playback.  Defaults to 0 for VOD and to the live edge for live.\n * @param {shakaExtern.ManifestParser.Factory=} opt_manifestParserFactory\n *   Optional manifest parser factory to override auto-detection or use an\n *   unregistered parser.\n * @return {!Promise} Resolved when the manifest has been loaded and playback\n *   has begun; rejected when an error occurs or the call was interrupted by\n *   destroy(), unload() or another call to load().\n * @export\n */\nshaka.Player.prototype.load = function(manifestUri, opt_startTime,\n                                       opt_manifestParserFactory) {\n  var unloadPromise = this.unload();\n  var loadChain = new shaka.util.CancelableChain();\n  this.loadChain_ = loadChain;\n  this.dispatchEvent(new shaka.util.FakeEvent('loading'));\n\n  return loadChain.then(function() {\n    return unloadPromise;\n  }).then(function() {\n\n    goog.asserts.assert(this.networkingEngine_, 'Must not be destroyed');\n    return shaka.media.ManifestParser.getFactory(\n        manifestUri,\n        this.networkingEngine_,\n        this.config_.manifest.retryParameters,\n        opt_manifestParserFactory);\n  }.bind(this)).then(function(factory) {\n\n    this.parser_ = new factory();\n    this.parser_.configure(this.config_.manifest);\n    goog.asserts.assert(this.networkingEngine_, 'Must not be destroyed');\n    return this.parser_.start(\n        manifestUri,\n        this.networkingEngine_,\n        this.filterPeriod_.bind(this),\n        this.onError_.bind(this),\n        this.onEvent_.bind(this));\n  }.bind(this)).then(function(manifest) {\n\n    if (manifest.periods.length == 0) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.NO_PERIODS);\n    }\n\n    this.manifest_ = manifest;\n    this.manifestUri_ = manifestUri;\n    this.drmEngine_ = this.createDrmEngine();\n    this.drmEngine_.configure(this.config_.drm);\n    return this.drmEngine_.init(manifest, false /* isOffline */);\n  }.bind(this)).then(function() {\n\n    // Re-filter the manifest after DRM has been initialized.\n    this.manifest_.periods.forEach(this.filterPeriod_.bind(this));\n\n    this.lastStatUpdateTimestamp_ = Date.now() / 1000;\n\n    // Wait for MediaSource to open before continuing.\n    return Promise.all([\n      this.drmEngine_.attach(this.video_),\n      this.mediaSourceOpen_\n    ]);\n  }.bind(this)).then(function() {\n    this.config_.abr.manager.init(this.switch_.bind(this));\n\n    // MediaSource is open, so create the Playhead, MediaSourceEngine, and\n    // StreamingEngine.\n    this.playhead_ = this.createPlayhead(opt_startTime);\n    this.mediaSourceEngine_ = this.createMediaSourceEngine();\n\n    this.streamingEngine_ = this.createStreamingEngine();\n    this.streamingEngine_.configure(this.config_.streaming);\n    return this.streamingEngine_.init();\n  }.bind(this)).then(function() {\n\n    // Re-filter the manifest after streams have been chosen.\n    this.manifest_.periods.forEach(this.filterPeriod_.bind(this));\n    // Dispatch a 'trackschanged' event now that all initial filtering is done.\n    this.onTracksChanged_();\n    // Since the first streams just became active, send an adaptation event.\n    this.onAdaptation_();\n\n    this.loadChain_ = null;\n  }.bind(this)).finalize().catch(function(error) {\n    goog.asserts.assert(error instanceof shaka.util.Error,\n                        'Wrong error type!');\n    shaka.log.debug('load() failed:', error);\n\n    // If we haven't started another load, clear the loadChain_ member.\n    if (this.loadChain_ == loadChain) {\n      this.loadChain_ = null;\n      this.dispatchEvent(new shaka.util.FakeEvent('unloading'));\n    }\n    return Promise.reject(error);\n  }.bind(this));\n};\n\n\n/**\n * Creates a new instance of DrmEngine.  This can be replaced by tests to\n * create fake instances instead.\n *\n * @return {!shaka.media.DrmEngine}\n */\nshaka.Player.prototype.createDrmEngine = function() {\n  goog.asserts.assert(this.networkingEngine_, 'Must not be destroyed');\n  return new shaka.media.DrmEngine(\n      this.networkingEngine_,\n      this.onError_.bind(this),\n      this.onKeyStatus_.bind(this));\n};\n\n\n/**\n * Creates a new instance of NetworkingEngine.  This can be replaced by tests\n * to create fake instances instead.\n *\n * @return {!shaka.net.NetworkingEngine}\n */\nshaka.Player.prototype.createNetworkingEngine = function() {\n  return new shaka.net.NetworkingEngine(this.onSegmentDownloaded_.bind(this));\n};\n\n\n/**\n * Creates a new instance of Playhead.  This can be replaced by tests to create\n * fake instances instead.\n *\n * @param {number=} opt_startTime\n * @return {!shaka.media.Playhead}\n */\nshaka.Player.prototype.createPlayhead = function(opt_startTime) {\n  var timeline = this.manifest_.presentationTimeline;\n  var rebufferingGoal = shaka.media.StreamingEngine.getRebufferingGoal(\n      this.manifest_, this.config_.streaming, 1 /* scaleFactor */);\n  return new shaka.media.Playhead(\n      this.video_, timeline, rebufferingGoal, opt_startTime || null,\n      this.onBuffering_.bind(this), this.onSeek_.bind(this));\n};\n\n\n/**\n * Create and open MediaSource.  Potentially slow.\n *\n * @return {!Promise}\n */\nshaka.Player.prototype.createMediaSource = function() {\n  this.mediaSource_ = new MediaSource();\n  var ret = new shaka.util.PublicPromise();\n  this.eventManager_.listen(this.mediaSource_, 'sourceopen', ret.resolve);\n  this.video_.src = window.URL.createObjectURL(this.mediaSource_);\n  return ret;\n};\n\n\n/**\n * Creates a new instance of MediaSourceEngine.  This can be replaced by tests\n * to create fake instances instead.\n *\n * @return {!shaka.media.MediaSourceEngine}\n */\nshaka.Player.prototype.createMediaSourceEngine = function() {\n  return new shaka.media.MediaSourceEngine(\n      this.video_, this.mediaSource_, this.textTrack_);\n};\n\n\n/**\n * Creates a new instance of StreamingEngine.  This can be replaced by tests\n * to create fake instances instead.\n *\n * @return {!shaka.media.StreamingEngine}\n */\nshaka.Player.prototype.createStreamingEngine = function() {\n  goog.asserts.assert(this.playhead_, 'Must not be destroyed');\n  goog.asserts.assert(this.mediaSourceEngine_, 'Must not be destroyed');\n  goog.asserts.assert(this.manifest_, 'Must not be destroyed');\n  return new shaka.media.StreamingEngine(\n      this.playhead_, this.mediaSourceEngine_, this.networkingEngine_,\n      this.manifest_, this.onChooseStreams_.bind(this),\n      this.canSwitch_.bind(this), this.onError_.bind(this));\n};\n\n\n/**\n * Configure the Player instance.\n *\n * The config object passed in need not be complete.  It will be merged with\n * the existing Player configuration.\n *\n * Config keys and types will be checked.  If any problems with the config\n * object are found, errors will be reported through logs.\n *\n * @param {!Object} config This should follow the form of\n *   {@link shakaExtern.PlayerConfiguration}, but you may omit any field you do\n *   not wish to change.\n * @export\n */\nshaka.Player.prototype.configure = function(config) {\n  goog.asserts.assert(this.config_, 'Config must not be null!');\n\n  if (config.abr && config.abr.manager &&\n      config.abr.manager != this.config_.abr.manager) {\n    this.config_.abr.manager.stop();\n    config.abr.manager.init(this.switch_.bind(this));\n  }\n\n  shaka.util.ConfigUtils.mergeConfigObjects(\n      this.config_, config, this.defaultConfig_(), this.configOverrides_(), '');\n\n  this.applyConfig_();\n};\n\n\n/**\n * Apply config changes.\n * @private\n */\nshaka.Player.prototype.applyConfig_ = function() {\n  if (this.parser_) {\n    this.parser_.configure(this.config_.manifest);\n  }\n  if (this.drmEngine_) {\n    this.drmEngine_.configure(this.config_.drm);\n  }\n  if (this.streamingEngine_) {\n    this.streamingEngine_.configure(this.config_.streaming);\n\n    // Need to apply the restrictions to every period.\n    try {\n      // this.filterPeriod_() may throw.\n      this.manifest_.periods.forEach(this.filterPeriod_.bind(this));\n    } catch (error) {\n      this.onError_(error);\n    }\n\n    // May need to choose new streams.\n    shaka.log.debug('Choosing new streams after changing configuration');\n    var period = this.streamingEngine_.getCurrentPeriod();\n    this.chooseStreamsAndSwitch_(period);\n  }\n\n  // Simply enable/disable ABR with each call, since multiple calls to these\n  // methods have no effect.\n  if (this.config_.abr.enabled && !this.switchingPeriods_) {\n    this.config_.abr.manager.enable();\n  } else {\n    this.config_.abr.manager.disable();\n  }\n\n  this.config_.abr.manager.setDefaultEstimate(\n      this.config_.abr.defaultBandwidthEstimate);\n};\n\n\n/**\n * Return a copy of the current configuration.  Modifications of the returned\n * value will not affect the Player's active configuration.  You must call\n * player.configure() to make changes.\n *\n * @return {shakaExtern.PlayerConfiguration}\n * @export\n */\nshaka.Player.prototype.getConfiguration = function() {\n  goog.asserts.assert(this.config_, 'Config must not be null!');\n\n  var ret = this.defaultConfig_();\n  shaka.util.ConfigUtils.mergeConfigObjects(\n      ret, this.config_, this.defaultConfig_(), this.configOverrides_(), '');\n  return ret;\n};\n\n\n/**\n * Reset configuration to default.\n * @export\n */\nshaka.Player.prototype.resetConfiguration = function() {\n  var config = this.defaultConfig_();\n\n  if (config.abr && config.abr.manager &&\n      config.abr.manager != this.config_.abr.manager) {\n    this.config_.abr.manager.stop();\n    config.abr.manager.init(this.switch_.bind(this));\n  }\n\n  // Don't call mergeConfigObjects_(), since that would not reset open-ended\n  // dictionaries like drm.servers.\n  this.config_ = this.defaultConfig_();\n\n  this.applyConfig_();\n};\n\n\n/**\n * @return {HTMLMediaElement} A reference to the HTML Media Element passed\n *     in during initialization.\n * @export\n */\nshaka.Player.prototype.getMediaElement = function() {\n  return this.video_;\n};\n\n\n/**\n * @return {shaka.net.NetworkingEngine} A reference to the Player's networking\n *     engine.  Applications may use this to make requests through Shaka's\n *     networking plugins.\n * @export\n */\nshaka.Player.prototype.getNetworkingEngine = function() {\n  return this.networkingEngine_;\n};\n\n\n/**\n * @return {?string} If a manifest is loaded, returns the manifest URI given in\n *   the last call to load().  Otherwise, returns null.\n * @export\n */\nshaka.Player.prototype.getManifestUri = function() {\n  return this.manifestUri_;\n};\n\n\n/**\n * @return {boolean} True if the current stream is live.  False otherwise.\n * @export\n */\nshaka.Player.prototype.isLive = function() {\n  return this.manifest_ ?\n         this.manifest_.presentationTimeline.isLive() :\n         false;\n};\n\n\n/**\n * @return {boolean} True if the current stream is in-progress VOD.\n *   False otherwise.\n * @export\n */\nshaka.Player.prototype.isInProgress = function() {\n  return this.manifest_ ?\n         this.manifest_.presentationTimeline.isInProgress() :\n         false;\n};\n\n\n/**\n * Get the seekable range for the current stream.\n * @return {{start: number, end: number}}\n * @export\n */\nshaka.Player.prototype.seekRange = function() {\n  var start = 0;\n  var end = 0;\n  if (this.manifest_) {\n    var timeline = this.manifest_.presentationTimeline;\n    start = timeline.getSegmentAvailabilityStart();\n    end = timeline.getSeekRangeEnd();\n  }\n  return {'start': start, 'end': end};\n};\n\n\n/**\n * Get the key system currently being used by EME.  This returns the empty\n * string if not using EME.\n *\n * @return {string}\n * @export\n */\nshaka.Player.prototype.keySystem = function() {\n  return this.drmEngine_ ? this.drmEngine_.keySystem() : '';\n};\n\n\n/**\n * Get the DrmInfo used to initialize EME.  This returns null when not using\n * EME.\n *\n * @return {?shakaExtern.DrmInfo}\n * @export\n */\nshaka.Player.prototype.drmInfo = function() {\n  return this.drmEngine_ ? this.drmEngine_.getDrmInfo() : null;\n};\n\n\n/**\n * @return {boolean} True if the Player is in a buffering state.\n * @export\n */\nshaka.Player.prototype.isBuffering = function() {\n  return this.buffering_;\n};\n\n\n/**\n * Unload the current manifest and make the Player available for re-use.\n *\n * @return {!Promise} Resolved when streaming has stopped and the previous\n *     content, if any, has been unloaded.\n * @export\n */\nshaka.Player.prototype.unload = function() {\n  if (this.destroyed_) return Promise.resolve();\n  this.dispatchEvent(new shaka.util.FakeEvent('unloading'));\n\n  var p = Promise.resolve();\n  if (this.loadChain_) {\n    // A load is in progress, cancel it.\n    var interrupt = new shaka.util.Error(\n        shaka.util.Error.Category.PLAYER,\n        shaka.util.Error.Code.LOAD_INTERRUPTED);\n    p = this.loadChain_.cancel(interrupt);\n  }\n\n  return p.then(function() {\n    // If there is an existing unload operation, use that.\n    if (!this.unloadChain_) {\n      this.unloadChain_ = this.resetStreaming_().then(function() {\n        this.unloadChain_ = null;\n      }.bind(this));\n    }\n    return this.unloadChain_;\n  }.bind(this));\n};\n\n\n/**\n * Gets the current effective playback rate.  If using trick play, it will\n * return the current trick play rate; otherwise, it will return the video\n * playback rate.\n * @return {number}\n * @export\n */\nshaka.Player.prototype.getPlaybackRate = function() {\n  return this.playhead_ ? this.playhead_.getPlaybackRate() : 0;\n};\n\n\n/**\n * Skip through the content without playing.  Simulated using repeated seeks.\n *\n * Trick play will be canceled automatically if the playhead hits the beginning\n * or end of the seekable range for the content.\n *\n * @param {number} rate The playback rate to simulate.  For example, a rate of\n *     2.5 would result in 2.5 seconds of content being skipped every second.\n *     To trick-play backward, use a negative rate.\n * @export\n */\nshaka.Player.prototype.trickPlay = function(rate) {\n  if (this.playhead_)\n    this.playhead_.setPlaybackRate(rate);\n};\n\n\n/**\n * Cancel trick-play.\n * @export\n */\nshaka.Player.prototype.cancelTrickPlay = function() {\n  if (this.playhead_)\n    this.playhead_.setPlaybackRate(1);\n};\n\n\n/**\n * Return a list of audio, video, and text tracks available for the current\n * Period.  If there are multiple Periods, then you must seek to the Period\n * before being able to switch.\n *\n * @return {!Array.<shakaExtern.Track>}\n * @export\n */\nshaka.Player.prototype.getTracks = function() {\n  if (!this.streamingEngine_)\n    return [];\n\n  var activeStreams = this.streamingEngine_.getActiveStreams();\n  var period = this.streamingEngine_.getCurrentPeriod();\n  return shaka.util.StreamUtils.getTracks(period, activeStreams)\n      .filter(function(track) {\n        // Don't show any tracks that are being loaded still.\n        return this.loadingTextStreamIds_.indexOf(track.id) < 0;\n      }.bind(this));\n};\n\n\n/**\n * Select a specific track.  For audio or video, this disables adaptation.\n * Note that AdaptationEvents are not fired for manual track selections.\n *\n * @param {shakaExtern.Track} track\n * @param {boolean=} opt_clearBuffer\n * @export\n */\nshaka.Player.prototype.selectTrack = function(track, opt_clearBuffer) {\n  if (!this.streamingEngine_)\n    return;\n\n  var period = this.streamingEngine_.getCurrentPeriod();\n  var data = shaka.util.StreamUtils.findStreamForTrack(period, track);\n  if (!data) {\n    shaka.log.error('Unable to find the track with id \"' + track.id +\n                    '\"; did we change Periods?');\n    return;\n  }\n\n  var stream = data.stream;\n\n  // Double check that the track is allowed to be played.\n  if (!stream.allowedByApplication || !stream.allowedByKeySystem) {\n    shaka.log.error('Unable to switch to track with id \"' + track.id +\n                    '\" because it is restricted.');\n    return;\n  }\n\n  // Add an entry to the history.\n  this.switchHistory_.push({\n    timestamp: Date.now() / 1000,\n    id: stream.id,\n    type: track.type,\n    fromAdaptation: false\n  });\n\n  var streamsToSwitch = {};\n  streamsToSwitch[track.type] = stream;\n\n  if (track.type != 'text') {\n    // Save current text stream to insure that it doesn't get overridden\n    // by a default one inside shaka.Player.configure()\n    var activeStreams = this.streamingEngine_.getActiveStreams();\n    var currentTextStream = activeStreams['text'];\n\n    // Disable ABR for anything other than text track changes.\n    var config = {abr: {enabled: false}};\n    this.configure(config);\n\n    if (currentTextStream) {\n      streamsToSwitch['text'] = currentTextStream;\n    }\n  }\n\n  this.deferredSwitch_(streamsToSwitch, opt_clearBuffer);\n};\n\n\n/**\n * @return {boolean} True if the current text track is visible.\n * @export\n */\nshaka.Player.prototype.isTextTrackVisible = function() {\n  return this.textTrack_.mode == 'showing';\n};\n\n\n/**\n * Set the visibility of the current text track, if any.\n *\n * @param {boolean} on\n * @export\n */\nshaka.Player.prototype.setTextTrackVisibility = function(on) {\n  this.textTrack_.mode = on ? 'showing' : 'hidden';\n  this.onTextTrackVisibility_();\n};\n\n\n/**\n * Return playback and adaptation stats.\n *\n * @return {shakaExtern.Stats}\n * @export\n */\nshaka.Player.prototype.getStats = function() {\n  this.updateStats_();\n\n  var video = {};\n  var audio = {};\n  var videoInfo = this.video_ && this.video_.getVideoPlaybackQuality ?\n      this.video_.getVideoPlaybackQuality() :\n      {};\n  if (this.streamingEngine_) {\n    var activeStreams = this.streamingEngine_.getActiveStreams();\n    video = activeStreams['video'] || {};\n    audio = activeStreams['audio'] || {};\n  }\n\n  return {\n    width: video.width || 0,\n    height: video.height || 0,\n    streamBandwidth: (video.bandwidth + audio.bandwidth) || 0,\n\n    decodedFrames: Number(videoInfo.totalVideoFrames),\n    droppedFrames: Number(videoInfo.droppedVideoFrames),\n    estimatedBandwidth: this.config_.abr.manager.getBandwidthEstimate(),\n    playTime: this.playTime_,\n    bufferingTime: this.bufferingTime_,\n\n    switchHistory: this.switchHistory_.slice(0)\n  };\n};\n\n\n/**\n * Adds the given text track to the current Period.  Load() must resolve before\n * calling.  The current Period or the presentation must have a duration.  This\n * returns a Promise that will resolve when the track can be switched to and\n * will resolve with the track that was created.\n *\n * @param {string} uri\n * @param {string} language\n * @param {string} kind\n * @param {string} mime\n * @param {string=} opt_codec\n * @return {!Promise.<shakaExtern.Track>}\n * @export\n */\nshaka.Player.prototype.addTextTrack = function(\n    uri, language, kind, mime, opt_codec) {\n  if (!this.streamingEngine_) {\n    shaka.log.error(\n        'Must call load() and wait for it to resolve before adding text ' +\n        'tracks.');\n    return Promise.reject();\n  }\n\n  // Get the Period duration.\n  var period = this.streamingEngine_.getCurrentPeriod();\n  /** @type {number} */\n  var periodDuration;\n  for (var i = 0; i < this.manifest_.periods.length; i++) {\n    if (this.manifest_.periods[i] == period) {\n      if (i == this.manifest_.periods.length - 1) {\n        periodDuration = this.manifest_.presentationTimeline.getDuration() -\n            period.startTime;\n        if (periodDuration == Infinity) {\n          shaka.log.error(\n              'The current Period or the presentation must have a duration ' +\n              'to add external text tracks.');\n          return Promise.reject();\n        }\n      } else {\n        var nextPeriod = this.manifest_.periods[i + 1];\n        periodDuration = nextPeriod.startTime - period.startTime;\n      }\n      break;\n    }\n  }\n\n  /** @type {shakaExtern.Stream} */\n  var stream = {\n    id: this.nextExternalStreamId_++,\n    createSegmentIndex: Promise.resolve.bind(Promise),\n    findSegmentPosition: function(time) { return 1; },\n    getSegmentReference: function(ref) {\n      if (ref != 1) return null;\n      return new shaka.media.SegmentReference(\n          1, 0, periodDuration, function() { return [uri]; }, 0, null);\n    },\n    initSegmentReference: null,\n    presentationTimeOffset: 0,\n    mimeType: mime,\n    codecs: opt_codec || '',\n    bandwidth: 0,\n    kind: kind,\n    encrypted: false,\n    keyId: null,\n    language: language,\n    allowedByApplication: true,\n    allowedByKeySystem: true\n  };\n  /** @type {shakaExtern.StreamSet} */\n  var streamSet = {\n    language: language,\n    type: 'text',\n    primary: false,\n    drmInfos: [],\n    streams: [stream]\n  };\n\n  // Add the stream to the loading list to ensure it isn't switched to while it\n  // is initializing.\n  this.loadingTextStreamIds_.push(stream.id);\n  period.streamSets.push(streamSet);\n\n  return this.streamingEngine_.notifyNewStream('text', stream).then(function() {\n    if (this.destroyed_) return;\n\n    // Remove the stream from the loading list.\n    this.loadingTextStreamIds_.splice(\n        this.loadingTextStreamIds_.indexOf(stream.id), 1);\n\n    shaka.log.debug('Choosing new streams after adding a text stream');\n    this.chooseStreamsAndSwitch_(period);\n    this.onTracksChanged_();\n\n    return {\n      id: stream.id,\n      active: false,\n      type: 'text',\n      bandwidth: 0,\n      language: language,\n      kind: kind,\n      width: null,\n      height: null\n    };\n  }.bind(this));\n};\n\n\n/**\n * Set the maximum resolution that the platform's hardware can handle.\n * This will be called automatically by shaka.cast.CastReceiver to enforce\n * limitations of the Chromecast hardware.\n *\n * @param {number} width\n * @param {number} height\n * @export\n */\nshaka.Player.prototype.setMaxHardwareResolution = function(width, height) {\n  this.maxHwRes_.width = width;\n  this.maxHwRes_.height = height;\n};\n\n\n/**\n * Initialize the Player.\n * @private\n */\nshaka.Player.prototype.initialize_ = function() {\n  // Start the (potentially slow) process of opening MediaSource now.\n  this.mediaSourceOpen_ = this.createMediaSource();\n\n  // If the video element has TextTracks, disable them.  If we see one that\n  // was created by a previous instance of Shaka Player, reuse it.\n  for (var i = 0; i < this.video_.textTracks.length; ++i) {\n    var track = this.video_.textTracks[i];\n    track.mode = 'disabled';\n\n    if (track.label == shaka.Player.TextTrackLabel_) {\n      this.textTrack_ = track;\n    }\n  }\n\n  if (!this.textTrack_) {\n    // As far as I can tell, there is no observable difference between setting\n    // kind to 'subtitles' or 'captions' when creating the TextTrack object.\n    // The individual text tracks from the manifest will still have their own\n    // kinds which can be displayed in the app's UI.\n    this.textTrack_ = this.video_.addTextTrack(\n        'subtitles', shaka.Player.TextTrackLabel_);\n  }\n  this.textTrack_.mode = 'hidden';\n\n  // TODO: test that in all cases, the built-in CC controls in the video element\n  // are toggling our TextTrack.\n\n  // Listen for video errors.\n  this.eventManager_.listen(this.video_, 'error',\n      this.onVideoError_.bind(this));\n};\n\n\n/**\n * Destroy members responsible for streaming.\n *\n * @return {!Promise}\n * @private\n */\nshaka.Player.prototype.destroyStreaming_ = function() {\n  if (this.eventManager_) {\n    this.eventManager_.unlisten(this.mediaSource_, 'sourceopen');\n  }\n\n  if (this.video_) {\n    this.video_.removeAttribute('src');\n    this.video_.load();\n  }\n\n  var p = Promise.all([\n    this.config_ ? this.config_.abr.manager.stop() : null,\n    this.drmEngine_ ? this.drmEngine_.destroy() : null,\n    this.mediaSourceEngine_ ? this.mediaSourceEngine_.destroy() : null,\n    this.playhead_ ? this.playhead_.destroy() : null,\n    this.streamingEngine_ ? this.streamingEngine_.destroy() : null,\n    this.parser_ ? this.parser_.stop() : null\n  ]);\n\n  this.drmEngine_ = null;\n  this.mediaSourceEngine_ = null;\n  this.playhead_ = null;\n  this.streamingEngine_ = null;\n  this.parser_ = null;\n  this.manifest_ = null;\n  this.manifestUri_ = null;\n  this.mediaSourceOpen_ = null;\n  this.mediaSource_ = null;\n  this.deferredSwitches_ = {};\n  this.switchHistory_ = [];\n  this.playTime_ = 0;\n  this.bufferingTime_ = 0;\n\n  return p;\n};\n\n\n/**\n * Reset the streaming system.\n * @return {!Promise}\n * @private\n */\nshaka.Player.prototype.resetStreaming_ = function() {\n  if (!this.parser_) {\n    // Nothing is playing, so this is effectively a no-op.\n    return Promise.resolve();\n  }\n\n  // Destroy the streaming system before we recreate everything.\n  return this.destroyStreaming_().then(function() {\n    if (this.destroyed_) return;\n\n    // Force an exit from the buffering state.\n    this.onBuffering_(false);\n\n    // Start the (potentially slow) process of opening MediaSource now.\n    this.mediaSourceOpen_ = this.createMediaSource();\n  }.bind(this));\n};\n\n\n/**\n * @const {string}\n * @private\n */\nshaka.Player.TextTrackLabel_ = 'Shaka Player TextTrack';\n\n\n/**\n * @return {!Object}\n * @private\n */\nshaka.Player.prototype.configOverrides_ = function() {\n  return {\n    '.drm.servers': '',\n    '.drm.clearKeys': '',\n    '.drm.advanced': {\n      distinctiveIdentifierRequired: false,\n      persistentStateRequired: false,\n      videoRobustness: '',\n      audioRobustness: '',\n      serverCertificate: null\n    }\n  };\n};\n\n\n/**\n * @return {shakaExtern.PlayerConfiguration}\n * @private\n */\nshaka.Player.prototype.defaultConfig_ = function() {\n  return {\n    drm: {\n      retryParameters: shaka.net.NetworkingEngine.defaultRetryParameters(),\n      // These will all be verified by special cases in mergeConfigObjects_():\n      servers: {},    // key is arbitrary key system ID, value must be string\n      clearKeys: {},  // key is arbitrary key system ID, value must be string\n      advanced: {}    // key is arbitrary key system ID, value is a record type\n    },\n    manifest: {\n      retryParameters: shaka.net.NetworkingEngine.defaultRetryParameters(),\n      dash: {\n        customScheme: function(node) {\n          // Reference node to keep closure from removing it.\n          // If the argument is removed, it breaks our function length check\n          // in mergeConfigObjects_().\n          // TODO: Find a better solution if possible.\n          // NOTE: Chrome App Content Security Policy prohibits usage of new\n          // Function()\n\n          if (node) return null;\n        },\n        clockSyncUri: ''\n      }\n    },\n    streaming: {\n      retryParameters: shaka.net.NetworkingEngine.defaultRetryParameters(),\n      rebufferingGoal: 2,\n      bufferingGoal: 10,\n      bufferBehind: 30,\n      ignoreTextStreamFailures: false,\n      useRelativeCueTimestamps: false\n    },\n    abr: {\n      manager: this.defaultAbrManager_,\n      enabled: true,\n      defaultBandwidthEstimate:\n          shaka.abr.EwmaBandwidthEstimator.DEFAULT_ESTIMATE\n    },\n    preferredAudioLanguage: '',\n    preferredTextLanguage: '',\n    restrictions: {\n      minWidth: 0,\n      maxWidth: Infinity,\n      minHeight: 0,\n      maxHeight: Infinity,\n      minPixels: 0,\n      maxPixels: Infinity,\n      minAudioBandwidth: 0,\n      maxAudioBandwidth: Infinity,\n      minVideoBandwidth: 0,\n      maxVideoBandwidth: Infinity\n    }\n  };\n};\n\n\n/**\n * @param {shakaExtern.Period} period\n * @private\n */\nshaka.Player.prototype.filterPeriod_ = function(period) {\n  goog.asserts.assert(this.video_, 'Must not be destroyed');\n\n  var activeStreams =\n      this.streamingEngine_ ? this.streamingEngine_.getActiveStreams() : {};\n  shaka.util.StreamUtils.filterPeriod(this.drmEngine_, activeStreams, period);\n\n  // Check for playable streams before restrictions to give a different error\n  // if we have restricted all the tracks rather than there being none.\n  var hasPlayableStreamSets =\n      period.streamSets.some(shaka.util.StreamUtils.hasPlayableStreams);\n\n  var tracksChanged = shaka.util.StreamUtils.applyRestrictions(\n      period, this.config_.restrictions, this.maxHwRes_);\n  if (tracksChanged && !this.loadChain_)\n    this.onTracksChanged_();\n\n  var allStreamsRestricted =\n      !period.streamSets.some(shaka.util.StreamUtils.hasPlayableStreams);\n  if (!hasPlayableStreamSets) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.UNPLAYABLE_PERIOD);\n  } else if (allStreamsRestricted) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.RESTRICTIONS_CANNOT_BE_MET);\n  }\n};\n\n\n/**\n * Switches to the given streams, deferring switches if needed.\n * @param {!Object.<string, shakaExtern.Stream>} streamsByType\n * @param {boolean=} opt_clearBuffer\n * @private\n */\nshaka.Player.prototype.deferredSwitch_ = function(\n    streamsByType, opt_clearBuffer) {\n  for (var type in streamsByType) {\n    var stream = streamsByType[type];\n    var clearBuffer = opt_clearBuffer || false;\n    // TODO: consider adding a cue replacement algorithm to TextEngine to remove\n    // this special case for text:\n    if (type == 'text') clearBuffer = true;\n    if (this.switchingPeriods_) {\n      this.deferredSwitches_[type] = {stream: stream, clearBuffer: clearBuffer};\n    } else {\n      this.streamingEngine_.switch(type, stream, clearBuffer);\n    }\n  }\n};\n\n\n/** @private */\nshaka.Player.prototype.updateStats_ = function() {\n  // Only count while we're loaded.\n  if (!this.manifest_)\n    return;\n\n  var now = Date.now() / 1000;\n  if (this.buffering_)\n    this.bufferingTime_ += (now - this.lastStatUpdateTimestamp_);\n  else\n    this.playTime_ += (now - this.lastStatUpdateTimestamp_);\n\n  this.lastStatUpdateTimestamp_ = now;\n};\n\n\n/**\n * Callback from NetworkingEngine.\n *\n * @param {number} startTimeMs\n * @param {number} endTimeMs\n * @param {number} numBytes\n * @private\n */\nshaka.Player.prototype.onSegmentDownloaded_ = function(\n    startTimeMs, endTimeMs, numBytes) {\n  this.config_.abr.manager.segmentDownloaded(startTimeMs, endTimeMs, numBytes);\n};\n\n\n/**\n * Callback from Playhead.\n *\n * @param {boolean} buffering\n * @private\n */\nshaka.Player.prototype.onBuffering_ = function(buffering) {\n  // Before setting |buffering_|, update the time spent in the previous state.\n  this.updateStats_();\n  this.buffering_ = buffering;\n\n  var event = new shaka.util.FakeEvent('buffering', { 'buffering': buffering });\n  this.dispatchEvent(event);\n};\n\n\n/**\n * Callback from Playhead.\n *\n * @private\n */\nshaka.Player.prototype.onSeek_ = function() {\n  if (this.streamingEngine_) {\n    this.streamingEngine_.seeked();\n  }\n};\n\n\n/**\n * Chooses streams from the given Period.\n *\n * @param {!shakaExtern.Period} period\n * @param {!Object.<string, shakaExtern.StreamSet>} streamSetsByType\n * @param {boolean=} opt_chooseAll If true, choose streams from all stream sets.\n * @return {!Object.<string, !shakaExtern.Stream>} A map of stream types to\n *   chosen streams.\n * @private\n */\nshaka.Player.prototype.chooseStreams_ =\n    function(period, streamSetsByType, opt_chooseAll) {\n  goog.asserts.assert(this.config_, 'Must not be destroyed');\n\n  var hasPlayableStreams = shaka.util.StreamUtils.hasPlayableStreams;\n\n  // If there are no unrestricted streams, issue an error.\n  var manifestIsPlayable =\n      shaka.util.MapUtils.values(streamSetsByType).some(hasPlayableStreams);\n  if (!manifestIsPlayable) {\n    this.onError_(new shaka.util.Error(\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.RESTRICTIONS_CANNOT_BE_MET));\n    return {};\n  }\n\n  // Which StreamSets need to have their chosen stream updated.\n  var needsUpdate = {};\n\n  if (opt_chooseAll) {\n    // Choose new streams for all recognized types.\n\n    // When MIME types starting with 'application/' were incorrectly turned\n    // into StreamSets of type 'application', we fed these to AbrManager.\n    // AbrManager ignored them, and this caused us to fail with a very\n    // confusing RESTRICTIONS_CANNOT_BE_MET error.\n\n    // It is important that we only feed AbrManager things we can expect it to\n    // deal with.  That way, we can later check that AbrManager chose streams\n    // for all the types we requested.\n\n    var recognizedTypes = ['video', 'audio', 'text'];\n    recognizedTypes.forEach(function(type) {\n      if (type in streamSetsByType) {\n        needsUpdate[type] = streamSetsByType[type];\n      }\n    });\n  } else {\n    // Check if any of the active streams is no longer available\n    // or is using the wrong language.\n    var activeStreams = this.streamingEngine_.getActiveStreams();\n    for (var type in activeStreams) {\n      var stream = activeStreams[type];\n      if (!stream.allowedByApplication ||\n          !stream.allowedByKeySystem ||\n          streamSetsByType[type].language != stream.language) {\n        needsUpdate[type] = streamSetsByType[type];\n      }\n    }\n  }\n\n  if (!shaka.util.MapUtils.empty(needsUpdate)) {\n    shaka.log.debug('Choosing new streams for', Object.keys(needsUpdate));\n    var chosen = this.config_.abr.manager.chooseStreams(needsUpdate);\n    if (!shaka.util.MapUtils.every(needsUpdate,\n        function(type, set) { return !!chosen[type]; })) {\n      // Not every type was chosen!  This should only happen when output\n      // restrictions prevent playback of a certain type and there are no\n      // usable streams for that type.\n      this.onError_(new shaka.util.Error(\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.RESTRICTIONS_CANNOT_BE_MET));\n      return {};\n    }\n    return chosen;\n  } else {\n    shaka.log.debug('No new streams need to be chosen.');\n    return {};\n  }\n};\n\n\n/**\n * Chooses streams from the given Period and switches to them.\n * Called after a config change, a new text stream, or a key status event.\n *\n * @param {!shakaExtern.Period} period\n * @private\n */\nshaka.Player.prototype.chooseStreamsAndSwitch_ = function(period) {\n  goog.asserts.assert(this.config_, 'Must not be destroyed');\n  var languageMatches = { 'audio': false, 'text': false };\n  var streamSetsByType = shaka.util.StreamUtils.chooseStreamSets(\n      period, this.config_, languageMatches);\n\n  // chooseStreams_ filters out choices which are already active.\n  var chosen = this.chooseStreams_(period, streamSetsByType);\n\n  for (var type in chosen) {\n    var stream = chosen[type];\n    this.switchHistory_.push({\n      timestamp: Date.now() / 1000,\n      id: stream.id,\n      type: type,\n      fromAdaptation: true\n    });\n  }\n\n  // Because we're running this after a config change (manual language change),\n  // a new text stream, or a key status event, and because active streams have\n  // been filtered out already, it is always okay to clear the buffer for what\n  // remains.\n  this.deferredSwitch_(chosen, true);\n\n  // Send an adaptation event so that the UI can show the new language/tracks.\n  this.onAdaptation_();\n\n  if (streamSetsByType['text']) {\n    // If audio and text tracks have different languages, and the text track\n    // matches the user's preference, then show the captions.\n    if (streamSetsByType['audio'] &&\n        languageMatches['text'] &&\n        streamSetsByType['text'].language !=\n            streamSetsByType['audio'].language) {\n      this.textTrack_.mode = 'showing';\n      this.onTextTrackVisibility_();\n    }\n  }\n};\n\n\n/**\n * Callback from StreamingEngine.\n *\n * @param {!shakaExtern.Period} period\n * @return {!Object.<string, !shakaExtern.Stream>} A map of stream types to\n *   chosen streams.\n * @private\n */\nshaka.Player.prototype.onChooseStreams_ = function(period) {\n  shaka.log.debug('onChooseStreams_', period);\n  goog.asserts.assert(this.config_, 'Must not be destroyed');\n\n  // We are switching Periods, so the AbrManager will be disabled.  But if we\n  // want to abr.enabled, we do not want to call AbrManager.enable before\n  // canSwitch_ is called.\n  this.switchingPeriods_ = true;\n  this.config_.abr.manager.disable();\n\n  shaka.log.debug('Choosing new streams after period changed');\n  var streamSetsByType = shaka.util.StreamUtils.chooseStreamSets(\n      period, this.config_);\n  shaka.log.v2('onChooseStreams_, streamSetsByType=', streamSetsByType);\n  var chosen = this.chooseStreams_(\n      period, streamSetsByType, /* opt_chooseAll */ true);\n  shaka.log.v2('onChooseStreams_, chosen=', chosen);\n\n  // Override the chosen streams with the ones picked in selectTrack.\n  // NOTE: The apparent race between selectTrack and period transition is\n  // handled by StreamingEngine, which will re-request tracks for the\n  // transition if any of these deferred selections are from the wrong period.\n  for (var type in this.deferredSwitches_) {\n    // We are choosing initial tracks, so no segments from this Period have\n    // been downloaded yet.  Therefore, it is okay to ignore the .clearBuffer\n    // member of this structure.\n    chosen[type] = this.deferredSwitches_[type].stream;\n  }\n  this.deferredSwitches_ = {};\n\n  for (var type in chosen) {\n    var stream = chosen[type];\n    this.switchHistory_.push({\n      timestamp: Date.now() / 1000,\n      id: stream.id,\n      type: type,\n      fromAdaptation: true\n    });\n  }\n\n  // If we are presently loading, we aren't done filtering streams just yet.\n  // Wait to send a 'trackschanged' event.\n  if (!this.loadChain_) {\n    this.onTracksChanged_();\n  }\n\n  return chosen;\n};\n\n\n/**\n * Callback from StreamingEngine.\n *\n * @private\n */\nshaka.Player.prototype.canSwitch_ = function() {\n  shaka.log.debug('canSwitch_');\n  this.switchingPeriods_ = false;\n  if (this.config_.abr.enabled)\n    this.config_.abr.manager.enable();\n\n  // If we still have deferred switches, switch now.\n  for (var type in this.deferredSwitches_) {\n    var info = this.deferredSwitches_[type];\n    this.streamingEngine_.switch(type, info.stream, info.clearBuffer);\n  }\n  this.deferredSwitches_ = {};\n};\n\n\n/**\n * Callback from AbrManager.\n *\n * @param {!Object.<string, !shakaExtern.Stream>} streamsByType\n * @param {boolean=} opt_clearBuffer\n * @private\n */\nshaka.Player.prototype.switch_ = function(streamsByType, opt_clearBuffer) {\n  shaka.log.debug('switch_');\n  goog.asserts.assert(this.config_.abr.enabled,\n      'AbrManager should not call switch while disabled!');\n  goog.asserts.assert(!this.switchingPeriods_,\n      'AbrManager should not call switch while transitioning between Periods!');\n\n  // We have adapted to a new stream, record it in the history.  Only add if\n  // we are actually switching the stream.\n  var oldActive = this.streamingEngine_.getActiveStreams();\n  for (var type in streamsByType) {\n    var stream = streamsByType[type];\n    if (oldActive[type] != stream) {\n      this.switchHistory_.push({\n        timestamp: Date.now() / 1000,\n        id: stream.id,\n        type: type,\n        fromAdaptation: true\n      });\n    } else {\n      // If it's the same, remove it from the map.\n      // This allows us to avoid onAdaptation_() when nothing has changed.\n      delete streamsByType[type];\n    }\n  }\n\n  if (shaka.util.MapUtils.empty(streamsByType)) {\n    // There's nothing to change.\n    return;\n  }\n\n  if (!this.streamingEngine_) {\n    // There's no way to change it.\n    return;\n  }\n\n  for (var type in streamsByType) {\n    var clearBuffer = opt_clearBuffer || false;\n    this.streamingEngine_.switch(type, streamsByType[type], clearBuffer);\n  }\n  this.onAdaptation_();\n};\n\n\n/**\n * Dispatches a 'adaptation' event.\n * @private\n */\nshaka.Player.prototype.onAdaptation_ = function() {\n  // In the next frame, dispatch a 'adaptation' event.\n  // This gives StreamingEngine time to absorb the changes before the user\n  // tries to query them.\n  Promise.resolve().then(function() {\n    if (this.destroyed_) return;\n    var event = new shaka.util.FakeEvent('adaptation');\n    this.dispatchEvent(event);\n  }.bind(this));\n};\n\n\n/**\n * Dispatches a 'trackschanged' event.\n * @private\n */\nshaka.Player.prototype.onTracksChanged_ = function() {\n  // In the next frame, dispatch a 'trackschanged' event.\n  // This gives StreamingEngine time to absorb the changes before the user\n  // tries to query them.\n  Promise.resolve().then(function() {\n    if (this.destroyed_) return;\n    var event = new shaka.util.FakeEvent('trackschanged');\n    this.dispatchEvent(event);\n  }.bind(this));\n};\n\n\n/** @private */\nshaka.Player.prototype.onTextTrackVisibility_ = function() {\n  var event = new shaka.util.FakeEvent('texttrackvisibility');\n  this.dispatchEvent(event);\n};\n\n\n/**\n * @param {!shaka.util.Error} error\n * @private\n */\nshaka.Player.prototype.onError_ = function(error) {\n  goog.asserts.assert(error instanceof shaka.util.Error, 'Wrong error type!');\n\n  var event = new shaka.util.FakeEvent('error', { 'detail': error });\n  this.dispatchEvent(event);\n};\n\n\n/**\n * @param {!Event} event\n * @private\n */\nshaka.Player.prototype.onEvent_ = function(event) {\n  this.dispatchEvent(event);\n};\n\n\n/**\n * @param {!Event} event\n * @private\n */\nshaka.Player.prototype.onVideoError_ = function(event) {\n  if (!this.video_.error) return;\n\n  var code = this.video_.error.code;\n  if (code == 1 /* MEDIA_ERR_ABORTED */) {\n    // Ignore this error code, which should only occur when navigating away or\n    // deliberately stopping playback of HTTP content.\n    return;\n  }\n\n  // Extra error information from MS Edge and IE11:\n  var extended = this.video_.error.msExtendedCode;\n  if (extended) {\n    // Convert to unsigned:\n    if (extended < 0) {\n      extended += Math.pow(2, 32);\n    }\n    // Format as hex:\n    extended = extended.toString(16);\n  }\n\n  this.onError_(new shaka.util.Error(\n      shaka.util.Error.Category.MEDIA,\n      shaka.util.Error.Code.VIDEO_ERROR,\n      code, extended));\n};\n\n\n/**\n * @param {!Object.<string, string>} keyStatusMap A map of hex key IDs to\n *   statuses.\n * @private\n */\nshaka.Player.prototype.onKeyStatus_ = function(keyStatusMap) {\n  goog.asserts.assert(this.streamingEngine_, 'Should have been initialized.');\n  // 'usable', 'released', 'output-downscaled', 'status-pending' are statuses\n  // of the usable keys.\n  // 'expired' status is being handled separately in DrmEngine.\n  var restrictedStatuses = ['output-restricted', 'internal-error'];\n\n  var period = this.streamingEngine_.getCurrentPeriod();\n  var tracksChanged = false;\n\n  period.streamSets.forEach(function(streamSet) {\n    streamSet.streams.forEach(function(stream) {\n      var originalAllowed = stream.allowedByKeySystem;\n\n      // Only update the status if it is in the map.\n      if (stream.keyId && stream.keyId in keyStatusMap) {\n        var keyStatus = keyStatusMap[stream.keyId];\n        stream.allowedByKeySystem = restrictedStatuses.indexOf(keyStatus) < 0;\n      }\n\n      if (originalAllowed != stream.allowedByKeySystem) {\n        tracksChanged = true;\n      }\n    });\n  });\n\n  shaka.log.debug('Choosing new streams after key status changed');\n  this.chooseStreamsAndSwitch_(period);\n\n  if (tracksChanged)\n    this.onTracksChanged_();\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/externs/shaka/abr_manager.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/** @externs */\n\n\n\n/**\n * An object which selects Streams for adaptive bit-rate presentations.\n *\n * @interface\n * @exportDoc\n */\nshakaExtern.AbrManager = function() {};\n\n\n/**\n * A callback which implementations call to switch streams.\n *\n * The first argument is a map of content types to chosen streams.\n *\n * The second argument is an optional boolean.  If true, all data will be\n * from the buffer, which will result in a buffering event.\n *\n * @typedef {function(!Object.<string, !shakaExtern.Stream>, boolean=)}\n * @exportDoc\n */\nshakaExtern.AbrManager.SwitchCallback;\n\n\n/**\n * Initializes the AbrManager.\n *\n * @param {shakaExtern.AbrManager.SwitchCallback} switchCallback\n * @exportDoc\n */\nshakaExtern.AbrManager.prototype.init = function(switchCallback) {};\n\n\n/**\n * Chooses one Stream from each StreamSet to switch to. All StreamSets must be\n * from the same Period. Some StreamSets may be absent in the case of language\n * changes.\n *\n * @param {!Object.<string, !shakaExtern.StreamSet>} streamSetsByType\n * @return {!Object.<string, shakaExtern.Stream>}\n * @exportDoc\n */\nshakaExtern.AbrManager.prototype.chooseStreams = function(streamSetsByType) {};\n\n\n/**\n * Enables automatic Stream choices from the last StreamSets passed to\n * chooseStreams(). After this, the AbrManager may call switchCallback() at any\n * time.\n *\n * @exportDoc\n */\nshakaExtern.AbrManager.prototype.enable = function() {};\n\n\n/**\n * Disables automatic Stream suggestions. After this, the AbrManager may not\n * call switchCallback().\n *\n * @exportDoc\n */\nshakaExtern.AbrManager.prototype.disable = function() {};\n\n\n/**\n * Notifies the AbrManager that a segment has been downloaded (includes MP4\n * SIDX data, WebM Cues data, initialization segments, and media segments).\n *\n * @param {number} startTimeMs The wall-clock time, in milliseconds, when the\n *     request began (before any outbound request filters).\n * @param {number} endTimeMs The wall-clock time, in milliseconds, when the\n *     response ended (after all retries and inbound response filters).\n * @param {number} numBytes The total number of bytes transferred.\n * @exportDoc\n */\nshakaExtern.AbrManager.prototype.segmentDownloaded = function(\n    startTimeMs, endTimeMs, numBytes) {};\n\n\n/**\n * Stops any background timers and frees any objects held by this instance.\n * This will only be called after a call to init.\n *\n * @exportDoc\n */\nshakaExtern.AbrManager.prototype.stop = function() {};\n\n\n/**\n * Gets an estimate of the current bandwidth in bit/sec.  This is used by the\n * Player to generate stats.\n *\n * @return {number}\n * @exportDoc\n */\nshakaExtern.AbrManager.prototype.getBandwidthEstimate = function() {};\n\n\n/**\n * Sets the default bandwidth estimate to use if there is not enough data.\n *\n * @param {number} estimate The default bandwidth estimate, in bit/sec.\n * @exportDoc\n */\nshakaExtern.AbrManager.prototype.setDefaultEstimate = function(estimate) {};\n\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/externs/shaka/manifest.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/** @externs */\n\n\n/**\n * @typedef {{\n *   presentationTimeline: !shaka.media.PresentationTimeline,\n *   periods: !Array.<!shakaExtern.Period>,\n *   offlineSessionIds: !Array.<string>,\n *   minBufferTime: number\n * }}\n *\n * @description\n * <p>\n * A Manifest object describes a collection of streams (segmented audio, video,\n * or text data) that share a common timeline. We call the collection of\n * streams \"the presentation\" and their timeline \"the presentation timeline\".\n * A Manifest describes one of two types of presentations: live and\n * video-on-demand.\n * </p>\n *\n * <p>\n * A live presentation begins at some point in time and either continues\n * indefinitely or ends when the presentation stops broadcasting. For a live\n * presentation, wall-clock time maps onto the presentation timeline, and the\n * current wall-clock time maps to the live-edge (AKA \"the current presentation\n * time\"). In contrast, a video-on-demand presentation exists entirely\n * independent of wall-clock time.\n * </p>\n *\n * <p>\n * The presentation timeline is divided into one or more Periods, and each of\n * these Periods contains its own collection of streams. Periods group their\n * streams by type (e.g., 'audio', 'video', or 'text') and logical content, and\n * each individual group defines a StreamSet.\n * </p>\n *\n * <p>\n * A stream has the same logical content as another stream if the only\n * difference between the two is their quality. For example, an SD video stream\n * and an HD video stream that depict the same scene have the same logical\n * content; whereas an English audio stream and a French audio stream have\n * different logical content. The player can automatically switch between\n * streams which have the same logical content to adapt to network conditions.\n * </p>\n *\n * @property {!shaka.media.PresentationTimeline} presentationTimeline\n *   <i>Required.</i> <br>\n *   The presentation timeline.\n * @property {!Array.<!shakaExtern.Period>} periods\n *   <i>Required.</i> <br>\n *   The presentation's Periods. There must be at least one Period.\n * @property {!Array.<string>} offlineSessionIds\n *   <i>Defaults to [].</i> <br>\n *   An array of EME sessions to load for offline playback.\n * @property {number} minBufferTime\n *   <i>Defaults to 0.</i> <br>\n *   The minimum number of seconds of content that must be buffered before\n *   playback can begin.  Can be overridden by a higher value from the Player\n *   configuration.\n *\n * @exportDoc\n */\nshakaExtern.Manifest;\n\n\n/**\n * @typedef {{\n *   startTime: number,\n *   streamSets: !Array.<shakaExtern.StreamSet>\n * }}\n *\n * @description\n * A Period object contains the Streams for part of the presentation.\n *\n * @property {number} startTime\n *   <i>Required.</i> <br>\n *   The Period's start time, in seconds, relative to the start of the\n *   presentation. The first Period must begin at the start of the\n *   presentation. The Period ends immediately before the next Period's start\n *   time or exactly at the end of the presentation timeline. Periods which\n *   begin after the end of the presentation timeline are ignored.\n * @property {!Array.<shakaExtern.StreamSet>} streamSets\n *   <i>Required.</i> <br>\n *   The Period's StreamSets. There must be at least one StreamSet.\n *\n * @exportDoc\n */\nshakaExtern.Period;\n\n\n/**\n * @typedef {{\n *   initData: !Uint8Array,\n *   initDataType: string\n * }}\n *\n * @description\n * Explicit initialization data, which override any initialization data in the\n * content. The initDataType values and the formats that they correspond to\n * are specified {@link https://goo.gl/TNjYwn here}.\n *\n * @property {!Uint8Array} initData\n *   Initialization data in the format indicated by initDataType.\n * @property {string} initDataType\n *   A string to indicate what format initData is in.\n *\n * @exportDoc\n */\nshakaExtern.InitDataOverride;\n\n\n/**\n * @typedef {{\n *   keySystem: string,\n *   licenseServerUri: string,\n *   distinctiveIdentifierRequired: boolean,\n *   persistentStateRequired: boolean,\n *   audioRobustness: string,\n *   videoRobustness: string,\n *   serverCertificate: Uint8Array,\n *   initData: Array.<!shakaExtern.InitDataOverride>,\n *   keyIds: Array.<string>\n * }}\n *\n * @description\n * DRM configuration for a single key system.\n *\n * @property {string} keySystem\n *   <i>Required.</i> <br>\n *   The key system, e.g., \"com.widevine.alpha\".\n * @property {string} licenseServerUri\n *   <i>Filled in by DRM config if missing.</i> <br>\n *   The license server URI.\n * @property {boolean} distinctiveIdentifierRequired\n *   <i>Defaults to false.  Can be filled in by advanced DRM config.</i> <br>\n *   True if the application requires the key system to support distinctive\n *   identifiers.\n * @property {boolean} persistentStateRequired\n *   <i>Defaults to false.  Can be filled in by advanced DRM config.</i> <br>\n *   True if the application requires the key system to support persistent\n *   state, e.g., for persistent license storage.\n * @property {string} audioRobustness\n *   <i>Defaults to '', e.g., no specific robustness required.  Can be filled in\n *   by advanced DRM config.</i> <br>\n *   A key-system-specific string that specifies a required security level.\n * @property {string} videoRobustness\n *   <i>Defaults to '', e.g., no specific robustness required.  Can be filled in\n *   by advanced DRM config.</i> <br>\n *   A key-system-specific string that specifies a required security level.\n * @property {Uint8Array} serverCertificate\n *   <i>Defaults to null, e.g., certificate will be requested from the license\n *   server if required.  Can be filled in by advanced DRM config.</i> <br>\n *   A key-system-specific server certificate used to encrypt license requests.\n *   Its use is optional and is meant as an optimization to avoid a round-trip\n *   to request a certificate.\n * @property {Array.<!shakaExtern.InitDataOverride>} initData\n *   <i>Defaults to [], e.g., no override.</i> <br>\n *   A list of initialization data which override any initialization data found\n *   in the content.  See also shakaExtern.InitDataOverride.\n * @property {Array.<string>} keyIds\n *   <i>Defaults to []</i> <br>\n *   If not empty, contains the default key IDs for this key system.\n * @exportDoc\n */\nshakaExtern.DrmInfo;\n\n\n/**\n * @typedef {{\n *   language: string,\n *   type: string,\n *   primary: boolean,\n *   drmInfos: Array.<!shakaExtern.DrmInfo>,\n *   streams: !Array.<!shakaExtern.Stream>\n * }}\n *\n * @description\n * A StreamSet object contains a set of Streams which have the same type,\n * container/format, and logical content. A StreamSet's type and\n * container/format define its MIME type.\n *\n * @property {string} language\n *   <i>Defaults to '' (i.e., unknown).</i> <br>\n *   The Streams' language, specified as a language code. <br>\n *   See {@link https://tools.ietf.org/html/rfc5646} <br>\n *   See {@link http://www.iso.org/iso/home/standards/language_codes.htm}\n * @property {string} type\n *   <i>Required.</i> <br>\n *   The Streams' type, e.g., 'audio', 'video', or 'text'.\n * @property {boolean} primary\n *   <i>Defaults to false.</i> <br>\n *   True indicates that the player should use this StreamSet over others of\n *   the same type in the same Period. However, the player may use another\n *   StreamSet to meet application preferences, or to achieve better MIME type\n *   or DRM compatibility among other StreamSets.\n * @property {Array.<!shakaExtern.DrmInfo>} drmInfos\n *   <i>Defaults to [] (i.e., no DRM).</i> <br>\n *   An array of DrmInfo objects which describe DRM schemes are compatible with\n *   the content.\n * @property {!Array.<!shakaExtern.Stream>} streams\n *   <i>Required.</i> <br>\n *   The StreamSets's Streams. There must be at least one Stream.\n *\n * @exportDoc\n */\nshakaExtern.StreamSet;\n\n\n/**\n * Creates a SegmentIndex; returns a Promise that resolves after the\n * SegmentIndex has been created.\n *\n * @typedef {function(): !Promise}\n * @exportDoc\n */\nshakaExtern.CreateSegmentIndexFunction;\n\n\n/**\n * Finds the position of the segment for the given time, in seconds, relative\n * to the start of a particular Period; returns null if the position of the\n * segment could not be determined. Note: the position of a segment is unique\n * only among segments within the same Period.\n *\n * @typedef {function(number): ?number}\n * @exportDoc\n */\nshakaExtern.FindSegmentPositionFunction;\n\n\n/**\n * Gets the SegmentReference for the segment at the given position; returns\n * null if no such SegmentReference exists. Note: the position of a segment is\n * unique only among segments within the same Period.\n\n * @typedef {function(number): shaka.media.SegmentReference}\n * @exportDoc\n */\nshakaExtern.GetSegmentReferenceFunction;\n\n\n/**\n * @typedef {{\n *   id: number,\n *   createSegmentIndex: shakaExtern.CreateSegmentIndexFunction,\n *   findSegmentPosition: shakaExtern.FindSegmentPositionFunction,\n *   getSegmentReference: shakaExtern.GetSegmentReferenceFunction,\n *   initSegmentReference: shaka.media.InitSegmentReference,\n *   presentationTimeOffset: (number|undefined),\n *   mimeType: string,\n *   codecs: string,\n *   frameRate: (number|undefined),\n *   bandwidth: (number|undefined),\n *   width: (number|undefined),\n *   height: (number|undefined),\n *   kind: (string|undefined),\n *   encrypted: boolean,\n *   keyId: ?string,\n *   language: string,\n *   allowedByApplication: boolean,\n *   allowedByKeySystem: boolean\n * }}\n *\n * @description\n * A Stream object describes a single stream (segmented media data).\n *\n * @property {number} id\n *   <i>Required.</i> <br>\n *   A unique ID among all Stream objects within the same Manifest.\n * @property {shakaExtern.CreateSegmentIndexFunction} createSegmentIndex\n *   <i>Required.</i> <br>\n *   Creates the Stream's SegmentIndex (asynchronously).\n * @property {shakaExtern.FindSegmentPositionFunction} findSegmentPosition\n *   <i>Required.</i> <br>\n *   Finds the position of the segment for the given time. The caller must call\n *   createSegmentIndex() and wait until the returned Promise resolves before\n *   calling this function.\n * @property {shakaExtern.GetSegmentReferenceFunction} getSegmentReference\n *   <i>Required.</i> <br>\n *   Gets the SegmentReference for the segment at the given position. The\n *   caller must call createSegmentIndex() and wait until the returned Promise\n *   resolves before calling this function.\n * @property {shaka.media.InitSegmentReference} initSegmentReference\n *   The Stream's initialization segment metadata, or null if the segments are\n *   self-initializing.\n * @property {(number|undefined)} presentationTimeOffset\n *   <i>Defaults to 0.</i> <br>\n *   The amount of time, in seconds, that the stream's presentation timestamps\n *   are offset from the start of the Stream's Period, i.e., this value should\n *   equal the first presentation timestamp of the first frame/sample in the\n *   period. <br>\n *   <br>\n *   For example, for MP4 based streams, this value should equal the first\n *   segment's tfdt box's 'baseMediaDecodeTime' field (after it has been\n *   converted to seconds).\n * @property {string} mimeType\n *   <i>Required.</i> <br>\n *   The Stream's MIME type, e.g., 'audio/mp4', 'video/webm', or 'text/vtt'.\n * @property {string} codecs\n *   <i>Defaults to '' (i.e., unknown / not needed).</i> <br>\n *   The Stream's codecs, e.g., 'avc1.4d4015' or 'vp9', which must be\n *   compatible with the Stream's MIME type. <br>\n *   See {@link https://tools.ietf.org/html/rfc6381}\n * @property {(number|undefined)} frameRate\n *   <i>Video streams only.</i> <br>\n *   The Stream's framerate in frames per second\n * @property {(number|undefined)} bandwidth\n *   <i>Audio and video streams only.</i> <br>\n *   The stream's required bandwidth in bits per second.\n * @property {(number|undefined)} width\n *   <i>Video streams only.</i> <br>\n *   The stream's width in pixels.\n * @property {(number|undefined)} height\n *   <i>Video streams only.</i> <br>\n *   The stream's height in pixels.\n * @property {(string|undefined)} kind\n *   <i>Text streams only.</i> <br>\n *   The kind of text stream.  For example, 'captions' or 'subtitles'.\n *   @see https://goo.gl/k1HWA6\n * @property {boolean} encrypted\n *   <i>Defaults to false.</i><br>\n *   True if the stream is encrypted.\n * @property {?string} keyId\n *   <i>Defaults to null (i.e., unencrypted or key ID unknown).</i> <br>\n *   The stream's key ID as a lowercase hex string. This key ID identifies the\n *   encryption key that the browser (key system) can use to decrypt the\n *   stream.\n * @property {string} language\n *   The Stream's language, specified as a language code. <br>\n *   Must be identical to the language of the containing StreamSet.\n * @property {boolean} allowedByApplication\n *   <i>Defaults to true.</i><br>\n *   Set by the Player to indicate whether the stream is allowed to be played\n *   by the application.\n * @property {boolean} allowedByKeySystem\n *   <i>Defaults to true.</i><br>\n *   Set by the Player to indicate whether the stream is allowed to be played\n *   by the key system.\n *\n * @exportDoc\n */\nshakaExtern.Stream;\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/externs/shaka/manifest_parser.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/** @externs */\n\n\n\n/**\n * Parses media manifests and handles manifest updates.\n *\n * Given a URI where the initial manifest is found, a parser will request the\n * manifest, parse it, and return the resulting Manifest object.\n *\n * If the manifest requires updates (e.g. for live media), the parser will use\n * background timers to update the same Manifest object.\n *\n * @interface\n * @exportDoc\n */\nshakaExtern.ManifestParser = function() {};\n\n\n/**\n * A factory for creating the manifest parser.  This will be called with 'new'.\n * This function is registered with shaka.media.ManifestParser to create parser\n * instances.\n *\n * @typedef {function(new:shakaExtern.ManifestParser)}\n * @exportDoc\n */\nshakaExtern.ManifestParser.Factory;\n\n\n/**\n * Called by the Player to provide an updated configuration any time the\n * configuration changes.  Will be called at least once before start().\n *\n * @param {shakaExtern.ManifestConfiguration} config\n * @exportDoc\n */\nshakaExtern.ManifestParser.prototype.configure = function(config) {};\n\n\n/**\n * Parses the given manifest data into a Manifest object and starts any\n * background timers that are needed.  This will only be called once.\n *\n * @param {string} uri The URI of the manifest.\n * @param {!shaka.net.NetworkingEngine} networkingEngine The networking engine\n *     to use for network requests.\n * @param {function(shakaExtern.Period)} filterPeriod A callback to be invoked\n *     on all new Periods so that they can be filtered.\n * @param {function(!shaka.util.Error)} onError A callback to be invoked on\n *     errors.\n * @param {function(!Event)} onEvent A callback to be invoked to dispatch events\n *     to the application.\n * @return {!Promise.<shakaExtern.Manifest>}\n * @exportDoc\n */\nshakaExtern.ManifestParser.prototype.start =\n    function(uri, networkingEngine, filterPeriod, onError, onEvent) {};\n\n\n/**\n * Stops any background timers and frees any objects held by this instance.\n * This will only be called after a successful call to start.  This will only\n * be called once.\n *\n * @return {!Promise}\n * @exportDoc\n */\nshakaExtern.ManifestParser.prototype.stop = function() {};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/externs/shaka/namespace.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * @externs\n * @namespace\n * @summary Types and interfaces which are used outside the library.\n * @exportDoc\n */\nvar shakaExtern;\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/externs/shaka/net.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/** @externs */\n\n\n/**\n * @typedef {{\n *   maxAttempts: number,\n *   baseDelay: number,\n *   backoffFactor: number,\n *   fuzzFactor: number,\n *   timeout: number\n * }}\n *\n * @description\n *   Parameters for retrying requests.\n *\n * @property {number} maxAttempts\n *   The maximum number of times the request should be attempted.\n * @property {number} baseDelay\n *   The delay before the first retry, in milliseconds.\n * @property {number} backoffFactor\n *   The multiplier for successive retry delays.\n * @property {number} fuzzFactor\n *   The maximum amount of fuzz to apply to each retry delay.\n *   For example, 0.5 means \"between 50% below and 50% above the retry delay.\"\n * @property {number} timeout\n *   The request timeout, in milliseconds.  Zero means \"unlimited\".\n *\n * @tutorial network-and-buffering-config\n *\n * @exportDoc\n */\nshakaExtern.RetryParameters;\n\n\n/**\n * @typedef {{\n *   uris: !Array.<string>,\n *   method: string,\n *   body: ArrayBuffer,\n *   headers: !Object.<string, string>,\n *   allowCrossSiteCredentials: boolean,\n *   retryParameters: !shakaExtern.RetryParameters\n * }}\n *\n * @description\n * Defines a network request.  This is passed to one or more request filters\n * that may alter the request, then it is passed to a scheme plugin which\n * performs the actual operation.\n *\n * @property {!Array.<string>} uris\n *   An array of URIs to attempt.  They will be tried in the order they are\n *   given.\n * @property {string} method\n *   The HTTP method to use for the request.\n * @property {ArrayBuffer} body\n *   The body of the request.\n * @property {!Object.<string, string>} headers\n *   A mapping of headers for the request.  e.g.: {'HEADER': 'VALUE'}\n * @property {boolean} allowCrossSiteCredentials\n *   Make requests with credentials.  This will allow cookies in cross-site\n *   requests.  See <a href=\"http://goo.gl/YBRKPe\">http://goo.gl/YBRKPe</a>.\n * @property {!shakaExtern.RetryParameters} retryParameters\n *   An object used to define how often to make retries.\n *\n * @exportDoc\n */\nshakaExtern.Request;\n\n\n/**\n * @typedef {{\n *   uri: string,\n *   data: ArrayBuffer,\n *   headers: !Object.<string, string>\n * }}\n *\n * @description\n * Defines a response object.  This includes the response data and header info.\n * This is given back from the scheme plugin.  This is passed to a response\n * filter before being returned from the request call.\n *\n * @property {string} uri\n *   The URI which was loaded.  Request filters and server redirects can cause\n *   this to be different from the original request URIs.\n * @property {ArrayBuffer} data\n *   The body of the response.\n * @property {!Object.<string, string>} headers\n *   A map of response headers, if supported by the underlying protocol.\n *   All keys should be lowercased.\n *   For HTTP/HTTPS, may not be available cross-origin.\n *\n * @exportDoc\n */\nshakaExtern.Response;\n\n\n/**\n * Defines a plugin that handles a specific scheme.\n *\n * @typedef {!function(string, shakaExtern.Request):\n *     !Promise.<shakaExtern.Response>}\n * @exportDoc\n */\nshakaExtern.SchemePlugin;\n\n\n/**\n * Defines a filter for requests.  This filter takes the request and modifies\n * it before it is sent to the scheme plugin.\n *\n * @typedef {!function(shaka.net.NetworkingEngine.RequestType,\n *                     shakaExtern.Request)}\n * @exportDoc\n */\nshakaExtern.RequestFilter;\n\n\n/**\n * Defines a filter for responses.  This filter takes the response and modifies\n * it before it is returned.\n *\n * @typedef {!function(shaka.net.NetworkingEngine.RequestType,\n *                     shakaExtern.Response)}\n * @exportDoc\n */\nshakaExtern.ResponseFilter;\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/externs/shaka/offline.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/** @externs */\n\n\n/**\n * @typedef {{\n *   basic: boolean,\n *   encrypted: !Object.<string, boolean>\n * }}\n *\n * @property {boolean} basic\n *   True if offline is usable at all.\n * @property {!Object.<string, boolean>} encrypted\n *   A map of key system name to whether it supports offline playback.\n * @exportDoc\n */\nshakaExtern.OfflineSupport;\n\n\n/**\n * @typedef {{\n *   trackSelectionCallback:\n *       function(!Array.<shakaExtern.Track>):!Array.<shakaExtern.Track>,\n *   progressCallback: function(shakaExtern.StoredContent,number)\n * }}\n *\n * @property {function(!Array.<shakaExtern.Track>):!Array.<shakaExtern.Track>}\n *     trackSelectionCallback\n *   Called inside store() to determine which tracks to save from a manifest.\n *   It is passed an array of Tracks from the manifest and it should return\n *   an array of the tracks to store.  This is called for each Period in the\n *   manifest (in order).\n * @property {function(shakaExtern.StoredContent,number)} progressCallback\n *   Called inside store() to give progress info back to the app.  It is given\n *   the current manifest being stored and the progress of it being stored.\n * @exportDoc\n */\nshakaExtern.OfflineConfiguration;\n\n\n/**\n * @typedef {{\n *   offlineUri: string,\n *   originalManifestUri: string,\n *   duration: number,\n *   size: number,\n *   tracks: !Array.<shakaExtern.Track>,\n *   appMetadata: Object\n * }}\n *\n * @property {string} offlineUri\n *   An offline URI to access the content.  This can be passed directly to\n *   Player.\n * @property {string} originalManifestUri\n *   The original manifest URI of the content stored.\n * @property {number} duration\n *   The duration of the content, in seconds.\n * @property {number} size\n *   The size of the content, in bytes.\n * @property {!Array.<shakaExtern.Track>} tracks\n *   The tracks that are stored.  This only lists those found in the first\n *   Period.\n * @property {Object} appMetadata\n *   The metadata passed to store().\n * @exportDoc\n */\nshakaExtern.StoredContent;\n\n\n/**\n * @typedef {{\n *   key: number,\n *   originalManifestUri: string,\n *   duration: number,\n *   size: number,\n *   periods: !Array.<shakaExtern.PeriodDB>,\n *   sessionIds: !Array.<string>,\n *   drmInfo: ?shakaExtern.DrmInfo,\n *   appMetadata: Object\n * }}\n *\n * @property {number} key\n *   The key that uniquely identifies the manifest.\n * @property {string} originalManifestUri\n *   The URI that the manifest was originally loaded from.\n * @property {number} duration\n *   The total duration of the media, in seconds.\n * @property {number} size\n *   The total size of all stored segments, in bytes.\n * @property {!Array.<shakaExtern.PeriodDB>} periods\n *   The Periods that are stored.\n * @property {!Array.<string>} sessionIds\n *   The DRM offline session IDs for the media.\n * @property {?shakaExtern.DrmInfo} drmInfo\n *   The DRM info used to initialize EME.\n * @property {Object} appMetadata\n *   A metadata object passed from the application.\n */\nshakaExtern.ManifestDB;\n\n\n/**\n * @typedef {{\n *   startTime: number,\n *   streams: !Array.<shakaExtern.StreamDB>\n * }}\n *\n * @property {number} startTime\n *   The start time of the period, in seconds.\n * @property {!Array.<shakaExtern.StreamDB>} streams\n *   The streams that define the Period.\n */\nshakaExtern.PeriodDB;\n\n\n/**\n * @typedef {{\n *   id: number,\n *   primary: boolean,\n *   presentationTimeOffset: number,\n *   contentType: string,\n *   mimeType: string,\n *   codecs: string,\n *   frameRate: (number|undefined),\n *   kind: (string|undefined),\n *   language: string,\n *   width: ?number,\n *   height: ?number,\n *   initSegmentUri: ?string,\n *   encrypted: boolean,\n *   keyId: ?string,\n *   segments: !Array.<shakaExtern.SegmentDB>\n * }}\n *\n * @property {number} id\n *   The unique id of the stream.\n * @property {boolean} primary\n *   Whether the stream set was primary.\n * @property {number} presentationTimeOffset\n *   The presentation time offset of the stream.\n * @property {string} contentType\n *   The type of the stream, 'audio', 'text', or 'video'.\n * @property {string} mimeType\n *   The MIME type of the stream.\n * @property {string} codecs\n *   The codecs of the stream.\n * @property {(number|undefined)} frameRate\n *   The Stream's framerate in frames per second\n * @property {(string|undefined)} kind\n *   The kind of text stream; undefined for audio/video.\n * @property {string} language\n *   The language of the stream; '' for video.\n * @property {?number} width\n *   The width of the stream; null for audio/text.\n * @property {?number} height\n *   The height of the stream; null for audio/text.\n * @property  {?string} initSegmentUri\n *   The offline URI where the init segment is found; null if no init segment.\n * @property {boolean} encrypted\n *   Whether this stream is encrypted.\n * @property {?string} keyId\n *   The key ID this stream is encrypted with.\n * @property {!Array.<shakaExtern.SegmentDB>} segments\n *   An array of segments that make up the stream\n */\nshakaExtern.StreamDB;\n\n\n/**\n * @typedef {{\n *   startTime: number,\n *   endTime: number,\n *   uri: string\n * }}\n *\n * @property {number} startTime\n *   The start time of the segment, in seconds from the start of the Period.\n * @property {number} endTime\n *   The end time of the segment, in seconds from the start of the Period.\n * @property {string} uri\n *   The offline URI where the segment is found.\n */\nshakaExtern.SegmentDB;\n\n\n/**\n * @typedef {{\n *   key: number,\n *   data: !ArrayBuffer,\n *   manifestKey: number,\n *   streamNumber: number,\n *   segmentNumber: number\n * }}\n *\n * @property {number} key\n *   A key that uniquely describes the segment.\n * @property {!ArrayBuffer} data\n *   The data contents of the segment.\n * @property {number} manifestKey\n *   The key of the manifest this belongs to.\n * @property {number} streamNumber\n *   The index of the stream this belongs to.\n * @property {number} segmentNumber\n *   The index of the segment within the stream.\n */\nshakaExtern.SegmentDataDB;\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/externs/shaka/player.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/** @externs */\n\n\n/**\n * @typedef {{\n *   timestamp: number,\n *   id: number,\n *   type: string,\n *   fromAdaptation: boolean\n * }}\n *\n * @property {number} timestamp\n *   The timestamp the choice was made, in seconds since 1970\n *   (i.e. Date.now() / 1000).\n * @property {number} id\n *   The id of the stream that was chosen.\n * @property {string} type\n *   The type of stream chosen ('audio', 'text', or 'video')\n * @property {boolean} fromAdaptation\n *   True if the choice was made by AbrManager for adaptation; false if it\n *   was made by the application through selectTrack.\n * @exportDoc\n */\nshakaExtern.StreamChoice;\n\n\n/**\n * @typedef {{\n *   width: number,\n *   height: number,\n *   streamBandwidth: number,\n *\n *   decodedFrames: number,\n *   droppedFrames: number,\n *   estimatedBandwidth: number,\n *   playTime: number,\n *   bufferingTime: number,\n *\n *   switchHistory: !Array.<shakaExtern.StreamChoice>\n * }}\n *\n * @description\n * Contains statistics and information about the current state of the player.\n * This is meant for applications that want to log quality-of-experience (QoE)\n * or other stats.  These values will reset when load() is called again.\n *\n * @property {number} width\n *   The width of the current video track.\n * @property {number} height\n *   The height of the current video track.\n * @property {number} streamBandwidth\n *   The bandwidth required for the current streams (total, in bit/sec).\n *\n * @property {number} decodedFrames\n *   The total number of frames decoded by the Player.  This may be NaN if this\n *   is not supported by the browser.\n * @property {number} droppedFrames\n *   The total number of frames dropped by the Player.  This may be NaN if this\n *   is not supported by the browser.\n * @property {number} estimatedBandwidth\n *   The current estimated network bandwidth (in bit/sec).\n * @property {number} playTime\n *   The total time spent in a playing state in seconds.\n * @property {number} bufferingTime\n *   The total time spent in a buffering state in seconds.\n *\n * @property {!Array.<shakaExtern.StreamChoice>} switchHistory\n *   A history of the stream changes.\n * @exportDoc\n */\nshakaExtern.Stats;\n\n\n/**\n * @typedef {{\n *   id: number,\n *   active: boolean,\n *\n *   type: string,\n *   bandwidth: number,\n *\n *   language: string,\n *   kind: ?string,\n *   width: ?number,\n *   height: ?number,\n *   frameRate: ?number,\n *   codecs: ?string\n * }}\n *\n * @description\n * An object describing a media track.  This object should be treated as\n * read-only as changing any values does not have any effect.  This is the\n * public view of the Stream type.\n *\n * @property {number} id\n *   The unique ID of the track.\n * @property {boolean} active\n *   If true, this is the track is being streamed (another track may be\n *   visible/audible in the buffer).\n *\n * @property {string} type\n *   The type of track, one of 'audio', 'text', or 'video'.\n * @property {number} bandwidth\n *   The bandwidth required to play the track, in bits/sec.\n *\n * @property {string} language\n *   The language of the track, or '' for video tracks.  This is the exact\n *   value provided in the manifest; it may need to be normalized.\n * @property {?string} kind\n *   (only for text tracks) The kind of text track, either 'captions' or\n *   'subtitles'.\n * @property {?number} width\n *   (only for video tracks) The width of the track in pixels.\n * @property {?number} height\n *   (only for video tracks) The height of the track in pixels.\n * @property {?number} frameRate\n *   The video framerate provided in the manifest, if present.\n * @property {?string} codecs\n *   The audio/video codecs string provided in the manifest, if present.\n * @exportDoc\n */\nshakaExtern.Track;\n\n\n/**\n * @typedef {{\n *   minWidth: number,\n *   maxWidth: number,\n *   minHeight: number,\n *   maxHeight: number,\n *   minPixels: number,\n *   maxPixels: number,\n *\n *   minAudioBandwidth: number,\n *   maxAudioBandwidth: number,\n *   minVideoBandwidth: number,\n *   maxVideoBandwidth: number\n * }}\n *\n * @description\n * An object describing application restrictions on what tracks can play.  All\n * restrictions must be fulfilled for a track to be playable.  If a track does\n * not meet the restrictions, it will not appear in the track list and it will\n * not be played.\n *\n * @property {number} minWidth\n *   The minimum width of a video track, in pixels.\n * @property {number} maxWidth\n *   The maximum width of a video track, in pixels.\n * @property {number} minHeight\n *   The minimum height of a video track, in pixels.\n * @property {number} maxHeight\n *   The maximum height of a video track, in pixels.\n * @property {number} minPixels\n *   The minimum number of total pixels in a video track (i.e. width * height).\n * @property {number} maxPixels\n *   The maximum number of total pixels in a video track (i.e. width * height).\n *\n * @property {number} minAudioBandwidth\n *   The minimum bandwidth of an audio track, in bit/sec.\n * @property {number} maxAudioBandwidth\n *   The maximum bandwidth of an audio track, in bit/sec.\n * @property {number} minVideoBandwidth\n *   The minimum bandwidth of a video track, in bit/sec.\n * @property {number} maxVideoBandwidth\n *   The maximum bandwidth of a video track, in bit/sec.\n * @exportDoc\n */\nshakaExtern.Restrictions;\n\n\n/**\n * @typedef {{\n *   persistentState: boolean\n * }}\n *\n * @property {boolean} persistentState\n *   Whether this key system supports persistent state.\n */\nshakaExtern.DrmSupportType;\n\n\n/**\n * @typedef {{\n *   manifest: !Object.<string, boolean>,\n *   media: !Object.<string, boolean>,\n *   drm: !Object.<string, ?shakaExtern.DrmSupportType>\n * }}\n *\n * @description\n * An object detailing browser support for various features.\n *\n * @property {!Object.<string, boolean>} manifest\n *   A map of supported manifest types.\n *   The keys are manifest MIME types and file extensions.\n * @property {!Object.<string, boolean>} media\n *   A map of supported media types.\n *   The keys are media MIME types.\n * @property {!Object.<string, ?shakaExtern.DrmSupportType>} drm\n *   A map of supported key systems.\n *   The keys are the key system names.  The value is null if it is not\n *   supported.  Key systems not probed will not be in this dictionary.\n *\n * @exportDoc\n */\nshakaExtern.SupportType;\n\n\n/**\n * @typedef {{\n *   schemeIdUri: string,\n *   value: string,\n *   timescale: number,\n *   presentationTimeDelta: number,\n *   eventDuration: number,\n *   id: number,\n *   messageData: Uint8Array\n * }}\n *\n * @description\n * Contains information about an EMSG MP4 box.\n *\n * @property {string} schemeIdUri\n *    Identifies the message scheme.\n * @property {string} value\n *    Specifies the value for the event.\n * @property {number} timescale\n *    Provides the timescale, in ticks per second,\n *    for the time and duration fields within this box.\n * @property {number} presentationTimeDelta\n *    Provides the Media Presentation time delta of the media presentation\n *    time of the event and the earliest presentation time in this segment.\n * @property {number} eventDuration\n *    Provides the duration of event in media presentation time.\n * @property {number} id\n *    A field identifying this instance of the message.\n * @property {Uint8Array} messageData\n *    Body of the message.\n * @exportDoc\n */\nshakaExtern.EmsgInfo;\n\n\n/**\n * @typedef {function(!Element):Array.<shakaExtern.DrmInfo>}\n * @see shakaExtern.DashManifestConfiguration\n * @exportDoc\n */\nshakaExtern.DashContentProtectionCallback;\n\n\n/**\n * @typedef {{\n *   distinctiveIdentifierRequired: boolean,\n *   persistentStateRequired: boolean,\n *   videoRobustness: string,\n *   audioRobustness: string,\n *   serverCertificate: Uint8Array\n * }}\n *\n * @property {boolean} distinctiveIdentifierRequired\n *   <i>Defaults to false.</i> <br>\n *   True if the application requires the key system to support distinctive\n *   identifiers.\n * @property {boolean} persistentStateRequired\n *   <i>Defaults to false.</i> <br>\n *   True if the application requires the key system to support persistent\n *   state, e.g., for persistent license storage.\n * @property {string} videoRobustness\n *   A key-system-specific string that specifies a required security level for\n *   video.\n *   <i>Defaults to '', i.e., no specific robustness required.</i> <br>\n * @property {string} audioRobustness\n *   A key-system-specific string that specifies a required security level for\n *   audio.\n *   <i>Defaults to '', i.e., no specific robustness required.</i> <br>\n * @property {Uint8Array} serverCertificate\n *   <i>Defaults to null, i.e., certificate will be requested from the license\n *   server if required.</i> <br>\n *   A key-system-specific server certificate used to encrypt license requests.\n *   Its use is optional and is meant as an optimization to avoid a round-trip\n *   to request a certificate.\n *\n * @exportDoc\n */\nshakaExtern.AdvancedDrmConfiguration;\n\n\n/**\n * @typedef {{\n *   retryParameters: shakaExtern.RetryParameters,\n *   servers: !Object.<string, string>,\n *   clearKeys: !Object.<string, string>,\n *   advanced: Object.<string, shakaExtern.AdvancedDrmConfiguration>\n * }}\n *\n * @property {shakaExtern.RetryParameters} retryParameters\n *   Retry parameters for license requests.\n * @property {!Object.<string, string>} servers\n *   <i>Required for all but the clear key CDM.</i> <br>\n *   A dictionary which maps key system IDs to their license servers.\n *   For example, {'com.widevine.alpha': 'http://example.com/drm'}.\n * @property {!Object.<string, string>} clearKeys\n *   <i>Forces the use of the Clear Key CDM.</i>\n *   A map of key IDs (hex) to keys (hex).\n * @property {Object.<string, shakaExtern.AdvancedDrmConfiguration>} advanced\n *   <i>Optional.</i> <br>\n *   A dictionary which maps key system IDs to advanced DRM configuration for\n *   those key systems.\n *\n * @exportDoc\n */\nshakaExtern.DrmConfiguration;\n\n\n/**\n * @typedef {{\n *   customScheme: shakaExtern.DashContentProtectionCallback,\n *   clockSyncUri: string\n * }}\n *\n * @property {shakaExtern.DashContentProtectionCallback} customScheme\n *   If given, invoked by a DASH manifest parser to interpret custom or\n *   non-standard DRM schemes found in the manifest.  The argument is a\n *   ContentProtection node.  Return null if not recognized.\n * @property {string} clockSyncUri\n *   A default clock sync URI to be used with live streams which do not\n *   contain any clock sync information.  The \"Date\" header from this URI\n *   will be used to determine the current time.\n *\n * @exportDoc\n */\nshakaExtern.DashManifestConfiguration;\n\n\n/**\n * @typedef {{\n *   retryParameters: shakaExtern.RetryParameters,\n *   dash: shakaExtern.DashManifestConfiguration\n * }}\n *\n * @property {shakaExtern.RetryParameters} retryParameters\n *   Retry parameters for manifest requests.\n * @property {shakaExtern.DashManifestConfiguration} dash\n *   Advanced parameters used by the DASH manifest parser.\n *\n * @exportDoc\n */\nshakaExtern.ManifestConfiguration;\n\n\n/**\n * @typedef {{\n *   retryParameters: shakaExtern.RetryParameters,\n *   rebufferingGoal: number,\n *   bufferingGoal: number,\n *   bufferBehind: number,\n *   ignoreTextStreamFailures: boolean,\n *   useRelativeCueTimestamps: boolean\n * }}\n *\n * @description\n * The StreamingEngine's configuration options.\n *\n * @property {shakaExtern.RetryParameters} retryParameters\n *   Retry parameters for segment requests.\n * @property {number} rebufferingGoal\n *   The minimum number of seconds of content that the StreamingEngine must\n *   buffer before it can begin playback or can continue playback after it has\n *   entered into a buffering state (i.e., after it has depleted one more\n *   more of its buffers).\n * @property {number} bufferingGoal\n *   The number of seconds of content that the StreamingEngine will attempt to\n *   buffer ahead of the playhead. This value must be greater than or equal to\n *   the rebuffering goal.\n * @property {number} bufferBehind\n *   The maximum number of seconds of content that the StreamingEngine will keep\n *   in buffer behind the playhead when it appends a new media segment.\n *   The StreamingEngine will evict content to meet this limit.\n * @property {boolean} ignoreTextStreamFailures\n *   If true, the player will ignore text stream failures and proceed to play\n *   other streams.\n * @property {boolean} useRelativeCueTimestamps\n *   If true, WebVTT cue timestamps will be treated as relative to the start\n *   time of the VTT segment. Defaults to false.\n * @exportDoc\n */\nshakaExtern.StreamingConfiguration;\n\n\n/**\n * @typedef {{\n *   manager: shakaExtern.AbrManager,\n *   enabled: boolean,\n *   defaultBandwidthEstimate: number\n * }}\n *\n * @property {shakaExtern.AbrManager} manager\n *   The AbrManager instance.\n * @property {boolean} enabled\n *   If true, enable adaptation by the current AbrManager.  Defaults to true.\n * @property {number} defaultBandwidthEstimate\n *   The default bandwidth estimate to use if there is not enough data, in\n *   bit/sec.\n * @exportDoc\n */\nshakaExtern.AbrConfiguration;\n\n\n/**\n * @typedef {{\n *   drm: shakaExtern.DrmConfiguration,\n *   manifest: shakaExtern.ManifestConfiguration,\n *   streaming: shakaExtern.StreamingConfiguration,\n *   abr: shakaExtern.AbrConfiguration,\n *   preferredAudioLanguage: string,\n *   preferredTextLanguage: string,\n *   restrictions: shakaExtern.Restrictions\n * }}\n *\n * @property {shakaExtern.DrmConfiguration} drm\n *   DRM configuration and settings.\n * @property {shakaExtern.ManifestConfiguration} manifest\n *   Manifest configuration and settings.\n * @property {shakaExtern.StreamingConfiguration} streaming\n *   Streaming configuration and settings.\n * @property {shakaExtern.AbrConfiguration} abr\n *   ABR configuration and settings.\n * @property {string} preferredAudioLanguage\n *   The preferred language to use for audio tracks.  If not given it will use\n *   the 'main' track.\n *   Changing this during playback will cause the language selection algorithm\n *   to run again, and may change the active audio track.\n * @property {string} preferredTextLanguage\n *   The preferred language to use for text tracks.  If a matching text track\n *   is found, and the selected audio and text tracks have different languages,\n *   the text track will be shown.\n *   Changing this during playback will cause the language selection algorithm\n *   to run again, and may change the active text track.\n * @property {shakaExtern.Restrictions} restrictions\n *   The application restrictions to apply to the tracks.  The track must\n *   meet all the restrictions to be playable.\n * @exportDoc\n */\nshakaExtern.PlayerConfiguration;\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/externs/shaka/text.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/** @externs */\n\n\n/**\n * Parses a text buffer into an array of cues.\n *\n * @typedef {function(ArrayBuffer, number, ?number,\n *                    ?number, boolean):!Array.<!TextTrackCue>}\n * @exportDoc\n */\nshakaExtern.TextParserPlugin;\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/abr/ewma_bandwidth_estimator.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.abr.EwmaBandwidthEstimator');\n\ngoog.require('shaka.abr.Ewma');\n\n\n\n/**\n * Tracks bandwidth samples and estimates available bandwidth.\n * Based on the minimum of two exponentially-weighted moving averages with\n * different half-lives.\n *\n * @constructor\n * @struct\n */\nshaka.abr.EwmaBandwidthEstimator = function() {\n  /**\n   * A fast-moving average.\n   * Half of the estimate is based on the last 2 seconds of sample history.\n   * @private {!shaka.abr.Ewma}\n   */\n  this.fast_ = new shaka.abr.Ewma(2);\n\n  /**\n   * A slow-moving average.\n   * Half of the estimate is based on the last 5 seconds of sample history.\n   * @private {!shaka.abr.Ewma}\n   */\n  this.slow_ = new shaka.abr.Ewma(5);\n\n  /**\n   * Number of bytes sampled.\n   * @private {number}\n   */\n  this.bytesSampled_ = 0;\n\n  /**\n   * Initial estimate used when there is not enough data.\n   * @see shaka.abr.EwmaBandwidthEstimator.DEFAULT_ESTIMATE\n   * @private {number}\n   */\n  this.defaultEstimate_ = shaka.abr.EwmaBandwidthEstimator.DEFAULT_ESTIMATE;\n\n  /**\n   * Minimum number of bytes sampled before we trust the estimate.  If we have\n   * not sampled much data, our estimate may not be accurate enough to trust.\n   * If bytesSampled_ is less than minTotalBytes_, we use defaultEstimate_.\n   * This specific value is based on experimentation.\n   *\n   * @private {number}\n   * @const\n   */\n  this.minTotalBytes_ = 128e3;  // 128kB\n\n  /**\n   * Minimum number of bytes, under which samples are discarded.  Our models do\n   * not include latency information, so connection startup time (time to first\n   * byte) is considered part of the download time.  Because of this, we should\n   * ignore very small downloads which would cause our estimate to be too low.\n   * This specific value is based on experimentation.\n   *\n   * @private {number}\n   * @const\n   */\n  this.minBytes_ = 16e3;  // 16kB\n};\n\n\n/**\n * Contains the default estimate to use when there is not enough data.\n * This is a relatively safe default, since 3G cell connections are faster than\n * this.  For slower connections, such as 2G, the default estimate may be too\n * high.  This default can be changed at runtime using\n * {@link shaka.Player#configure} and {@link shakaExtern.AbrConfiguration}.\n * @const {number}\n */\nshaka.abr.EwmaBandwidthEstimator.DEFAULT_ESTIMATE = 500e3;  // 500kbps\n\n\n/**\n * Takes a bandwidth sample.\n *\n * @param {number} durationMs The amount of time, in milliseconds, for a\n *   particular request.\n * @param {number} numBytes The total number of bytes transferred in that\n *   request.\n */\nshaka.abr.EwmaBandwidthEstimator.prototype.sample = function(\n    durationMs, numBytes) {\n  if (numBytes < this.minBytes_) {\n    return;\n  }\n\n  var bandwidth = 8000 * numBytes / durationMs;\n  var weight = durationMs / 1000;\n\n  this.bytesSampled_ += numBytes;\n  this.fast_.sample(weight, bandwidth);\n  this.slow_.sample(weight, bandwidth);\n};\n\n\n/**\n * Sets the default bandwidth estimate to use if there is not enough data.\n *\n * @param {number} estimate The default bandwidth estimate, in bit/sec.\n */\nshaka.abr.EwmaBandwidthEstimator.prototype.setDefaultEstimate = function(\n    estimate) {\n  this.defaultEstimate_ = estimate;\n};\n\n\n/**\n * Gets the current bandwidth estimate.\n *\n * @return {number} The bandwidth estimate in bits per second.\n */\nshaka.abr.EwmaBandwidthEstimator.prototype.getBandwidthEstimate = function() {\n  if (this.bytesSampled_ < this.minTotalBytes_) {\n    return this.defaultEstimate_;\n  }\n\n  // Take the minimum of these two estimates.  This should have the effect of\n  // adapting down quickly, but up more slowly.\n  return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());\n};\n\n\n/**\n * @return {boolean} True if there is enough data to produce a meaningful\n *   estimate.\n */\nshaka.abr.EwmaBandwidthEstimator.prototype.hasGoodEstimate = function() {\n  return this.bytesSampled_ >= this.minTotalBytes_;\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/abr/ewma.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.abr.Ewma');\n\ngoog.require('goog.asserts');\n\n\n\n/**\n * Computes an exponentionally-weighted moving average.\n *\n * @param {number} halfLife About half of the estimated value will be from the\n *   last |halfLife| samples by weight.\n * @struct\n * @constructor\n */\nshaka.abr.Ewma = function(halfLife) {\n  goog.asserts.assert(halfLife > 0, 'expected halfLife to be positive');\n\n  /**\n   * Larger values of alpha expire historical data more slowly.\n   * @private {number}\n   */\n  this.alpha_ = Math.exp(Math.log(0.5) / halfLife);\n\n  /** @private {number} */\n  this.estimate_ = 0;\n\n  /** @private {number} */\n  this.totalWeight_ = 0;\n};\n\n\n/**\n * Takes a sample.\n *\n * @param {number} weight\n * @param {number} value\n */\nshaka.abr.Ewma.prototype.sample = function(weight, value) {\n  var adjAlpha = Math.pow(this.alpha_, weight);\n  var newEstimate = value * (1 - adjAlpha) + adjAlpha * this.estimate_;\n\n  if (!isNaN(newEstimate)) {\n    this.estimate_ = newEstimate;\n    this.totalWeight_ += weight;\n  }\n};\n\n\n/**\n * @return {number}\n */\nshaka.abr.Ewma.prototype.getEstimate = function() {\n  var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);\n  return this.estimate_ / zeroFactor;\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/abr/simple_abr_manager.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.abr.SimpleAbrManager');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.abr.EwmaBandwidthEstimator');\ngoog.require('shaka.log');\n\n\n\n/**\n * Creates a new SimpleAbrManager.\n *\n * @constructor\n * @struct\n * @implements {shakaExtern.AbrManager}\n * @export\n */\nshaka.abr.SimpleAbrManager = function() {\n  /** @private {?shakaExtern.AbrManager.SwitchCallback} */\n  this.switch_ = null;\n\n  /** @private {boolean} */\n  this.enabled_ = false;\n\n  /** @private {shaka.abr.EwmaBandwidthEstimator} */\n  this.bandwidthEstimator_ = new shaka.abr.EwmaBandwidthEstimator();\n\n  /**\n   * The last StreamSets given to us via chooseStreams().\n   * @private {Object.<string, shakaExtern.StreamSet>}\n   */\n  this.streamSetsByType_ = {};\n\n  /**\n   * The last Streams chosen.\n   * @private {Object.<string, shakaExtern.Stream>}\n   */\n  this.streamsByType_ = {};\n\n  /** @private {boolean} */\n  this.startupComplete_ = false;\n\n  /**\n   * The last wall-clock time, in milliseconds, when Streams were chosen via\n   * chooseStreams() or switch_().\n   *\n   * @private {?number}\n   */\n  this.lastTimeChosenMs_ = null;\n};\n\n\n/**\n * The minimum amount of time that must pass between switches, in milliseconds.\n * This keeps us from changing too often and annoying the user.\n *\n * @const {number}\n */\nshaka.abr.SimpleAbrManager.SWITCH_INTERVAL_MS = 8000;\n\n\n/**\n * The fraction of the estimated bandwidth which we should try to use when\n * upgrading.\n *\n * @private\n * @const {number}\n */\nshaka.abr.SimpleAbrManager.BANDWIDTH_UPGRADE_TARGET_ = 0.85;\n\n\n/**\n * The largest fraction of the estimated bandwidth we should use. We should\n * downgrade to avoid this.\n *\n * @private\n * @const {number}\n */\nshaka.abr.SimpleAbrManager.BANDWIDTH_DOWNGRADE_TARGET_ = 0.95;\n\n\n/**\n * @override\n * @export\n */\nshaka.abr.SimpleAbrManager.prototype.stop = function() {\n  this.switch_ = null;\n  this.enabled_ = false;\n  this.streamSetsByType_ = {};\n  this.streamsByType_ = {};\n  this.lastTimeChosenMs_ = null;\n\n  // Don't reset |startupComplete_|: if we've left the startup interval then we\n  // can start using bandwidth estimates right away if init() is called again.\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.abr.SimpleAbrManager.prototype.init = function(switchCallback) {\n  this.switch_ = switchCallback;\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.abr.SimpleAbrManager.prototype.chooseStreams = function(\n    streamSetsByType) {\n  // Merge StreamSets.  We may have been given a partial list.\n  for (var type in streamSetsByType) {\n    this.streamSetsByType_[type] = streamSetsByType[type];\n  }\n\n  // Choose streams for the specific types requested.\n  var chosen = {};\n\n  if ('audio' in streamSetsByType) {\n    var audioStream = this.chooseAudioStream_();\n    if (audioStream) {\n      chosen['audio'] = audioStream;\n      this.streamsByType_['audio'] = audioStream;\n    } else {\n      delete this.streamsByType_['audio'];\n    }\n  }\n\n  if ('video' in streamSetsByType) {\n    var videoStream = this.chooseVideoStream_();\n    if (videoStream) {\n      chosen['video'] = videoStream;\n      this.streamsByType_['video'] = videoStream;\n    } else {\n      delete this.streamsByType_['video'];\n    }\n  }\n\n  if ('text' in streamSetsByType) {\n    // We don't adapt text, so just choose stream 0.\n    chosen['text'] = streamSetsByType['text'].streams[0];\n  }\n\n  this.lastTimeChosenMs_ = Date.now();\n  return chosen;\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.abr.SimpleAbrManager.prototype.enable = function() {\n  this.enabled_ = true;\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.abr.SimpleAbrManager.prototype.disable = function() {\n  this.enabled_ = false;\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.abr.SimpleAbrManager.prototype.segmentDownloaded = function(\n    startTimeMs, endTimeMs, numBytes) {\n  shaka.log.v2('Segment downloaded:',\n               'startTimeMs=' + startTimeMs,\n               'endTimeMs=' + endTimeMs,\n               'numBytes=' + numBytes);\n  goog.asserts.assert(endTimeMs >= startTimeMs,\n                      'expected a non-negative duration');\n  this.bandwidthEstimator_.sample(endTimeMs - startTimeMs, numBytes);\n\n  if ((this.lastTimeChosenMs_ != null) && this.enabled_)\n    this.suggestStreams_();\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.abr.SimpleAbrManager.prototype.getBandwidthEstimate = function() {\n  return this.bandwidthEstimator_.getBandwidthEstimate();\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.abr.SimpleAbrManager.prototype.setDefaultEstimate = function(estimate) {\n  this.bandwidthEstimator_.setDefaultEstimate(estimate);\n};\n\n\n/**\n * Calls switch_() with which Streams to switch to.\n *\n * @private\n */\nshaka.abr.SimpleAbrManager.prototype.suggestStreams_ = function() {\n  shaka.log.v2('Suggesting Streams...');\n  goog.asserts.assert(this.lastTimeChosenMs_ != null,\n                      'lastTimeChosenMs_ should not be null');\n\n  if (!this.startupComplete_) {\n    // Check if we've got enough data yet.\n    if (!this.bandwidthEstimator_.hasGoodEstimate()) {\n      shaka.log.v2('Still waiting for a good estimate...');\n      return;\n    }\n    this.startupComplete_ = true;\n  } else {\n    // Check if we've left the switch interval.\n    var now = Date.now();\n    var delta = now - this.lastTimeChosenMs_;\n    if (delta < shaka.abr.SimpleAbrManager.SWITCH_INTERVAL_MS) {\n      shaka.log.v2('Still within switch interval...');\n      return;\n    }\n  }\n\n  var chosen = this.chooseStreams_();\n  var currentBandwidthKbps =\n      Math.round(this.bandwidthEstimator_.getBandwidthEstimate() / 1000.0);\n  shaka.log.debug(\n      'Calling switch_(), bandwidth=' + currentBandwidthKbps + ' kbps');\n  // If any of these chosen streams are already chosen, Player will filter them\n  // out before passing the choices on to StreamingEngine.\n  this.switch_(chosen);\n};\n\n\n/**\n * Chooses which Streams to switch to.\n *\n * @return {!Object.<string, !shakaExtern.Stream>}\n * @private\n */\nshaka.abr.SimpleAbrManager.prototype.chooseStreams_ = function() {\n  var streamsByType = {};\n\n  // Choose audio Stream.\n  var audioStream = this.chooseAudioStream_();\n  if (audioStream) {\n    streamsByType['audio'] = audioStream;\n    this.streamsByType_['audio'] = audioStream;\n  }\n\n  // Choose video Stream.\n  var videoStream = this.chooseVideoStream_();\n  if (videoStream) {\n    streamsByType['video'] = videoStream;\n    this.streamsByType_['video'] = videoStream;\n  }\n\n  this.lastTimeChosenMs_ = Date.now();\n  return streamsByType;\n};\n\n\n/**\n * Chooses which audio Stream to switch to.\n *\n * @return {?shakaExtern.Stream}\n * @private\n */\nshaka.abr.SimpleAbrManager.prototype.chooseAudioStream_ = function() {\n  // Alias.\n  var SimpleAbrManager = shaka.abr.SimpleAbrManager;\n\n  // Get sorted audio Streams.\n  var audioStreamSet = this.streamSetsByType_['audio'];\n  if (!audioStreamSet)\n    return null;\n  var audioStreams = SimpleAbrManager.sortStreamsByBandwidth_(audioStreamSet);\n\n  // Just pick the middle one.\n  // TODO: Implement better audio adaptation.\n  return audioStreams[Math.floor(audioStreams.length / 2)];\n};\n\n\n/**\n * Chooses which video Stream to switch to.\n *\n * @return {?shakaExtern.Stream}\n * @private\n */\nshaka.abr.SimpleAbrManager.prototype.chooseVideoStream_ = function() {\n  // Alias.\n  var SimpleAbrManager = shaka.abr.SimpleAbrManager;\n\n  // Get sorted video Streams.\n  var videoStreamSet = this.streamSetsByType_['video'];\n  if (!videoStreamSet)\n    return null;\n  var videoStreams = SimpleAbrManager.sortStreamsByBandwidth_(videoStreamSet);\n\n  var audioStream = this.streamsByType_['audio'];\n  var audioBandwidth = (audioStream && audioStream.bandwidth) || 0;\n  var currentBandwidth = this.bandwidthEstimator_.getBandwidthEstimate();\n\n  // Start by assuming that we will use the first Stream.\n  var chosen = videoStreams[0];\n\n  for (var i = 0; i < videoStreams.length; ++i) {\n    var stream = videoStreams[i];\n    var nextStream = (i + 1 < videoStreams.length) ?\n                     videoStreams[i + 1] :\n                     {bandwidth: Infinity};\n\n    // Ignore Streams which don't have bandwidth information.\n    if (!stream.bandwidth) continue;\n\n    var minBandwidth = (stream.bandwidth + audioBandwidth) /\n                       SimpleAbrManager.BANDWIDTH_DOWNGRADE_TARGET_;\n    var maxBandwidth = (nextStream.bandwidth + audioBandwidth) /\n                       SimpleAbrManager.BANDWIDTH_UPGRADE_TARGET_;\n    shaka.log.v2('Bandwidth ranges:',\n                 ((stream.bandwidth + audioBandwidth) / 1e6).toFixed(3),\n                 (minBandwidth / 1e6).toFixed(3),\n                 (maxBandwidth / 1e6).toFixed(3));\n\n    if (currentBandwidth >= minBandwidth && currentBandwidth <= maxBandwidth)\n      chosen = stream;\n  }\n\n  return chosen;\n};\n\n\n/**\n * @param {!shakaExtern.StreamSet} streamSet\n * @return {!Array.<shakaExtern.Stream>} |streamSet|'s Streams sorted\n *   in ascending order of bandwidth.\n * @private\n */\nshaka.abr.SimpleAbrManager.sortStreamsByBandwidth_ = function(streamSet) {\n  return streamSet.streams.slice(0)\n      .filter(function(s) {\n        return s.allowedByApplication && s.allowedByKeySystem;\n      })\n      .sort(function(s1, s2) { return s1.bandwidth - s2.bandwidth; });\n};\n\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/cast/cast_proxy.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.cast.CastProxy');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.cast.CastSender');\ngoog.require('shaka.cast.CastUtils');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.IDestroyable');\n\n\n\n/**\n * A proxy to switch between local and remote playback for Chromecast in a way\n * that is transparent to the app's controls.\n *\n * @constructor\n * @struct\n * @param {!HTMLMediaElement} video The local video element associated with the\n *   local Player instance.\n * @param {!shaka.Player} player A local Player instance.\n * @param {string} receiverAppId The ID of the cast receiver application.\n * @implements {shaka.util.IDestroyable}\n * @extends {shaka.util.FakeEventTarget}\n * @export\n */\nshaka.cast.CastProxy = function(video, player, receiverAppId) {\n  shaka.util.FakeEventTarget.call(this);\n\n  /** @private {HTMLMediaElement} */\n  this.localVideo_ = video;\n\n  /** @private {shaka.Player} */\n  this.localPlayer_ = player;\n\n  /** @private {Object} */\n  this.videoProxy_ = null;\n\n  /** @private {Object} */\n  this.playerProxy_ = null;\n\n  /** @private {shaka.util.FakeEventTarget} */\n  this.videoEventTarget_ = null;\n\n  /** @private {shaka.util.FakeEventTarget} */\n  this.playerEventTarget_ = null;\n\n  /** @private {shaka.util.EventManager} */\n  this.eventManager_ = null;\n\n  /** @private {shaka.cast.CastSender} */\n  this.sender_ = new shaka.cast.CastSender(\n      receiverAppId,\n      this.onCastStatusChanged_.bind(this),\n      this.onRemoteEvent_.bind(this),\n      this.onResumeLocal_.bind(this),\n      this.getInitState_.bind(this));\n\n  this.init_();\n};\ngoog.inherits(shaka.cast.CastProxy, shaka.util.FakeEventTarget);\n\n\n/**\n * Destroys the proxy and the underlying local Player.\n *\n * @override\n * @export\n */\nshaka.cast.CastProxy.prototype.destroy = function() {\n  var async = [\n    this.eventManager_ ? this.eventManager_.destroy() : null,\n    this.localPlayer_ ? this.localPlayer_.destroy() : null,\n    this.sender_ ? this.sender_.destroy() : null\n  ];\n\n  this.localVideo_ = null;\n  this.localPlayer_ = null;\n  this.videoProxy_ = null;\n  this.playerProxy_ = null;\n  this.eventManager_ = null;\n  this.sender_ = null;\n\n  return Promise.all(async);\n};\n\n\n/**\n * @event shaka.cast.CastProxy.CastStatusChangedEvent\n * @description Fired when cast status changes.  The status change will be\n *   reflected in canCast() and isCasting().\n * @property {string} type\n *   'caststatuschanged'\n * @exportDoc\n */\n\n\n/**\n * Get a proxy for the video element that delegates to local and remote video\n * elements as appropriate.\n *\n * @suppress {invalidCasts} to cast proxy Objects to unrelated types\n * @return {HTMLMediaElement}\n * @export\n */\nshaka.cast.CastProxy.prototype.getVideo = function() {\n  return /** @type {HTMLMediaElement} */(this.videoProxy_);\n};\n\n\n/**\n * Get a proxy for the Player that delegates to local and remote Player objects\n * as appropriate.\n *\n * @suppress {invalidCasts} to cast proxy Objects to unrelated types\n * @return {shaka.Player}\n * @export\n */\nshaka.cast.CastProxy.prototype.getPlayer = function() {\n  return /** @type {shaka.Player} */(this.playerProxy_);\n};\n\n\n/**\n * @return {boolean} True if the cast API is available and there are receivers.\n * @export\n */\nshaka.cast.CastProxy.prototype.canCast = function() {\n  return this.sender_ ?\n      this.sender_.apiReady() && this.sender_.hasReceivers() :\n      false;\n};\n\n\n/**\n * @return {boolean} True if we are currently casting.\n * @export\n */\nshaka.cast.CastProxy.prototype.isCasting = function() {\n  return this.sender_ ? this.sender_.isCasting() : false;\n};\n\n\n/**\n * @return {string} The name of the Cast receiver device, if isCasting().\n * @export\n */\nshaka.cast.CastProxy.prototype.receiverName = function() {\n  return this.sender_ ? this.sender_.receiverName() : '';\n};\n\n\n/**\n * @return {!Promise} Resolved when connected to a receiver.  Rejected if the\n *   connection fails or is canceled by the user.\n * @export\n */\nshaka.cast.CastProxy.prototype.cast = function() {\n  var initState = this.getInitState_();\n\n  // TODO: transfer manually-selected tracks?\n  // TODO: transfer side-loaded text tracks?\n\n  return this.sender_.cast(initState).then(function() {\n    // Unload the local manifest when casting succeeds.\n    return this.localPlayer_.unload();\n  }.bind(this));\n};\n\n\n/**\n * Set application-specific data.\n *\n * @param {Object} appData Application-specific data to relay to the receiver.\n * @export\n */\nshaka.cast.CastProxy.prototype.setAppData = function(appData) {\n  this.sender_.setAppData(appData);\n};\n\n\n/**\n * Show a dialog where user can choose to disconnect from the cast connection.\n * @export\n */\nshaka.cast.CastProxy.prototype.suggestDisconnect = function() {\n  this.sender_.showDisconnectDialog();\n};\n\n\n/**\n * Initialize the Proxies and the Cast sender.\n * @private\n */\nshaka.cast.CastProxy.prototype.init_ = function() {\n  this.sender_.init();\n\n  this.eventManager_ = new shaka.util.EventManager();\n\n  shaka.cast.CastUtils.VideoEvents.forEach(function(name) {\n    this.eventManager_.listen(this.localVideo_, name,\n        this.videoProxyLocalEvent_.bind(this));\n  }.bind(this));\n\n  shaka.cast.CastUtils.PlayerEvents.forEach(function(name) {\n    this.eventManager_.listen(this.localPlayer_, name,\n        this.playerProxyLocalEvent_.bind(this));\n  }.bind(this));\n\n  // We would like to use Proxy here, but it is not supported on IE11 or Safari.\n  this.videoProxy_ = {};\n  for (var k in this.localVideo_) {\n    Object.defineProperty(this.videoProxy_, k, {\n      configurable: false,\n      enumerable: true,\n      get: this.videoProxyGet_.bind(this, k),\n      set: this.videoProxySet_.bind(this, k)\n    });\n  }\n\n  this.playerProxy_ = {};\n  for (var k in /** @type {Object} */(this.localPlayer_)) {\n    Object.defineProperty(this.playerProxy_, k, {\n      configurable: false,\n      enumerable: true,\n      get: this.playerProxyGet_.bind(this, k)\n    });\n  }\n\n  this.videoEventTarget_ = new shaka.util.FakeEventTarget();\n  this.videoEventTarget_.dispatchTarget =\n      /** @type {EventTarget} */(this.videoProxy_);\n\n  this.playerEventTarget_ = new shaka.util.FakeEventTarget();\n  this.playerEventTarget_.dispatchTarget =\n      /** @type {EventTarget} */(this.playerProxy_);\n};\n\n\n/**\n * @return {shaka.cast.CastUtils.InitStateType} initState Video and player state\n *   to be sent to the receiver.\n * @private\n */\nshaka.cast.CastProxy.prototype.getInitState_ = function() {\n  var initState = {\n    'video': {},\n    'player': {},\n    'playerAfterLoad': {},\n    'manifest': this.localPlayer_.getManifestUri(),\n    'startTime': null\n  };\n\n  // Pause local playback before capturing state.\n  this.localVideo_.pause();\n\n  shaka.cast.CastUtils.VideoInitStateAttributes.forEach(function(name) {\n    initState['video'][name] = this.localVideo_[name];\n  }.bind(this));\n\n  // If the video is still playing, set the startTime.\n  // Has no effect if nothing is loaded.\n  if (!this.localVideo_.ended) {\n    initState['startTime'] = this.localVideo_.currentTime;\n  }\n\n  shaka.cast.CastUtils.PlayerInitState.forEach(function(pair) {\n    var getter = pair[0];\n    var setter = pair[1];\n    var value = /** @type {Object} */(this.localPlayer_)[getter]();\n\n    initState['player'][setter] = value;\n  }.bind(this));\n\n  shaka.cast.CastUtils.PlayerInitAfterLoadState.forEach(function(pair) {\n    var getter = pair[0];\n    var setter = pair[1];\n    var value = /** @type {Object} */(this.localPlayer_)[getter]();\n\n    initState['playerAfterLoad'][setter] = value;\n  }.bind(this));\n\n  return initState;\n};\n\n\n/**\n * Dispatch an event to notify the app that the status has changed.\n * @private\n */\nshaka.cast.CastProxy.prototype.onCastStatusChanged_ = function() {\n  var event = new shaka.util.FakeEvent('caststatuschanged');\n  this.dispatchEvent(event);\n};\n\n\n/**\n * Transfer remote state back and resume local playback.\n * @private\n */\nshaka.cast.CastProxy.prototype.onResumeLocal_ = function() {\n  // Transfer back the player state.\n  shaka.cast.CastUtils.PlayerInitState.forEach(function(pair) {\n    var getter = pair[0];\n    var setter = pair[1];\n    var value = this.sender_.get('player', getter)();\n    /** @type {Object} */(this.localPlayer_)[setter](value);\n  }.bind(this));\n\n  // Get the most recent manifest URI and ended state.\n  var manifestUri = this.sender_.get('player', 'getManifestUri')();\n  var ended = this.sender_.get('video', 'ended');\n\n  var manifestReady = Promise.resolve();\n  var autoplay = this.localVideo_.autoplay;\n\n  var startTime = null;\n\n  // If the video is still playing, set the startTime.\n  // Has no effect if nothing is loaded.\n  if (!ended) {\n    startTime = this.sender_.get('video', 'currentTime');\n  }\n\n  // Now load the manifest, if present.\n  if (manifestUri) {\n    // Don't autoplay the content until we finish setting up initial state.\n    this.localVideo_.autoplay = false;\n    manifestReady = this.localPlayer_.load(manifestUri, startTime);\n    // Pass any errors through to the app.\n    manifestReady.catch(function(error) {\n      goog.asserts.assert(error instanceof shaka.util.Error,\n                          'Wrong error type!');\n      var event = new shaka.util.FakeEvent('error', { 'detail': error });\n      this.localPlayer_.dispatchEvent(event);\n    }.bind(this));\n  }\n\n  // Get the video state into a temp variable since we will apply it async.\n  var videoState = {};\n  shaka.cast.CastUtils.VideoInitStateAttributes.forEach(function(name) {\n    videoState[name] = this.sender_.get('video', name);\n  }.bind(this));\n\n  // Finally, take on video state and player's \"after load\" state.\n  manifestReady.then(function() {\n    shaka.cast.CastUtils.VideoInitStateAttributes.forEach(function(name) {\n      this.localVideo_[name] = videoState[name];\n    }.bind(this));\n\n    shaka.cast.CastUtils.PlayerInitAfterLoadState.forEach(function(pair) {\n      var getter = pair[0];\n      var setter = pair[1];\n      var value = this.sender_.get('player', getter)();\n      /** @type {Object} */(this.localPlayer_)[setter](value);\n    }.bind(this));\n\n    // Restore original autoplay setting.\n    this.localVideo_.autoplay = autoplay;\n    if (manifestUri) {\n      // Resume playback with transferred state.\n      this.localVideo_.play();\n    }\n  }.bind(this));\n};\n\n\n/**\n * @param {string} name\n * @return {?}\n * @private\n */\nshaka.cast.CastProxy.prototype.videoProxyGet_ = function(name) {\n  if (name == 'addEventListener') {\n    return this.videoEventTarget_.addEventListener.bind(\n        this.videoEventTarget_);\n  }\n  if (name == 'removeEventListener') {\n    return this.videoEventTarget_.removeEventListener.bind(\n        this.videoEventTarget_);\n  }\n\n  // If we are casting, but the first update has not come in yet, use local\n  // values, but not local methods.\n  if (this.sender_.isCasting() && !this.sender_.hasRemoteProperties()) {\n    var value = this.localVideo_[name];\n    if (typeof value != 'function') {\n      return value;\n    }\n  }\n\n  // Use local values and methods if we are not casting.\n  if (!this.sender_.isCasting()) {\n    var value = this.localVideo_[name];\n    if (typeof value == 'function') {\n      value = value.bind(this.localVideo_);\n    }\n    return value;\n  }\n\n  return this.sender_.get('video', name);\n};\n\n\n/**\n * @param {string} name\n * @param {?} value\n * @private\n */\nshaka.cast.CastProxy.prototype.videoProxySet_ = function(name, value) {\n  if (!this.sender_.isCasting()) {\n    this.localVideo_[name] = value;\n    return;\n  }\n\n  this.sender_.set('video', name, value);\n};\n\n\n/**\n * @param {!Event} event\n * @private\n */\nshaka.cast.CastProxy.prototype.videoProxyLocalEvent_ = function(event) {\n  if (this.sender_.isCasting()) {\n    // Ignore any unexpected local events while casting.  Events can still be\n    // fired by the local video and Player when we unload() after the Cast\n    // connection is complete.\n    return;\n  }\n\n  // Convert this real Event into a FakeEvent for dispatch from our\n  // FakeEventListener.\n  var fakeEvent = new shaka.util.FakeEvent(event.type, event);\n  this.videoEventTarget_.dispatchEvent(fakeEvent);\n};\n\n\n/**\n * @param {string} name\n * @return {?}\n * @private\n */\nshaka.cast.CastProxy.prototype.playerProxyGet_ = function(name) {\n  if (name == 'addEventListener') {\n    return this.playerEventTarget_.addEventListener.bind(\n        this.playerEventTarget_);\n  }\n  if (name == 'removeEventListener') {\n    return this.playerEventTarget_.removeEventListener.bind(\n        this.playerEventTarget_);\n  }\n\n  if (name == 'getNetworkingEngine') {\n    // Always returns a local instance, in case you need to make a request.\n    // Issues a warning, in case you think you are making a remote request\n    // or affecting remote filters.\n    if (this.sender_.isCasting()) {\n      shaka.log.warning('NOTE: getNetworkingEngine() is always local!');\n    }\n    return this.localPlayer_.getNetworkingEngine.bind(this.localPlayer_);\n  }\n\n  // If we are casting, but the first update has not come in yet, use local\n  // getters, but not local methods.\n  if (this.sender_.isCasting() && !this.sender_.hasRemoteProperties()) {\n    if (shaka.cast.CastUtils.PlayerGetterMethods.indexOf(name) >= 0) {\n      var value = /** @type {Object} */(this.localPlayer_)[name];\n      goog.asserts.assert(typeof value == 'function', 'only methods on Player');\n      return value.bind(this.localPlayer_);\n    }\n  }\n\n  // Use local getters and methods if we are not casting.\n  if (!this.sender_.isCasting()) {\n    var value = /** @type {Object} */(this.localPlayer_)[name];\n    goog.asserts.assert(typeof value == 'function', 'only methods on Player');\n    return value.bind(this.localPlayer_);\n  }\n\n  return this.sender_.get('player', name);\n};\n\n\n/**\n * @param {!Event} event\n * @private\n */\nshaka.cast.CastProxy.prototype.playerProxyLocalEvent_ = function(event) {\n  if (this.sender_.isCasting()) {\n    // Ignore any unexpected local events while casting.\n    return;\n  }\n\n  this.playerEventTarget_.dispatchEvent(event);\n};\n\n\n/**\n * @param {string} targetName\n * @param {!shaka.util.FakeEvent} event\n * @private\n */\nshaka.cast.CastProxy.prototype.onRemoteEvent_ = function(targetName, event) {\n  goog.asserts.assert(this.sender_.isCasting(),\n                      'Should only receive remote events while casting');\n  if (!this.sender_.isCasting()) {\n    // Ignore any unexpected remote events.\n    return;\n  }\n\n  if (targetName == 'video') {\n    this.videoEventTarget_.dispatchEvent(event);\n  } else if (targetName == 'player') {\n    this.playerEventTarget_.dispatchEvent(event);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/cast/cast_receiver.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.cast.CastReceiver');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.cast.CastUtils');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.IDestroyable');\n\n\n\n/**\n * A receiver to communicate between the Chromecast-hosted player and the\n * sender application.\n *\n * @constructor\n * @struct\n * @param {!HTMLMediaElement} video The local video element associated with the\n *   local Player instance.\n * @param {!shaka.Player} player A local Player instance.\n * @param {function(Object)=} opt_appDataCallback A callback to handle\n *   application-specific data passed from the sender.\n * @implements {shaka.util.IDestroyable}\n * @extends {shaka.util.FakeEventTarget}\n * @export\n */\nshaka.cast.CastReceiver = function(video, player, opt_appDataCallback) {\n  shaka.util.FakeEventTarget.call(this);\n\n  /** @private {HTMLMediaElement} */\n  this.video_ = video;\n\n  /** @private {shaka.Player} */\n  this.player_ = player;\n\n  /** @private {Object} */\n  this.targets_ = {\n    'video': video,\n    'player': player\n  };\n\n  /** @private {?function(Object)} */\n  this.appDataCallback_ = opt_appDataCallback || function() {};\n\n  /** @private {boolean} */\n  this.isConnected_ = false;\n\n  /** @private {boolean} */\n  this.isIdle_ = true;\n\n  /** @private {cast.receiver.CastMessageBus} */\n  this.bus_ = null;\n\n  /** @private {?number} */\n  this.pollTimerId_ = null;\n\n  this.init_();\n};\ngoog.inherits(shaka.cast.CastReceiver, shaka.util.FakeEventTarget);\n\n\n/**\n * @return {boolean} True if the cast API is available and there are receivers.\n * @export\n */\nshaka.cast.CastReceiver.prototype.isConnected = function() {\n  return this.isConnected_;\n};\n\n\n/**\n * @return {boolean} True if the receiver is not currently doing loading or\n *   playing anything.\n * @export\n */\nshaka.cast.CastReceiver.prototype.isIdle = function() {\n  return this.isIdle_;\n};\n\n\n/**\n * Destroys the underlying Player, then terminates the cast receiver app.\n *\n * @override\n * @export\n */\nshaka.cast.CastReceiver.prototype.destroy = function() {\n  var p = this.player_ ? this.player_.destroy() : Promise.resolve();\n\n  if (this.pollTimerId_ != null) {\n    window.clearTimeout(this.pollTimerId_);\n  }\n\n  this.video_ = null;\n  this.player_ = null;\n  this.targets_ = null;\n  this.appDataCallback_ = null;\n  this.isConnected_ = false;\n  this.isIdle_ = true;\n  this.bus_ = null;\n  this.pollTimerId_ = null;\n\n  return p.then(function() {\n    var manager = cast.receiver.CastReceiverManager.getInstance();\n    manager.stop();\n  });\n};\n\n\n/** @private */\nshaka.cast.CastReceiver.prototype.init_ = function() {\n  var manager = cast.receiver.CastReceiverManager.getInstance();\n  manager.onSenderConnected = this.onSendersChanged_.bind(this);\n  manager.onSenderDisconnected = this.onSendersChanged_.bind(this);\n  manager.onSystemVolumeChanged = this.fakeVolumeChangeEvent_.bind(this);\n\n  this.bus_ = manager.getCastMessageBus(shaka.cast.CastUtils.MESSAGE_NAMESPACE);\n  this.bus_.onMessage = this.onMessage_.bind(this);\n\n  if (!COMPILED) {\n    // Sometimes it is useful to load the receiver app in Chrome to work on the\n    // UI.  To avoid log spam caused by the SDK trying to connect to web sockets\n    // that don't exist, in uncompiled mode we check if the hosting browser is a\n    // Chromecast before starting the receiver manager.  We wouldn't do browser\n    // detection except for debugging, so only do this in uncompiled mode.\n    var isChromecast = navigator.userAgent.indexOf('CrKey') >= 0;\n    if (isChromecast) {\n      manager.start();\n    }\n  } else {\n    manager.start();\n  }\n\n  shaka.cast.CastUtils.VideoEvents.forEach(function(name) {\n    this.video_.addEventListener(name, this.proxyEvent_.bind(this, 'video'));\n  }.bind(this));\n\n  shaka.cast.CastUtils.PlayerEvents.forEach(function(name) {\n    this.player_.addEventListener(name, this.proxyEvent_.bind(this, 'player'));\n  }.bind(this));\n\n  // In our tests, the original Chromecast seems to have trouble decoding above\n  // 1080p.  It would be a waste to select a higher res anyway, given that the\n  // device only outputs 1080p to begin with.\n\n  // Chromecast has an extension to query the device/display's resolution.\n  if (cast.__platform__ && cast.__platform__.canDisplayType(\n      'video/mp4; codecs=\"avc1.640028\"; width=3840; height=2160')) {\n    // The device & display can both do 4k.  Assume a 4k limit.\n    this.player_.setMaxHardwareResolution(3840, 2160);\n  } else {\n    // Chromecast has always been able to do 1080p.  Assume a 1080p limit.\n    this.player_.setMaxHardwareResolution(1920, 1080);\n  }\n\n  // Maintain idle state.\n  this.player_.addEventListener('loading', function() {\n    // No longer idle once loading.  This allows us to show the spinner during\n    // the initial buffering phase.\n    this.isIdle_ = false;\n    this.onCastStatusChanged_();\n  }.bind(this));\n  this.video_.addEventListener('playing', function() {\n    // No longer idle once playing.  This allows us to replay a video without\n    // reloading.\n    this.isIdle_ = false;\n    this.onCastStatusChanged_();\n  }.bind(this));\n  this.player_.addEventListener('unloading', function() {\n    // Go idle when unloading content.\n    this.isIdle_ = true;\n    this.onCastStatusChanged_();\n  }.bind(this));\n  this.video_.addEventListener('ended', function() {\n    // Go idle 5 seconds after 'ended', assuming we haven't started again or\n    // been destroyed.\n    window.setTimeout(function() {\n      if (this.video_ && this.video_.ended) {\n        this.isIdle_ = true;\n        this.onCastStatusChanged_();\n      }\n    }.bind(this), 5000);\n  }.bind(this));\n\n  // Do not start polling until after the sender's 'init' message is handled.\n};\n\n\n/** @private */\nshaka.cast.CastReceiver.prototype.onSendersChanged_ = function() {\n  var manager = cast.receiver.CastReceiverManager.getInstance();\n  this.isConnected_ = manager.getSenders().length != 0;\n  this.onCastStatusChanged_();\n};\n\n\n/**\n * Dispatch an event to notify the receiver app that the status has changed.\n * @private\n */\nshaka.cast.CastReceiver.prototype.onCastStatusChanged_ = function() {\n  // Do this asynchronously so that synchronous changes to idle state (such as\n  // Player calling unload() as part of load()) are coalesced before the event\n  // goes out.\n  Promise.resolve().then(function() {\n    var event = new shaka.util.FakeEvent('caststatuschanged');\n    this.dispatchEvent(event);\n  }.bind(this));\n};\n\n\n/**\n * Take on initial state from the sender.\n * @param {shaka.cast.CastUtils.InitStateType} initState\n * @param {Object} appData\n * @private\n */\nshaka.cast.CastReceiver.prototype.initState_ = function(initState, appData) {\n  // Take on player state first.\n  for (var k in initState['player']) {\n    var v = initState['player'][k];\n    // All player state vars are setters to be called.\n    /** @type {Object} */(this.player_)[k](v);\n  }\n\n  // Now process custom app data, which may add additional player configs:\n  this.appDataCallback_(appData);\n\n  var manifestReady = Promise.resolve();\n  var autoplay = this.video_.autoplay;\n\n  // Now load the manifest, if present.\n  if (initState['manifest']) {\n    // Don't autoplay the content until we finish setting up initial state.\n    this.video_.autoplay = false;\n    manifestReady = this.player_.load(\n        initState['manifest'], initState['startTime']);\n    // Pass any errors through to the app.\n    manifestReady.catch(function(error) {\n      goog.asserts.assert(error instanceof shaka.util.Error,\n                          'Wrong error type!');\n      var event = new shaka.util.FakeEvent('error', { 'detail': error });\n      this.player_.dispatchEvent(event);\n    }.bind(this));\n  }\n\n  // Finally, take on video state and player's \"after load\" state.\n  manifestReady.then(function() {\n    for (var k in initState['video']) {\n      var v = initState['video'][k];\n      this.video_[k] = v;\n    }\n\n    for (var k in initState['playerAfterLoad']) {\n      var v = initState['playerAfterLoad'][k];\n      // All player state vars are setters to be called.\n      /** @type {Object} */(this.player_)[k](v);\n    }\n\n    // Restore original autoplay setting.\n    this.video_.autoplay = autoplay;\n    if (initState['manifest']) {\n      // Resume playback with transferred state.\n      this.video_.play();\n    }\n  }.bind(this));\n};\n\n\n/**\n * @param {string} targetName\n * @param {!Event} event\n * @private\n */\nshaka.cast.CastReceiver.prototype.proxyEvent_ = function(targetName, event) {\n  // Poll and send an update right before we send the event.  Some events\n  // indicate an attribute change, so that change should be visible when the\n  // event is handled.\n  this.pollAttributes_();\n\n  this.sendMessage_({\n    'type': 'event',\n    'targetName': targetName,\n    'event': event\n  });\n};\n\n\n/** @private */\nshaka.cast.CastReceiver.prototype.pollAttributes_ = function() {\n  // The poll timer may have been pre-empted by an event.\n  // To avoid polling too often, we clear it here.\n  if (this.pollTimerId_ != null) {\n    window.clearTimeout(this.pollTimerId_);\n  }\n  // Since we know the timer has been cleared, start a new one now.\n  // This will be preempted by events, including 'timeupdate'.\n  this.pollTimerId_ = window.setTimeout(this.pollAttributes_.bind(this), 500);\n\n  var update = {\n    'video': {},\n    'player': {}\n  };\n\n  shaka.cast.CastUtils.VideoAttributes.forEach(function(name) {\n    update['video'][name] = this.video_[name];\n  }.bind(this));\n\n  shaka.cast.CastUtils.PlayerGetterMethods.forEach(function(name) {\n    update['player'][name] = /** @type {Object} */(this.player_)[name]();\n  }.bind(this));\n\n  // Volume attributes are tied to the system volume.\n  var manager = cast.receiver.CastReceiverManager.getInstance();\n  var systemVolume = manager.getSystemVolume();\n  if (systemVolume) {\n    update['video']['volume'] = systemVolume.level;\n    update['video']['muted'] = systemVolume.muted;\n  }\n\n  this.sendMessage_({\n    'type': 'update',\n    'update': update\n  });\n};\n\n\n/**\n * Dispatch a fake 'volumechange' event to mimic the video element, since volume\n * changes are routed to the system volume on the receiver.\n * @private\n */\nshaka.cast.CastReceiver.prototype.fakeVolumeChangeEvent_ = function() {\n  // Volume attributes are tied to the system volume.\n  var manager = cast.receiver.CastReceiverManager.getInstance();\n  var systemVolume = manager.getSystemVolume();\n  goog.asserts.assert(systemVolume, 'System volume should not be null!');\n\n  if (systemVolume) {\n    // Send an update message with just the latest volume level and muted state.\n    this.sendMessage_({\n      'type': 'update',\n      'update': {\n        'video': {\n          'volume': systemVolume.level,\n          'muted': systemVolume.muted\n        }\n      }\n    });\n  }\n\n  // Send another message with a 'volumechange' event to update the sender's UI.\n  this.sendMessage_({\n    'type': 'event',\n    'targetName': 'video',\n    'event': {'type': 'volumechange'}\n  });\n};\n\n\n/**\n * Since this method is in the compiled library, make sure all messages are\n * read with quoted properties.\n * @param {cast.receiver.CastMessageBus.Event} event\n * @private\n */\nshaka.cast.CastReceiver.prototype.onMessage_ = function(event) {\n  var message = shaka.cast.CastUtils.deserialize(event.data);\n  shaka.log.debug('CastReceiver: message', message);\n\n  switch (message['type']) {\n    case 'init':\n      this.initState_(message['initState'], message['appData']);\n      // The sender is supposed to reflect the cast system volume after\n      // connecting.  Using fakeVolumeChangeEvent_() would create a race on the\n      // sender side, since it would have volume properties, but no others.\n      // This would lead to hasRemoteProperties() being true, even though a\n      // complete set had never been sent.\n      // Now that we have init state, this is a good time for the first update\n      // message anyway.\n      this.pollAttributes_();\n      break;\n    case 'appData':\n      this.appDataCallback_(message['appData']);\n      break;\n    case 'set':\n      var targetName = message['targetName'];\n      var property = message['property'];\n      var value = message['value'];\n\n      if (targetName == 'video') {\n        // Volume attributes must be rerouted to the system.\n        var manager = cast.receiver.CastReceiverManager.getInstance();\n        if (property == 'volume') {\n          manager.setSystemVolumeLevel(value);\n          break;\n        } else if (property == 'muted') {\n          manager.setSystemVolumeMuted(value);\n          break;\n        }\n      }\n\n      this.targets_[targetName][property] = value;\n      break;\n    case 'call':\n      var targetName = message['targetName'];\n      var methodName = message['methodName'];\n      var args = message['args'];\n      var target = this.targets_[targetName];\n      target[methodName].apply(target, args);\n      break;\n    case 'asyncCall':\n      var targetName = message['targetName'];\n      var methodName = message['methodName'];\n      var args = message['args'];\n      var id = message['id'];\n      var senderId = event.senderId;\n      var target = this.targets_[targetName];\n      var p = target[methodName].apply(target, args);\n      // Replies must go back to the specific sender who initiated, so that we\n      // don't have to deal with conflicting IDs between senders.\n      p.then(this.sendAsyncComplete_.bind(this, senderId, id, /* error */ null),\n             this.sendAsyncComplete_.bind(this, senderId, id));\n      break;\n  }\n};\n\n\n/**\n * Tell the sender that the async operation is complete.\n * @param {string} senderId\n * @param {string} id\n * @param {shaka.util.Error} error\n * @private\n */\nshaka.cast.CastReceiver.prototype.sendAsyncComplete_ =\n    function(senderId, id, error) {\n  this.sendMessage_({\n    'type': 'asyncComplete',\n    'id': id,\n    'error': error\n  }, senderId);\n};\n\n\n/**\n * Since this method is in the compiled library, make sure all messages passed\n * in here were created with quoted property names.\n * @param {!Object} message\n * @param {string=} opt_senderId\n * @private\n */\nshaka.cast.CastReceiver.prototype.sendMessage_ =\n    function(message, opt_senderId) {\n  // Cuts log spam when debugging the receiver UI in Chrome.\n  if (!this.isConnected_) return;\n\n  var serialized = shaka.cast.CastUtils.serialize(message);\n  if (opt_senderId) {\n    this.bus_.getCastChannel(opt_senderId).send(serialized);\n  } else {\n    this.bus_.broadcast(serialized);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/cast/cast_sender.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.cast.CastSender');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.cast.CastUtils');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.PublicPromise');\n\n\n\n/**\n * @constructor\n * @struct\n * @param {string} receiverAppId The ID of the cast receiver application.\n * @param {function()} onStatusChanged A callback invoked when the cast status\n *   changes.\n * @param {function(string, !shaka.util.FakeEvent)} onRemoteEvent A callback\n *   invoked with target name and event when a remote event is received.\n * @param {function()} onResumeLocal A callback invoked when the local player\n *   should resume playback. Called before cached remote state is wiped.\n * @param {function()} onInitStateRequired A callback to get local player's.\n *   state. Invoked when casting is initiated from Chrome's cast button.\n * @implements {shaka.util.IDestroyable}\n */\nshaka.cast.CastSender =\n    function(receiverAppId, onStatusChanged, onRemoteEvent, onResumeLocal,\n             onInitStateRequired) {\n  /** @private {string} */\n  this.receiverAppId_ = receiverAppId;\n\n  /** @private {?function()} */\n  this.onStatusChanged_ = onStatusChanged;\n\n  /** @private {?function(string, !shaka.util.FakeEvent)} */\n  this.onRemoteEvent_ = onRemoteEvent;\n\n  /** @private {?function()} */\n  this.onResumeLocal_ = onResumeLocal;\n\n  /** @private {?function()} */\n  this.onInitStateRequired_ = onInitStateRequired;\n\n  /** @private {boolean} */\n  this.apiReady_ = false;\n\n  /** @private {boolean} */\n  this.hasReceivers_ = false;\n\n  /** @private {boolean} */\n  this.isCasting_ = false;\n\n  /** @private {string} */\n  this.receiverName_ = '';\n\n  /** @private {Object} */\n  this.appData_ = null;\n\n  /** @private {chrome.cast.Session} */\n  this.session_ = null;\n\n  /** @private {Object} */\n  this.cachedProperties_ = {\n    'video': {},\n    'player': {}\n  };\n\n  /** @private {number} */\n  this.nextAsyncCallId_ = 0;\n\n  /** @private {Object.<string, !shaka.util.PublicPromise>} */\n  this.asyncCallPromises_ = {};\n\n  /** @private {shaka.util.PublicPromise} */\n  this.castPromise_ = null;\n};\n\n\n/** @override */\nshaka.cast.CastSender.prototype.destroy = function() {\n  this.rejectAllPromises_();\n  if (this.session_) {\n    this.session_.stop(function() {}, function() {});\n    this.session_ = null;\n  }\n\n  this.onStatusChanged_ = null;\n  this.onRemoteEvent_ = null;\n  this.onResumeLocal_ = null;\n  this.apiReady_ = false;\n  this.hasReceivers_ = false;\n  this.isCasting_ = false;\n  this.appData_ = null;\n  this.session_ = null;\n  this.cachedProperties_ = null;\n  this.asyncCallPromises_ = null;\n  this.castPromise_ = null;\n\n  return Promise.resolve();\n};\n\n\n/**\n * @return {boolean} True if the cast API is available.\n */\nshaka.cast.CastSender.prototype.apiReady = function() {\n  return this.apiReady_;\n};\n\n\n/**\n * @return {boolean} True if there are receivers.\n */\nshaka.cast.CastSender.prototype.hasReceivers = function() {\n  return this.hasReceivers_;\n};\n\n\n/**\n * @return {boolean} True if we are currently casting.\n */\nshaka.cast.CastSender.prototype.isCasting = function() {\n  return this.isCasting_;\n};\n\n\n/**\n * @return {string} The name of the Cast receiver device, if isCasting().\n */\nshaka.cast.CastSender.prototype.receiverName = function() {\n  return this.receiverName_;\n};\n\n\n/**\n * @return {boolean} True if we have a cache of remote properties from the\n *   receiver.\n */\nshaka.cast.CastSender.prototype.hasRemoteProperties = function() {\n  return Object.keys(this.cachedProperties_['video']).length != 0;\n};\n\n\n/**\n * Initialize the Cast API.\n */\nshaka.cast.CastSender.prototype.init = function() {\n  // Check for the cast extension.\n  if (!window.chrome || !chrome.cast || !chrome.cast.isAvailable) {\n    // Not available yet, so wait to be notified if/when it is available.\n    window.__onGCastApiAvailable = (function(loaded) {\n      if (loaded) {\n        this.init();\n      }\n    }).bind(this);\n    return;\n  }\n\n  // The API is now available.\n  delete window.__onGCastApiAvailable;\n  this.apiReady_ = true;\n  this.onStatusChanged_();\n\n  var sessionRequest = new chrome.cast.SessionRequest(this.receiverAppId_);\n  var apiConfig = new chrome.cast.ApiConfig(sessionRequest,\n      this.onExistingSessionJoined_.bind(this),\n      this.onReceiverStatusChanged_.bind(this),\n      'origin_scoped');\n\n  // TODO: have never seen this fail.  when would it and how should we react?\n  chrome.cast.initialize(apiConfig,\n      function() { shaka.log.debug('CastSender: init'); },\n      function(error) { shaka.log.error('CastSender: init error', error); });\n};\n\n\n/**\n * Set application-specific data.\n *\n * @param {Object} appData Application-specific data to relay to the receiver.\n */\nshaka.cast.CastSender.prototype.setAppData = function(appData) {\n  this.appData_ = appData;\n  if (this.isCasting_) {\n    this.sendMessage_({\n      'type': 'appData',\n      'appData': this.appData_\n    });\n  }\n};\n\n\n/**\n * @param {shaka.cast.CastUtils.InitStateType} initState Video and player state\n *   to be sent to the receiver.\n * @return {!Promise} Resolved when connected to a receiver.  Rejected if the\n *   connection fails or is canceled by the user.\n */\nshaka.cast.CastSender.prototype.cast = function(initState) {\n  if (!this.apiReady_) {\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Category.CAST,\n        shaka.util.Error.Code.CAST_API_UNAVAILABLE));\n  }\n  if (!this.hasReceivers_) {\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Category.CAST,\n        shaka.util.Error.Code.NO_CAST_RECEIVERS));\n  }\n  if (this.isCasting_) {\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Category.CAST,\n        shaka.util.Error.Code.ALREADY_CASTING));\n  }\n\n  this.castPromise_ = new shaka.util.PublicPromise();\n  chrome.cast.requestSession(\n      this.onSessionInitiated_.bind(this, initState),\n      this.onConnectionError_.bind(this));\n  return this.castPromise_;\n};\n\n\n/**\n * Shows user a cast dialog where they can choose to stop\n * casting. Relies on Chrome to perform disconnect if they do.\n * Doesn't do anything if not connected.\n */\nshaka.cast.CastSender.prototype.showDisconnectDialog = function() {\n  if (!this.isCasting_) {\n    return;\n  }\n  var initState = this.onInitStateRequired_();\n\n  chrome.cast.requestSession(\n      this.onSessionInitiated_.bind(this, initState),\n      this.onConnectionError_.bind(this));\n};\n\n\n/**\n * Getter for properties of remote objects.\n * @param {string} targetName\n * @param {string} property\n * @return {?}\n */\nshaka.cast.CastSender.prototype.get = function(targetName, property) {\n  goog.asserts.assert(targetName == 'video' || targetName == 'player',\n                      'Unexpected target name');\n  if (targetName == 'video') {\n    if (shaka.cast.CastUtils.VideoVoidMethods.indexOf(property) >= 0) {\n      return this.remoteCall_.bind(this, targetName, property);\n    }\n  } else if (targetName == 'player') {\n    if (shaka.cast.CastUtils.PlayerVoidMethods.indexOf(property) >= 0) {\n      return this.remoteCall_.bind(this, targetName, property);\n    }\n    if (shaka.cast.CastUtils.PlayerPromiseMethods.indexOf(property) >= 0) {\n      return this.remoteAsyncCall_.bind(this, targetName, property);\n    }\n    if (shaka.cast.CastUtils.PlayerGetterMethods.indexOf(property) >= 0) {\n      return this.propertyGetter_.bind(this, targetName, property);\n    }\n  }\n\n  return this.propertyGetter_(targetName, property);\n};\n\n\n/**\n * Setter for properties of remote objects.\n * @param {string} targetName\n * @param {string} property\n * @param {?} value\n */\nshaka.cast.CastSender.prototype.set = function(targetName, property, value) {\n  goog.asserts.assert(targetName == 'video' || targetName == 'player',\n                      'Unexpected target name');\n\n  this.cachedProperties_[targetName][property] = value;\n  this.sendMessage_({\n    'type': 'set',\n    'targetName': targetName,\n    'property': property,\n    'value': value\n  });\n};\n\n\n/**\n * @param {shaka.cast.CastUtils.InitStateType} initState\n * @param {chrome.cast.Session} session\n * @private\n */\nshaka.cast.CastSender.prototype.onSessionInitiated_ =\n    function(initState, session) {\n  shaka.log.debug('CastSender: onSessionInitiated');\n  this.onSessionCreated_(session);\n\n  this.sendMessage_({\n    'type': 'init',\n    'initState': initState,\n    'appData': this.appData_\n  });\n\n  this.castPromise_.resolve();\n};\n\n\n/**\n * @param {chrome.cast.Error} error\n * @private\n */\nshaka.cast.CastSender.prototype.onConnectionError_ = function(error) {\n  // Default error code:\n  var code = shaka.util.Error.Code.UNEXPECTED_CAST_ERROR;\n\n  switch (error.code) {\n    case 'cancel':\n      code = shaka.util.Error.Code.CAST_CANCELED_BY_USER;\n      break;\n    case 'timeout':\n      code = shaka.util.Error.Code.CAST_CONNECTION_TIMED_OUT;\n      break;\n    case 'receiver_unavailable':\n      code = shaka.util.Error.Code.CAST_RECEIVER_APP_UNAVAILABLE;\n      break;\n  }\n\n  this.castPromise_.reject(new shaka.util.Error(\n      shaka.util.Error.Category.CAST,\n      code,\n      error));\n};\n\n\n/**\n * @param {string} targetName\n * @param {string} property\n * @return {?}\n * @private\n */\nshaka.cast.CastSender.prototype.propertyGetter_ =\n    function(targetName, property) {\n  goog.asserts.assert(targetName == 'video' || targetName == 'player',\n                      'Unexpected target name');\n  return this.cachedProperties_[targetName][property];\n};\n\n\n/**\n * @param {string} targetName\n * @param {string} methodName\n * @private\n */\nshaka.cast.CastSender.prototype.remoteCall_ =\n    function(targetName, methodName) {\n  goog.asserts.assert(targetName == 'video' || targetName == 'player',\n                      'Unexpected target name');\n  var args = Array.prototype.slice.call(arguments, 2);\n  this.sendMessage_({\n    'type': 'call',\n    'targetName': targetName,\n    'methodName': methodName,\n    'args': args\n  });\n};\n\n\n/**\n * @param {string} targetName\n * @param {string} methodName\n * @return {!Promise}\n * @private\n */\nshaka.cast.CastSender.prototype.remoteAsyncCall_ =\n    function(targetName, methodName) {\n  goog.asserts.assert(targetName == 'video' || targetName == 'player',\n                      'Unexpected target name');\n  var args = Array.prototype.slice.call(arguments, 2);\n\n  var p = new shaka.util.PublicPromise();\n  var id = this.nextAsyncCallId_.toString();\n  this.nextAsyncCallId_++;\n  this.asyncCallPromises_[id] = p;\n\n  this.sendMessage_({\n    'type': 'asyncCall',\n    'targetName': targetName,\n    'methodName': methodName,\n    'args': args,\n    'id': id\n  });\n  return p;\n};\n\n\n/**\n * @param {chrome.cast.Session} session\n * @private\n */\nshaka.cast.CastSender.prototype.onExistingSessionJoined_ = function(session) {\n  shaka.log.debug('CastSender: onExistingSessionJoined');\n\n  var initState = this.onInitStateRequired_();\n\n  this.castPromise_ = new shaka.util.PublicPromise();\n\n  this.onSessionInitiated_(initState, session);\n};\n\n\n/**\n * @param {string} availability\n * @private\n */\nshaka.cast.CastSender.prototype.onReceiverStatusChanged_ =\n    function(availability) {\n  // The cast extension is telling us whether there are any cast receiver\n  // devices available.\n  shaka.log.debug('CastSender: receiver status', availability);\n  this.hasReceivers_ = availability == 'available';\n  this.onStatusChanged_();\n};\n\n\n/**\n * @param {chrome.cast.Session} session\n * @private\n */\nshaka.cast.CastSender.prototype.onSessionCreated_ = function(session) {\n  this.session_ = session;\n  this.session_.addUpdateListener(this.onConnectionStatusChanged_.bind(this));\n  this.session_.addMessageListener(\n      shaka.cast.CastUtils.MESSAGE_NAMESPACE,\n      this.onMessageReceived_.bind(this));\n  this.onConnectionStatusChanged_();\n};\n\n\n/**\n * @private\n */\nshaka.cast.CastSender.prototype.onConnectionStatusChanged_ = function() {\n  var connected = this.session_ ? this.session_.status == 'connected' : false;\n  shaka.log.debug('CastSender: connection status', connected);\n  if (this.isCasting_ && !connected) {\n    // Tell CastProxy to transfer state back to local player.\n    this.onResumeLocal_();\n\n    // Clear whatever we have cached.\n    for (var targetName in this.cachedProperties_) {\n      this.cachedProperties_[targetName] = {};\n    }\n\n    this.rejectAllPromises_();\n  }\n\n  this.isCasting_ = connected;\n  this.receiverName_ = connected ? this.session_.receiver.friendlyName : '';\n  this.onStatusChanged_();\n};\n\n\n/**\n * Reject any async call promises that are still pending.\n * @private\n */\nshaka.cast.CastSender.prototype.rejectAllPromises_ = function() {\n  for (var id in this.asyncCallPromises_) {\n    var p = this.asyncCallPromises_[id];\n    delete this.asyncCallPromises_[id];\n\n    // Reject pending async operations as if they were interrupted.\n    // At the moment, load() is the only async operation we are worried\n    // about.\n    p.reject(new shaka.util.Error(\n        shaka.util.Error.Category.PLAYER,\n        shaka.util.Error.Code.LOAD_INTERRUPTED));\n  }\n};\n\n\n/**\n * Since this method is in the compiled library, make sure all messages are\n * read with quoted properties.\n * @param {string} namespace\n * @param {string} serialized\n * @private\n */\nshaka.cast.CastSender.prototype.onMessageReceived_ =\n    function(namespace, serialized) {\n  var message = shaka.cast.CastUtils.deserialize(serialized);\n  shaka.log.v2('CastSender: message', message);\n\n  switch (message['type']) {\n    case 'event':\n      var targetName = message['targetName'];\n      var event = message['event'];\n      var fakeEvent = new shaka.util.FakeEvent(event['type'], event);\n      this.onRemoteEvent_(targetName, fakeEvent);\n      break;\n    case 'update':\n      var update = message['update'];\n      for (var targetName in update) {\n        var target = this.cachedProperties_[targetName] || {};\n        for (var property in update[targetName]) {\n          target[property] = update[targetName][property];\n        }\n      }\n      break;\n    case 'asyncComplete':\n      var id = message['id'];\n      var error = message['error'];\n      var p = this.asyncCallPromises_[id];\n      delete this.asyncCallPromises_[id];\n\n      goog.asserts.assert(p, 'Unexpected async id');\n      if (!p) break;\n\n      if (error) {\n        // This is a hacky way to reconstruct the serialized error.\n        var reconstructedError = new shaka.util.Error(\n            error.category, error.code);\n        for (var k in error) {\n          (/** @type {Object} */(reconstructedError))[k] = error[k];\n        }\n        p.reject(reconstructedError);\n      } else {\n        p.resolve();\n      }\n      break;\n  }\n};\n\n\n/**\n * Since this method is in the compiled library, make sure all messages passed\n * in here were created with quoted property names.\n * @param {!Object} message\n * @private\n */\nshaka.cast.CastSender.prototype.sendMessage_ = function(message) {\n  var serialized = shaka.cast.CastUtils.serialize(message);\n  // TODO: have never seen this fail.  when would it and how should we react?\n  this.session_.sendMessage(shaka.cast.CastUtils.MESSAGE_NAMESPACE, serialized,\n                            function() {},  // success callback\n                            shaka.log.error);  // error callback\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/cast/cast_utils.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.cast.CastUtils');\n\ngoog.require('shaka.util.FakeEvent');\n\n\n/**\n * @namespace shaka.cast.CastUtils\n * @summary A set of cast utility functions and variables shared between sender\n *   and receiver.\n */\n\n\n/**\n * HTMLMediaElement events that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.VideoEvents = [\n  'ended',\n  'play',\n  'playing',\n  'pause',\n  'pausing',\n  'ratechange',\n  'seeked',\n  'seeking',\n  'timeupdate',\n  'volumechange'\n];\n\n\n/**\n * HTMLMediaElement attributes that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.VideoAttributes = [\n  'buffered',\n  'currentTime',\n  'duration',\n  'ended',\n  'loop',\n  'muted',\n  'paused',\n  'playbackRate',\n  'seeking',\n  'videoHeight',\n  'videoWidth',\n  'volume'\n];\n\n\n/**\n * HTMLMediaElement attributes that are transferred when casting begins.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.VideoInitStateAttributes = [\n  'loop',\n  'playbackRate'\n];\n\n\n/**\n * HTMLMediaElement methods with no return value that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.VideoVoidMethods = [\n  'pause',\n  'play'\n];\n\n\n/**\n * Player events that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.PlayerEvents = [\n  'adaptation',\n  'buffering',\n  'emsg',\n  'error',\n  'loading',\n  'unloading',\n  'texttrackvisibility',\n  'trackschanged'\n];\n\n\n/**\n * Player getter methods that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.PlayerGetterMethods = [\n  'drmInfo',\n  'getConfiguration',\n  'getManifestUri',\n  'getPlaybackRate',\n  'getTracks',\n  'getStats',\n  'isBuffering',\n  'isInProgress',\n  'isLive',\n  'isTextTrackVisible',\n  'keySystem',\n  'seekRange'\n];\n\n\n/**\n * Player getter and setter methods that are used to transfer state when casting\n * begins.\n * @const {!Array.<!Array.<string>>}\n */\nshaka.cast.CastUtils.PlayerInitState = [\n  ['getConfiguration', 'configure']\n];\n\n\n/**\n * Player getter and setter methods that are used to transfer state after\n * after load() is resolved.\n * @const {!Array.<!Array.<string>>}\n */\nshaka.cast.CastUtils.PlayerInitAfterLoadState = [\n  ['isTextTrackVisible', 'setTextTrackVisibility']\n];\n\n\n/**\n * Player methods with no return value that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.PlayerVoidMethods = [\n  'addTextTrack',\n  'cancelTrickPlay',\n  'configure',\n  'resetConfiguration',\n  'selectTrack',\n  'setTextTrackVisibility',\n  'trickPlay'\n];\n\n\n/**\n * Player methods returning a Promise that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.PlayerPromiseMethods = [\n  // The opt_manifestFactory method is not supported.\n  'load',\n  'unload'\n];\n\n\n/**\n * @typedef {{\n *   video: Object,\n *   player: Object,\n *   manifest: ?string,\n *   startTime: ?number\n * }}\n * @property {Object} video\n *   Dictionary of video properties to be set.\n * @property {Object} player\n *   Dictionary of player setters to be called.\n * @property {?string} manifest\n *   The currently-selected manifest, if present.\n * @property {?number} startTime\n *   The playback start time, if currently playing.\n */\nshaka.cast.CastUtils.InitStateType;\n\n\n/**\n * The namespace for Shaka messages on the cast bus.\n * @const {string}\n */\nshaka.cast.CastUtils.MESSAGE_NAMESPACE = 'urn:x-cast:com.google.shaka.v2';\n\n\n/**\n * Serialize as JSON, but specially encode things JSON will not otherwise\n * represent.\n * @param {?} thing\n * @return {string}\n */\nshaka.cast.CastUtils.serialize = function(thing) {\n  return JSON.stringify(thing, function(key, value) {\n    if (key == 'manager') {\n      // ABR manager can't be serialized.\n      return undefined;\n    }\n    if (typeof value == 'function') {\n      // Functions can't be (safely) serialized.\n      return undefined;\n    }\n    if (value instanceof Event || value instanceof shaka.util.FakeEvent) {\n      // Events don't serialize to JSON well because of the DOM objects\n      // and other complex objects they contain.  So we strip these out.\n      // Note that using Object.keys or JSON.stringify directly on the event\n      // will not capture its properties.  We must use a for loop.\n      var simpleEvent = {};\n      for (var eventKey in value) {\n        var eventValue = value[eventKey];\n        if (eventValue && typeof eventValue == 'object') {\n          // Strip out non-null object types because they are complex and we\n          // don't need them.\n        } else if (eventKey in Event) {\n          // Strip out keys that are found on Event itself because they are\n          // class-level constants we don't need, like Event.MOUSEMOVE == 16.\n        } else {\n          simpleEvent[eventKey] = eventValue;\n        }\n      }\n      return simpleEvent;\n    }\n    if (value instanceof TimeRanges) {\n      // TimeRanges must be unpacked into plain data for serialization.\n      return shaka.cast.CastUtils.unpackTimeRanges_(value);\n    }\n    if (typeof value == 'number') {\n      // NaN and infinity cannot be represented directly in JSON.\n      if (isNaN(value)) return 'NaN';\n      if (isFinite(value)) return value;\n      if (value < 0) return '-Infinity';\n      return 'Infinity';\n    }\n    return value;\n  });\n};\n\n\n/**\n * Deserialize JSON using our special encodings.\n * @param {string} str\n * @return {?}\n */\nshaka.cast.CastUtils.deserialize = function(str) {\n  return JSON.parse(str, function(key, value) {\n    if (value == 'NaN') {\n      return NaN;\n    } else if (value == '-Infinity') {\n      return -Infinity;\n    } else if (value == 'Infinity') {\n      return Infinity;\n    } else if (value && typeof value == 'object' &&\n               value['__type__'] == 'TimeRanges') {\n      // TimeRanges objects have been unpacked and sent as plain data.\n      // Simulate the original TimeRanges object.\n      return shaka.cast.CastUtils.simulateTimeRanges_(value);\n    }\n    return value;\n  });\n};\n\n\n/**\n * @param {!TimeRanges} ranges\n * @return {Object}\n * @private\n */\nshaka.cast.CastUtils.unpackTimeRanges_ = function(ranges) {\n  var obj = {\n    '__type__': 'TimeRanges',  // a signal to deserialize\n    'length': ranges.length,\n    'start': [],\n    'end': []\n  };\n\n  for (var i = 0; i < ranges.length; ++i) {\n    obj['start'].push(ranges.start(i));\n    obj['end'].push(ranges.end(i));\n  }\n\n  return obj;\n};\n\n\n/**\n * Creates a simulated TimeRanges object from data sent by the cast receiver.\n * @param {?} obj\n * @return {{\n *   length: number,\n *   start: function(number): number,\n *   end: function(number): number\n * }}\n * @private\n */\nshaka.cast.CastUtils.simulateTimeRanges_ = function(obj) {\n  return {\n    length: obj.length,\n    // NOTE: a more complete simulation would throw when |i| was out of range,\n    // but for simplicity we will assume a well-behaved application that uses\n    // length instead of catch to stop iterating.\n    start: function(i) { return obj.start[i]; },\n    end: function(i) { return obj.end[i]; }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/dash/content_protection.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.dash.ContentProtection');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.MapUtils');\ngoog.require('shaka.util.Uint8ArrayUtils');\ngoog.require('shaka.util.XmlUtils');\n\n\n/**\n * @namespace shaka.dash.ContentProtection\n * @summary A set of functions for parsing and interpreting ContentProtection\n *   elements.\n */\n\n\n/**\n * @typedef {{\n *   defaultKeyId: ?string,\n *   defaultInit: Array.<shakaExtern.InitDataOverride>,\n *   drmInfos: !Array.<shakaExtern.DrmInfo>,\n *   firstRepresentation: boolean\n * }}\n *\n * @description\n * Contains information about the ContentProtection elements found at the\n * AdaptationSet level.\n *\n * @property {?string} defaultKeyId\n *   The default key ID to use.  This is used by parseKeyIds as a default.  This\n *   can be null to indicate that there is no default.\n * @property {Array.<shakaExtern.InitDataOverride>} defaultInit\n *   The default init data override.  This can be null to indicate that there\n *   is no default.\n * @property {!Array.<shakaExtern.DrmInfo>} drmInfos\n *   The DrmInfo objects.\n * @property {boolean} firstRepresentation\n *   True when first parsed; changed to false after the first call to\n *   parseKeyIds.  This is used to determine if a dummy key-system should be\n *   overwritten; namely that the first representation can replace the dummy\n *   from the AdaptationSet.\n */\nshaka.dash.ContentProtection.Context;\n\n\n/**\n * @typedef {{\n *   node: !Element,\n *   schemeUri: string,\n *   keyId: ?string,\n *   init: Array.<shakaExtern.InitDataOverride>\n * }}\n *\n * @description\n * The parsed result of a single ContentProtection element.\n *\n * @property {!Element} node\n *   The ContentProtection XML element.\n * @property {string} schemeUri\n *   The scheme URI.\n * @property {?string} keyId\n *   The default key ID, if present.\n * @property {Array.<shakaExtern.InitDataOverride>} init\n *   The init data, if present.  If there is no init data, it will be null.  If\n *   this is non-null, there is at least one element.\n */\nshaka.dash.ContentProtection.Element;\n\n\n/**\n * A map of scheme URI to key system name.\n *\n * @const {!Object.<string, string>}\n * @private\n */\nshaka.dash.ContentProtection.defaultKeySystems_ = {\n  'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b': 'org.w3.clearkey',\n  'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed': 'com.widevine.alpha',\n  'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95': 'com.microsoft.playready',\n  'urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb': 'com.adobe.primetime'\n};\n\n\n/**\n * @const {string}\n * @private\n */\nshaka.dash.ContentProtection.MP4Protection_ =\n    'urn:mpeg:dash:mp4protection:2011';\n\n\n/**\n * Parses info from the ContentProtection elements at the AdaptationSet level.\n *\n * @param {!Array.<!Element>} elems\n * @param {shakaExtern.DashContentProtectionCallback} callback\n * @return {shaka.dash.ContentProtection.Context}\n */\nshaka.dash.ContentProtection.parseFromAdaptationSet = function(\n    elems, callback) {\n  var ContentProtection = shaka.dash.ContentProtection;\n  var Functional = shaka.util.Functional;\n  var MapUtils = shaka.util.MapUtils;\n  var parsed = ContentProtection.parseElements_(elems);\n\n  // Find the default key ID and init data.  Create a new array of all the\n  // non-CENC elements.\n  /** @type {Array.<shakaExtern.InitDataOverride>} */\n  var defaultInit = null;\n  var parsedNonCenc = parsed.filter(function(elem) {\n    if (elem.schemeUri == ContentProtection.MP4Protection_) {\n      goog.asserts.assert(!elem.init || elem.init.length,\n                          'Init data must be null or non-empty.');\n      defaultInit = elem.init || defaultInit;\n      return false;\n    } else {\n      return true;\n    }\n  });\n\n  // Get the default key ID; if there are multiple, they must all match.\n  var keyIds = parsed.map(function(elem) { return elem.keyId; })\n    .filter(Functional.isNotNull);\n  /** @type {?string} */\n  var defaultKeyId = null;\n  if (keyIds.length > 0) {\n    defaultKeyId = keyIds[0];\n    if (keyIds.some(Functional.isNotEqualFunc(defaultKeyId))) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_CONFLICTING_KEY_IDS);\n    }\n  }\n\n  /** @type {!Array.<shakaExtern.DrmInfo>} */\n  var drmInfos = [];\n  if (parsedNonCenc.length > 0) {\n    drmInfos = ContentProtection.convertElements_(\n        defaultInit, callback, parsedNonCenc);\n\n    // If there are no drmInfos after parsing, then add a dummy entry.  This may\n    // be removed in parseKeyIds.\n    if (drmInfos.length == 0) {\n      drmInfos = [ContentProtection.createDrmInfo_('', defaultInit)];\n    }\n  } else if (parsed.length > 0) {\n    // If there are only CENC element(s), then assume all key-systems are\n    // supported.\n    var keySystems = ContentProtection.defaultKeySystems_;\n    drmInfos =\n        MapUtils.values(keySystems)\n            .map(function(keySystem) {\n              return ContentProtection.createDrmInfo_(keySystem, defaultInit);\n            });\n  }\n\n  return {\n    defaultKeyId: defaultKeyId,\n    defaultInit: defaultInit,\n    drmInfos: drmInfos,\n    firstRepresentation: true\n  };\n};\n\n\n/**\n * Parses the given ContentProtection elements found at the Representation\n * level.  This may update the |context|.\n *\n * @param {!Array.<!Element>} elems\n * @param {shakaExtern.DashContentProtectionCallback} callback\n * @param {shaka.dash.ContentProtection.Context} context\n * @return {?string} The parsed key ID\n */\nshaka.dash.ContentProtection.parseFromRepresentation = function(\n    elems, callback, context) {\n  var ContentProtection = shaka.dash.ContentProtection;\n  var repContext = ContentProtection.parseFromAdaptationSet(elems, callback);\n\n  if (context.firstRepresentation) {\n    var asUnknown = context.drmInfos.length == 1 &&\n        !context.drmInfos[0].keySystem;\n    var asUnencrypted = context.drmInfos.length == 0;\n    var repUnencrypted = repContext.drmInfos.length == 0;\n\n    // There are two cases when we need to replace the |drmInfos| in the context\n    // with those in the Representation:\n    // * The AdaptationSet does not list any ContentProtection.\n    // * The AdaptationSet only lists unknown key-systems.\n    if (asUnencrypted || (asUnknown && !repUnencrypted)) {\n      context.drmInfos = repContext.drmInfos;\n    }\n    context.firstRepresentation = false;\n  } else if (repContext.drmInfos.length > 0) {\n    // If this is not the first Representation, then we need to remove entries\n    // from the context that do not appear in this Representation.\n    context.drmInfos = context.drmInfos.filter(function(asInfo) {\n      return repContext.drmInfos.some(function(repInfo) {\n        return repInfo.keySystem == asInfo.keySystem;\n      });\n    });\n    // If we have filtered out all key-systems, throw an error.\n    if (context.drmInfos.length == 0) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_NO_COMMON_KEY_SYSTEM);\n    }\n  }\n\n  return repContext.defaultKeyId || context.defaultKeyId;\n};\n\n\n/**\n * Creates a DrmInfo object from the given info.\n *\n * @param {string} keySystem\n * @param {Array.<shakaExtern.InitDataOverride>} initData\n * @return {shakaExtern.DrmInfo}\n * @private\n */\nshaka.dash.ContentProtection.createDrmInfo_ = function(keySystem, initData) {\n  return {\n    keySystem: keySystem,\n    licenseServerUri: '',\n    distinctiveIdentifierRequired: false,\n    persistentStateRequired: false,\n    audioRobustness: '',\n    videoRobustness: '',\n    serverCertificate: null,\n    initData: initData || [],\n    keyIds: []\n  };\n};\n\n\n/**\n * Creates DrmInfo objects from the given element.\n *\n * @param {Array.<shakaExtern.InitDataOverride>} defaultInit\n * @param {shakaExtern.DashContentProtectionCallback} callback\n * @param {!Array.<shaka.dash.ContentProtection.Element>} elements\n * @return {!Array.<shakaExtern.DrmInfo>}\n * @private\n */\nshaka.dash.ContentProtection.convertElements_ = function(\n    defaultInit, callback, elements) {\n  var Functional = shaka.util.Functional;\n  return elements.map(\n      /**\n       * @param {shaka.dash.ContentProtection.Element} element\n       * @return {!Array.<shakaExtern.DrmInfo>}\n       */\n      function(element) {\n        var ContentProtection = shaka.dash.ContentProtection;\n        var keySystem = ContentProtection.defaultKeySystems_[element.schemeUri];\n        if (keySystem) {\n          goog.asserts.assert(!element.init || element.init.length,\n                              'Init data must be null or non-empty.');\n          var initData = element.init || defaultInit;\n          return [ContentProtection.createDrmInfo_(keySystem, initData)];\n        } else {\n          goog.asserts.assert(\n              callback, 'ContentProtection callback is required');\n          return callback(element.node) || [];\n        }\n      }).reduce(Functional.collapseArrays, []);\n};\n\n\n/**\n * Parses the given ContentProtection elements.  If there is an error, it\n * removes those elements.\n *\n * @param {!Array.<!Element>} elems\n * @return {!Array.<shaka.dash.ContentProtection.Element>}\n * @private\n */\nshaka.dash.ContentProtection.parseElements_ = function(elems) {\n  var Functional = shaka.util.Functional;\n  return elems.map(\n      /**\n       * @param {!Element} elem\n       * @return {?shaka.dash.ContentProtection.Element}\n       */\n      function(elem) {\n        /** @type {?string} */\n        var schemeUri = elem.getAttribute('schemeIdUri');\n        /** @type {?string} */\n        var keyId = elem.getAttribute('cenc:default_KID');\n        /** @type {!Array.<string>} */\n        var psshs = shaka.util.XmlUtils.findChildren(elem, 'cenc:pssh')\n                        .map(shaka.util.XmlUtils.getContents);\n\n        if (!schemeUri) {\n          shaka.log.error('Missing required schemeIdUri attribute on',\n                          'ContentProtection element', elem);\n          return null;\n        }\n\n        schemeUri = schemeUri.toLowerCase();\n        if (keyId) {\n          keyId = keyId.replace(/-/g, '').toLowerCase();\n          if (keyId.indexOf(' ') >= 0) {\n            throw new shaka.util.Error(\n                shaka.util.Error.Category.MANIFEST,\n                shaka.util.Error.Code.DASH_MULTIPLE_KEY_IDS_NOT_SUPPORTED);\n          }\n        }\n\n        /** @type {!Array.<shakaExtern.InitDataOverride>} */\n        var init = [];\n        try {\n          init = psshs.map(function(pssh) {\n            /** @type {shakaExtern.InitDataOverride} */\n            var ret = {\n              initDataType: 'cenc',\n              initData: shaka.util.Uint8ArrayUtils.fromBase64(pssh)\n            };\n            return ret;\n          });\n        } catch (e) {\n          // Invalid PSSH data, ignore.\n          throw new shaka.util.Error(\n              shaka.util.Error.Category.MANIFEST,\n              shaka.util.Error.Code.DASH_PSSH_BAD_ENCODING);\n        }\n\n        /** @type {shaka.dash.ContentProtection.Element} */\n        var element = {\n          node: elem,\n          schemeUri: schemeUri,\n          keyId: keyId,\n          init: (init.length > 0 ? init : null)\n        };\n        return element;\n      }).filter(Functional.isNotNull);\n};\n\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/dash/dash_parser.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.dash.DashParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.dash.ContentProtection');\ngoog.require('shaka.dash.MpdUtils');\ngoog.require('shaka.dash.SegmentBase');\ngoog.require('shaka.dash.SegmentList');\ngoog.require('shaka.dash.SegmentTemplate');\ngoog.require('shaka.log');\ngoog.require('shaka.media.ManifestParser');\ngoog.require('shaka.media.PresentationTimeline');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.media.TextEngine');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.DataViewReader');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.MapUtils');\ngoog.require('shaka.util.Mp4Parser');\ngoog.require('shaka.util.MultiMap');\ngoog.require('shaka.util.StreamUtils');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.XmlUtils');\n\n\n\n/**\n * Creates a new DASH parser.\n *\n * @struct\n * @constructor\n * @implements {shakaExtern.ManifestParser}\n * @export\n */\nshaka.dash.DashParser = function() {\n  /** @private {shaka.net.NetworkingEngine} */\n  this.networkingEngine_ = null;\n\n  /** @private {?shakaExtern.ManifestConfiguration} */\n  this.config_ = null;\n\n  /** @private {?function(shakaExtern.Period)} */\n  this.filterPeriod_ = null;\n\n  /** @private {?function(!shaka.util.Error)} */\n  this.onError_ = null;\n\n  /** @private {?function(!shaka.util.FakeEvent)} */\n  this.onEvent_ = null;\n\n  /** @private {!Array.<string>} */\n  this.manifestUris_ = [];\n\n  /** @private {?shakaExtern.Manifest} */\n  this.manifest_ = null;\n\n  /** @private {!Array.<string>} */\n  this.periodIds_ = [];\n\n  /** @private {number} */\n  this.globalId_ = 1;\n\n  /**\n   * A map of IDs to SegmentIndex objects.\n   * ID: Period@id,AdaptationSet@id,@Representation@id\n   * e.g.: '1,5,23'\n   * @private {!Object.<string, !shaka.media.SegmentIndex>}\n   */\n  this.segmentIndexMap_ = {};\n\n  /**\n   * The update period in seconds; or 0 for no updates.\n   * @private {number}\n   */\n  this.updatePeriod_ = 0;\n\n  /** @private {?number} */\n  this.updateTimer_ = null;\n\n  /** @private {!shakaExtern.ResponseFilter} */\n  this.emsgResponseFilter_ = this.emsgResponseFilter_.bind(this);\n};\n\n\n/**\n * Contains the minimum amount of time, in seconds, between manifest update\n * requests.\n *\n * @private\n * @const {number}\n */\nshaka.dash.DashParser.MIN_UPDATE_PERIOD_ = 3;\n\n\n/**\n * The default MPD@suggestedPresentationDelay in seconds.\n *\n * @private\n * @const {number}\n */\nshaka.dash.DashParser.DEFAULT_SUGGESTED_PRESENTATION_DELAY_ = 10;\n\n\n/**\n * @typedef {\n *   !function(!Array.<string>, ?number, ?number):!Promise.<!ArrayBuffer>\n * }\n */\nshaka.dash.DashParser.RequestInitSegmentCallback;\n\n\n/**\n * @typedef {{\n *   segmentBase: Element,\n *   segmentList: Element,\n *   segmentTemplate: Element,\n *   baseUris: !Array.<string>,\n *   width: (number|undefined),\n *   height: (number|undefined),\n *   contentType: string,\n *   mimeType: string,\n *   codecs: string,\n *   frameRate: (number|undefined),\n *   id: string\n * }}\n *\n * @description\n * A collection of elements and properties which are inherited across levels\n * of a DASH manifest.\n *\n * @property {Element} segmentBase\n *   The XML node for SegmentBase.\n * @property {Element} segmentList\n *   The XML node for SegmentList.\n * @property {Element} segmentTemplate\n *   The XML node for SegmentTemplate.\n * @property {!Array.<string>} baseUris\n *   An array of absolute base URIs for the frame.\n * @property {(number|undefined)} width\n *   The inherited width value.\n * @property {(number|undefined)} height\n *   The inherited height value.\n * @property {string} contentType\n *   The inherited media type.\n * @property {string} mimeType\n *   The inherited MIME type value.\n * @property {string} codecs\n *   The inherited codecs value.\n * @property {(number|undefined)} frameRate\n *   The inherited framerate value.\n * @property {string} id\n *   The ID of the element.\n */\nshaka.dash.DashParser.InheritanceFrame;\n\n\n/**\n * @typedef {{\n *   dynamic: boolean,\n *   presentationTimeline: !shaka.media.PresentationTimeline,\n *   period: ?shaka.dash.DashParser.InheritanceFrame,\n *   periodInfo: ?shaka.dash.DashParser.PeriodInfo,\n *   adaptationSet: ?shaka.dash.DashParser.InheritanceFrame,\n *   representation: ?shaka.dash.DashParser.InheritanceFrame,\n *   bandwidth: (number|undefined),\n *   indexRangeWarningGiven: boolean\n * }}\n *\n * @description\n * Contains context data for the streams.\n *\n * @property {boolean} dynamic\n *   True if the MPD is dynamic (not all segments available at once)\n * @property {!shaka.media.PresentationTimeline} presentationTimeline\n *   The PresentationTimeline.\n * @property {?shaka.dash.DashParser.InheritanceFrame} period\n *   The inheritance from the Period element.\n * @property {?shaka.dash.DashParser.PeriodInfo} periodInfo\n *   The Period info for the current Period.\n * @property {?shaka.dash.DashParser.InheritanceFrame} adaptationSet\n *   The inheritance from the AdaptationSet element.\n * @property {?shaka.dash.DashParser.InheritanceFrame} representation\n *   The inheritance from the Representation element.\n * @property {(number|undefined)} bandwidth\n *   The bandwidth of the Representation.\n * @property {boolean} indexRangeWarningGiven\n *   True if the warning about SegmentURL@indexRange has been printed.\n */\nshaka.dash.DashParser.Context;\n\n\n/**\n * @typedef {{\n *   start: number,\n *   duration: ?number,\n *   node: !Element,\n *   containsInband: boolean\n * }}\n *\n * @description\n * Contains information about a Period element.\n *\n * @property {number} start\n *   The start time of the period.\n * @property {?number} duration\n *   The duration of the period; or null if the duration is not given.  This\n *   will be non-null for all periods except the last.\n * @property {!Element} node\n *   The XML Node for the Period.\n * @property {boolean} containsInband\n *   Indicates whether a period contains inband information.\n */\nshaka.dash.DashParser.PeriodInfo;\n\n\n/**\n * @typedef {{\n *   id: string,\n *   contentType: ?string,\n *   language: string,\n *   main: boolean,\n *   streams: !Array.<shakaExtern.Stream>,\n *   drmInfos: !Array.<shakaExtern.DrmInfo>,\n *   switchableIds: !Array.<string>,\n *   containsInband: boolean,\n *   representationIds: !Array.<string>\n * }}\n *\n * @description\n * Contains information about an AdaptationSet element.\n *\n * @property {string} id\n *   The unique ID of the adaptation set.\n * @property {?string} contentType\n *   The content type of the AdaptationSet.\n * @property {string} language\n *   The language of the AdaptationSet.\n * @property {boolean} main\n *   Whether the AdaptationSet has the 'main' type.\n * @property {!Array.<shakaExtern.Stream>} streams\n *   The streams this AdaptationSet contains.\n * @property {!Array.<shakaExtern.DrmInfo>} drmInfos\n *   The DRM info for the AdaptationSet.\n * @property {!Array.<string>} switchableIds\n *   An array of the IDs of the AdaptationSets it can switch to.\n * @property {boolean} containsInband\n *   Signals whether AdaptationSet has inband content indicator on it.\n * @property {!Array.<string>} representationIds\n *   An array of the IDs of the Representations this AdaptationSet contains.\n */\nshaka.dash.DashParser.AdaptationInfo;\n\n\n/**\n * @typedef {{\n *   createSegmentIndex: shakaExtern.CreateSegmentIndexFunction,\n *   findSegmentPosition: shakaExtern.FindSegmentPositionFunction,\n *   getSegmentReference: shakaExtern.GetSegmentReferenceFunction\n * }}\n *\n * @description\n * Contains functions used to create and find segment references.\n *\n * @property {shakaExtern.CreateSegmentIndexFunction} createSegmentIndex\n *   The createSegmentIndex function.\n * @property {shakaExtern.FindSegmentPositionFunction} findSegmentPosition\n *   The findSegmentPosition function.\n * @property {shakaExtern.GetSegmentReferenceFunction} getSegmentReference\n *   The getSegmentReference function.\n */\nshaka.dash.DashParser.SegmentIndexFunctions;\n\n\n/**\n * @typedef {{\n *   createSegmentIndex: shakaExtern.CreateSegmentIndexFunction,\n *   findSegmentPosition: shakaExtern.FindSegmentPositionFunction,\n *   getSegmentReference: shakaExtern.GetSegmentReferenceFunction,\n *   initSegmentReference: shaka.media.InitSegmentReference,\n *   presentationTimeOffset: (number|undefined)\n * }}\n *\n * @description\n * Contains information about a Stream.  This is passed from the createStream\n * methods.\n *\n * @property {shakaExtern.CreateSegmentIndexFunction} createSegmentIndex\n *   The createSegmentIndex function for the stream.\n * @property {shakaExtern.FindSegmentPositionFunction} findSegmentPosition\n *   The findSegmentPosition function for the stream.\n * @property {shakaExtern.GetSegmentReferenceFunction} getSegmentReference\n *   The getSegmentReference function for the stream.\n * @property {shaka.media.InitSegmentReference} initSegmentReference\n *   The init segment for the stream.\n * @property {(number|undefined)} presentationTimeOffset\n *   The presentationTimeOffset for the stream.\n */\nshaka.dash.DashParser.StreamInfo;\n\n\n/**\n * @override\n * @exportInterface\n */\nshaka.dash.DashParser.prototype.configure = function(config) {\n  this.config_ = config;\n};\n\n\n/**\n * @override\n * @exportInterface\n */\nshaka.dash.DashParser.prototype.start =\n    function(uri, networkingEngine, filterPeriod, onError, onEvent) {\n  goog.asserts.assert(this.config_, 'Must call configure() before start()!');\n  this.manifestUris_ = [uri];\n  this.networkingEngine_ = networkingEngine;\n  this.filterPeriod_ = filterPeriod;\n  this.onError_ = onError;\n  this.onEvent_ = onEvent;\n  return this.requestManifest_().then(function() {\n    if (this.networkingEngine_)\n      this.setUpdateTimer_(0);\n    return this.manifest_;\n  }.bind(this));\n};\n\n\n/**\n * @override\n * @exportInterface\n */\nshaka.dash.DashParser.prototype.stop = function() {\n  if (this.networkingEngine_)\n    this.networkingEngine_.unregisterResponseFilter(this.emsgResponseFilter_);\n  this.networkingEngine_ = null;\n  this.filterPeriod_ = null;\n  this.onError_ = null;\n  this.onEvent_ = null;\n  this.config_ = null;\n\n  this.manifestUris_ = [];\n  this.manifest_ = null;\n  this.periodIds_ = [];\n  this.segmentIndexMap_ = {};\n  if (this.updateTimer_ != null) {\n    window.clearTimeout(this.updateTimer_);\n    this.updateTimer_ = null;\n  }\n\n  return Promise.resolve();\n};\n\n\n/**\n * Makes a network request for the manifest and parses the resulting data.\n *\n * @return {!Promise}\n * @private\n */\nshaka.dash.DashParser.prototype.requestManifest_ = function() {\n  var requestType = shaka.net.NetworkingEngine.RequestType.MANIFEST;\n  var request = shaka.net.NetworkingEngine.makeRequest(\n      this.manifestUris_, this.config_.retryParameters);\n  return this.networkingEngine_.request(requestType, request)\n      .then(function(response) {\n        // Detect calls to stop().\n        if (!this.networkingEngine_)\n          return;\n\n        // This may throw; but it will result in a failed promise.\n        return this.parseManifest_(response.data, response.uri);\n      }.bind(this));\n};\n\n\n/**\n * Parses the manifest XML.  This also handles updates and will update the\n * stored manifest.\n *\n * @param {!ArrayBuffer} data\n * @param {string} finalManifestUri The final manifest URI, which may\n *   differ from this.manifestUri_ if there has been a redirect.\n * @return {!Promise}\n * @throws shaka.util.Error When there is a parsing error.\n * @private\n */\nshaka.dash.DashParser.prototype.parseManifest_ =\n    function(data, finalManifestUri) {\n  var Error = shaka.util.Error;\n  var Functional = shaka.util.Functional;\n  var XmlUtils = shaka.util.XmlUtils;\n\n  var string = shaka.util.StringUtils.fromUTF8(data);\n  var parser = new DOMParser();\n  var xml = null;\n  var mpd = null;\n\n  try {\n    xml = parser.parseFromString(string, 'text/xml');\n  } catch (exception) {}\n  if (xml) {\n    // parseFromString returns a Document object.  A Document is a Node but not\n    // an Element, so it cannot be used in XmlUtils (technically it can but the\n    // types don't match).  The |documentElement| member defines the top-level\n    // element in the document.\n    if (xml.documentElement.tagName == 'MPD')\n      mpd = xml.documentElement;\n  }\n  if (!mpd) {\n    throw new Error(Error.Category.MANIFEST, Error.Code.DASH_INVALID_XML);\n  }\n\n  // Get any Location elements.  This will update the manifest location and\n  // the base URI.\n  /** @type {!Array.<string>} */\n  var manifestBaseUris = [finalManifestUri];\n  /** @type {!Array.<string>} */\n  var locations = XmlUtils.findChildren(mpd, 'Location')\n                      .map(XmlUtils.getContents)\n                      .filter(Functional.isNotNull);\n  if (locations.length > 0) {\n    this.manifestUris_ = locations;\n    manifestBaseUris = locations;\n  }\n\n  var uris = XmlUtils.findChildren(mpd, 'BaseURL').map(XmlUtils.getContents);\n  var baseUris = shaka.dash.MpdUtils.resolveUris(manifestBaseUris, uris);\n\n  var minBufferTime =\n      XmlUtils.parseAttr(mpd, 'minBufferTime', XmlUtils.parseDuration);\n  this.updatePeriod_ = /** @type {number} */ (XmlUtils.parseAttr(\n      mpd, 'minimumUpdatePeriod', XmlUtils.parseDuration, -1));\n\n  var presentationStartTime = XmlUtils.parseAttr(\n      mpd, 'availabilityStartTime', XmlUtils.parseDate);\n  var segmentAvailabilityDuration = XmlUtils.parseAttr(\n      mpd, 'timeShiftBufferDepth', XmlUtils.parseDuration);\n  var suggestedPresentationDelay = XmlUtils.parseAttr(\n      mpd, 'suggestedPresentationDelay', XmlUtils.parseDuration);\n  var maxSegmentDuration = XmlUtils.parseAttr(\n      mpd, 'maxSegmentDuration', XmlUtils.parseDuration);\n  var mpdType = mpd.getAttribute('type') || 'static';\n\n  var presentationTimeline;\n  if (this.manifest_) {\n    presentationTimeline = this.manifest_.presentationTimeline;\n  } else {\n    // DASH IOP v3.0 suggests using a default delay between minBufferTime and\n    // timeShiftBufferDepth.  This is literally the range of all feasible\n    // choices for the value.  Nothing older than timeShiftBufferDepth is still\n    // available, and anything less than minBufferTime will cause buffering\n    // issues.\n    //\n    // We have decided that our default will be 1.5 * minBufferTime, or 10s,\n    // whichever is larger.  This is fairly conservative.  Content providers\n    // should provide a suggestedPresentationDelay whenever possible to optimize\n    // the live streaming experience.\n    var defaultPresentationDelay = Math.max(\n        shaka.dash.DashParser.DEFAULT_SUGGESTED_PRESENTATION_DELAY_,\n        minBufferTime * 1.5);\n    var presentationDelay = suggestedPresentationDelay != null ?\n        suggestedPresentationDelay : defaultPresentationDelay;\n    presentationTimeline = new shaka.media.PresentationTimeline(\n        presentationStartTime, presentationDelay);\n  }\n\n  /** @type {shaka.dash.DashParser.Context} */\n  var context = {\n    dynamic: mpdType != 'static',\n    presentationTimeline: presentationTimeline,\n    period: null,\n    periodInfo: null,\n    adaptationSet: null,\n    representation: null,\n    bandwidth: undefined,\n    indexRangeWarningGiven: false\n  };\n\n  var periodsAndDuration = this.parsePeriods_(context, baseUris, mpd);\n  var duration = periodsAndDuration.duration;\n  var periods = periodsAndDuration.periods;\n\n  presentationTimeline.setStatic(mpdType == 'static');\n  presentationTimeline.setDuration(duration || Infinity);\n  presentationTimeline.setSegmentAvailabilityDuration(\n      segmentAvailabilityDuration != null ?\n      segmentAvailabilityDuration :\n      Infinity);\n  // Use @maxSegmentDuration to override smaller, derived values.\n  presentationTimeline.notifyMaxSegmentDuration(maxSegmentDuration || 1);\n  if (!COMPILED) presentationTimeline.assertIsValid();\n\n  if (this.manifest_) {\n    // This is a manifest update, so we're done.\n    return Promise.resolve();\n  }\n\n  // This is the first manifest parse, so we cannot return until we calculate\n  // the clock offset.\n  var timingElements = XmlUtils.findChildren(mpd, 'UTCTiming');\n\n  var isLive = presentationTimeline.isLive();\n\n  // if any of the periods had an emsg box indicator,\n  // register a response filter to look for an EMSG box in segments\n  if (periodsAndDuration.containsInband)\n    this.networkingEngine_.registerResponseFilter(this.emsgResponseFilter_);\n\n  return this.parseUtcTiming_(\n      baseUris, timingElements, isLive).then(function(offset) {\n    // Detect calls to stop().\n    if (!this.networkingEngine_)\n      return;\n\n    presentationTimeline.setClockOffset(offset);\n\n    this.manifest_ = {\n      presentationTimeline: presentationTimeline,\n      periods: periods,\n      offlineSessionIds: [],\n      minBufferTime: minBufferTime || 0\n    };\n  }.bind(this));\n};\n\n\n/**\n * Reads and parses the periods from the manifest.  This first does some\n * partial parsing so the start and duration is available when parsing children.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {!Array.<string>} baseUris\n * @param {!Element} mpd\n * @return {{periods: !Array.<shakaExtern.Period>,\n *          duration: ?number, containsInband: boolean}}\n * @private\n */\nshaka.dash.DashParser.prototype.parsePeriods_ = function(\n    context, baseUris, mpd) {\n  var Functional = shaka.util.Functional;\n  var XmlUtils = shaka.util.XmlUtils;\n  var presentationDuration = XmlUtils.parseAttr(\n      mpd, 'mediaPresentationDuration', XmlUtils.parseDuration);\n\n  var containsInband = false;\n  var periods = [];\n  var prevEnd = 0;\n  var periodNodes = XmlUtils.findChildren(mpd, 'Period');\n  for (var i = 0; i < periodNodes.length; i++) {\n    var elem = periodNodes[i];\n    var start = /** @type {number} */ (\n        XmlUtils.parseAttr(elem, 'start', XmlUtils.parseDuration, prevEnd));\n    var periodDuration =\n        XmlUtils.parseAttr(elem, 'duration', XmlUtils.parseDuration);\n\n    if (periodDuration == null) {\n      if (i + 1 != periodNodes.length) {\n        // \"The difference between the start time of a Period and the start time\n        // of the following Period is the duration of the media content\n        // represented by this Period.\"\n        var nextPeriod = periodNodes[i + 1];\n        var nextStart =\n            XmlUtils.parseAttr(nextPeriod, 'start', XmlUtils.parseDuration);\n        if (nextStart != null)\n          periodDuration = nextStart - start;\n      } else if (presentationDuration != null) {\n        // \"The Period extends until the Period.start of the next Period, or\n        // until the end of the Media Presentation in the case of the last\n        // Period.\"\n        periodDuration = presentationDuration - start;\n      }\n    }\n\n    // Parse child nodes.\n    var info = {\n      start: start,\n      duration: periodDuration,\n      node: elem,\n      containsInband: false\n    };\n    var period = this.parsePeriod_(context, baseUris, info);\n    periods.push(period);\n    // parsePeriod_ has now calculated info.containsInband.\n    containsInband = containsInband || info.containsInband;\n\n    // If there are any new periods, call the callback and add them to the\n    // manifest.  If this is the first parse, it will see all of them as new.\n    var periodId = context.period.id;\n    if (this.periodIds_.every(Functional.isNotEqualFunc(periodId))) {\n      this.filterPeriod_(period);\n      this.periodIds_.push(periodId);\n      if (this.manifest_)\n        this.manifest_.periods.push(period);\n    }\n\n    if (periodDuration == null) {\n      if (i + 1 != periodNodes.length) {\n        // If the duration is still null and we aren't at the end, then we will\n        // skip any remaining periods.\n        shaka.log.warning(\n            'Skipping Period', i + 1, 'and any subsequent Periods:', 'Period',\n            i + 1, 'does not have a valid start time.', periods[i + 1]);\n      }\n\n      // The duration is unknown, so the end is unknown.\n      prevEnd = null;\n      break;\n    }\n\n    prevEnd = start + periodDuration;\n  }\n\n  if (presentationDuration != null) {\n    if (prevEnd != presentationDuration) {\n      shaka.log.warning(\n          '@mediaPresentationDuration does not match the total duration of all',\n          'Periods.');\n      // Assume @mediaPresentationDuration is correct.\n    }\n    return {\n      periods: periods,\n      duration: presentationDuration,\n      containsInband: containsInband\n    };\n  } else {\n    return {\n      periods: periods,\n      duration: prevEnd,\n      containsInband: containsInband\n    };\n  }\n};\n\n\n/**\n * Parses a Period XML element.  Unlike the other parse methods, this is not\n * given the Node; it is given a PeriodInfo structure.  Also, partial parsing\n * was done before this was called so start and duration are valid.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {!Array.<string>} baseUris\n * @param {shaka.dash.DashParser.PeriodInfo} periodInfo\n * @return {shakaExtern.Period}\n * @throws shaka.util.Error When there is a parsing error.\n * @private\n */\nshaka.dash.DashParser.prototype.parsePeriod_ = function(\n    context, baseUris, periodInfo) {\n  var Functional = shaka.util.Functional;\n  var XmlUtils = shaka.util.XmlUtils;\n  context.period = this.createFrame_(periodInfo.node, null, baseUris);\n  context.periodInfo = periodInfo;\n\n  // If the period doesn't have an ID, give it one based on its start time.\n  if (!context.period.id) {\n    shaka.log.info(\n        'No Period ID given for Period with start time ' + periodInfo.start +\n        ',  Assigning a default');\n    context.period.id = '__shaka_period_' + periodInfo.start;\n  }\n\n  var adaptationSetNodes =\n      XmlUtils.findChildren(periodInfo.node, 'AdaptationSet');\n  var adaptationSets = adaptationSetNodes\n      .map(this.parseAdaptationSet_.bind(this, context))\n      .filter(Functional.isNotNull);\n\n  var representationIds = adaptationSets\n      .map(function(as) { return as.representationIds; })\n      .reduce(Functional.collapseArrays, []);\n  var uniqueRepIds = representationIds.filter(Functional.isNotDuplicate);\n  if (representationIds.length != uniqueRepIds.length) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_DUPLICATE_REPRESENTATION_ID);\n  }\n\n  if (adaptationSets.length == 0) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_EMPTY_PERIOD);\n  }\n\n  // see if any adaptation set has emsg indicator on it.\n  // If it does, we'll register a response filter later.\n  for (var i = 0; i < adaptationSets.length; i++) {\n    if (adaptationSets[i].containsInband) {\n      periodInfo.containsInband = true;\n    }\n  }\n\n  var streamSets = this.createStreamSets_(adaptationSets);\n  return {startTime: periodInfo.start, streamSets: streamSets};\n};\n\n\n/**\n * Parses an AdaptationSet XML element.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {!Element} elem The AdaptationSet element.\n * @return {?shaka.dash.DashParser.AdaptationInfo}\n * @throws shaka.util.Error When there is a parsing error.\n * @private\n */\nshaka.dash.DashParser.prototype.parseAdaptationSet_ = function(context, elem) {\n  var XmlUtils = shaka.util.XmlUtils;\n  context.adaptationSet = this.createFrame_(elem, context.period, null);\n\n  var main = false;\n  var roles = XmlUtils.findChildren(elem, 'Role');\n\n  // Default kind for text streams is 'subtitle' if unspecified in the manifest.\n  var kind = undefined;\n  if (context.adaptationSet.contentType == 'text') kind = 'subtitle';\n\n  for (var i = 0; i < roles.length; i++) {\n    var scheme = roles[i].getAttribute('schemeIdUri');\n    if (scheme == null || scheme == 'urn:mpeg:dash:role:2011') {\n      // These only apply for the given scheme, but allow them to be specified\n      // if there is no scheme specified.\n      // See: DASH section 5.8.5.5\n      var value = roles[i].getAttribute('value');\n      switch (value) {\n        case 'main':\n          main = true;\n          break;\n        case 'caption':\n        case 'subtitle':\n          kind = value;\n          break;\n      }\n    }\n  }\n\n  // InbandEventStream indicates that a segment contains inband\n  // information.\n  var containsInband = this.inBandEventStreamIsPresent_(elem);\n\n  var supplementalProperties =\n      XmlUtils.findChildren(elem, 'SupplementalProperty');\n  var switchableIds = [];\n  supplementalProperties.forEach(function(prop) {\n    var schemeId = prop.getAttribute('schemeIdUri');\n    if (schemeId == 'urn:mpeg:dash:adaptation-set-switching:2016' ||\n        schemeId == 'http://dashif.org/guidelines/AdaptationSetSwitching' ||\n        schemeId == 'http://dashif.org/descriptor/AdaptationSetSwitching') {\n      var value = prop.getAttribute('value');\n      if (value)\n        switchableIds.push.apply(switchableIds, value.split(','));\n    }\n  });\n\n  var essentialProperties = XmlUtils.findChildren(elem, 'EssentialProperty');\n  // ID of real AdaptationSet if this is a trick mode set:\n  var trickModeFor = null;\n  var unrecognizedEssentialProperty = false;\n  essentialProperties.forEach(function(prop) {\n    var schemeId = prop.getAttribute('schemeIdUri');\n    if (schemeId == 'http://dashif.org/guidelines/trickmode') {\n      trickModeFor = prop.getAttribute('value');\n    } else {\n      unrecognizedEssentialProperty = true;\n    }\n  });\n  if (trickModeFor != null) {\n    // Ignore trick mode tracks until we support them fully.\n    return null;\n  }\n\n  // According to DASH spec (2014) section 5.8.4.8, \"the successful processing\n  // of the descriptor is essential to properly use the information in the\n  // parent element\".  According to DASH IOP v3.3, section 3.3.4, \"if the scheme\n  // or the value\" for EssentialProperty is not recognized, \"the DASH client\n  // shall ignore the parent element.\"\n  if (unrecognizedEssentialProperty) {\n    // Stop parsing this AdaptationSet and let the caller filter out the nulls.\n    return null;\n  }\n\n  var contentProtectionElems = XmlUtils.findChildren(elem, 'ContentProtection');\n  var contentProtection = shaka.dash.ContentProtection.parseFromAdaptationSet(\n      contentProtectionElems, this.config_.dash.customScheme);\n\n  var language =\n      shaka.util.LanguageUtils.normalize(elem.getAttribute('lang') || 'und');\n\n  // Parse Representations into Streams.\n  var representations = XmlUtils.findChildren(elem, 'Representation');\n  var streams = representations\n      .map(this.parseRepresentation_.bind(\n          this, context, contentProtection, kind, language))\n      .filter(function(s) { return !!s; });\n\n  if (streams.length == 0) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_EMPTY_ADAPTATION_SET);\n  }\n\n  if (!context.adaptationSet.contentType) {\n    // Guess the AdaptationSet's content type.\n    var mimeType = streams[0].mimeType;\n    var codecs = streams[0].codecs;\n    context.adaptationSet.contentType =\n        shaka.dash.DashParser.guessContentType_(mimeType, codecs);\n  }\n\n  var repIds = representations\n      .map(function(node) { return node.getAttribute('id'); })\n      .filter(shaka.util.Functional.isNotNull);\n\n  return {\n    id: context.adaptationSet.id || ('__fake__' + this.globalId_++),\n    contentType: context.adaptationSet.contentType,\n    language: language,\n    main: main,\n    streams: streams,\n    drmInfos: contentProtection.drmInfos,\n    switchableIds: switchableIds,\n    containsInband: containsInband,\n    representationIds: repIds\n  };\n};\n\n\n/**\n * Indicates whether an InbandEventStream element is present at the Adaption\n * Set or Representation level.\n *\n * @param {!Element} elem The AdaptationSet element.\n * @return {boolean} Whether the InbandEventStream element is present.\n * @private\n */\nshaka.dash.DashParser.prototype.inBandEventStreamIsPresent_ = function(elem) {\n  var XmlUtils = shaka.util.XmlUtils;\n\n  var adaptationEventStream = XmlUtils.findChild(elem, 'InbandEventStream');\n  if (adaptationEventStream != null) {\n    return true;\n  }\n\n  var representations = XmlUtils.findChildren(elem, 'Representation');\n  var representationEventStream = null;\n  if (representations.length > 0) {\n    for (var i = 0; i < representations.length; i++) {\n      representationEventStream =\n          XmlUtils.findChild(representations[i], 'InbandEventStream');\n\n      if (representationEventStream)\n        return true;\n    }\n  }\n\n  return false;\n};\n\n\n/**\n * Parses a Representation XML element.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {shaka.dash.ContentProtection.Context} contentProtection\n * @param {(string|undefined)} kind\n * @param {string} language\n * @param {!Element} node\n * @return {?shakaExtern.Stream} The Stream, or null when there is a\n *   non-critical parsing error.\n * @throws shaka.util.Error When there is a parsing error.\n * @private\n */\nshaka.dash.DashParser.prototype.parseRepresentation_ = function(\n    context, contentProtection, kind, language, node) {\n  var XmlUtils = shaka.util.XmlUtils;\n\n  context.representation = this.createFrame_(node, context.adaptationSet, null);\n  if (!this.verifyRepresentation_(context.representation)) {\n    shaka.log.warning('Skipping Representation', context.representation);\n    return null;\n  }\n\n  context.bandwidth =\n      XmlUtils.parseAttr(node, 'bandwidth', XmlUtils.parsePositiveInt) ||\n      undefined;\n\n  /** @type {?shaka.dash.DashParser.StreamInfo} */\n  var streamInfo;\n  var requestInitSegment = this.requestInitSegment_.bind(this);\n  if (context.representation.segmentBase) {\n    streamInfo = shaka.dash.SegmentBase.createStream(\n        context, requestInitSegment);\n  } else if (context.representation.segmentList) {\n    streamInfo = shaka.dash.SegmentList.createStream(\n        context, this.segmentIndexMap_);\n  } else if (context.representation.segmentTemplate) {\n    streamInfo = shaka.dash.SegmentTemplate.createStream(\n        context, requestInitSegment, this.segmentIndexMap_, !!this.manifest_);\n  } else {\n    goog.asserts.assert(context.representation.contentType == 'text' ||\n                        context.representation.contentType == 'application',\n                        'Must have Segment* with non-text streams.');\n\n    var baseUris = context.representation.baseUris;\n    var duration = context.periodInfo.duration || 0;\n    streamInfo = {\n      createSegmentIndex: Promise.resolve.bind(Promise),\n      findSegmentPosition:\n          /** @return {?number} */ function(/** number */ time) {\n            if (time >= 0 && time < duration)\n              return 1;\n            else\n              return null;\n          },\n      getSegmentReference:\n          /** @return {shaka.media.SegmentReference} */\n          function(/** number */ ref) {\n            if (ref != 1)\n              return null;\n\n            return new shaka.media.SegmentReference(\n                1, 0, duration, function() { return baseUris; }, 0, null);\n          },\n      initSegmentReference: null,\n      presentationTimeOffset: 0\n    };\n  }\n\n  var contentProtectionElems = XmlUtils.findChildren(node, 'ContentProtection');\n  var keyId = shaka.dash.ContentProtection.parseFromRepresentation(\n      contentProtectionElems, this.config_.dash.customScheme,\n      contentProtection);\n\n  return {\n    id: this.globalId_++,\n    createSegmentIndex: streamInfo.createSegmentIndex,\n    findSegmentPosition: streamInfo.findSegmentPosition,\n    getSegmentReference: streamInfo.getSegmentReference,\n    initSegmentReference: streamInfo.initSegmentReference,\n    presentationTimeOffset: streamInfo.presentationTimeOffset,\n    mimeType: context.representation.mimeType,\n    codecs: context.representation.codecs,\n    frameRate: context.representation.frameRate,\n    bandwidth: context.bandwidth,\n    width: context.representation.width,\n    height: context.representation.height,\n    kind: kind,\n    encrypted: contentProtection.drmInfos.length > 0,\n    keyId: keyId,\n    language: language,\n    allowedByApplication: true,\n    allowedByKeySystem: true\n  };\n};\n\n\n/**\n * Called when the update timer ticks.\n *\n * @private\n */\nshaka.dash.DashParser.prototype.onUpdate_ = function() {\n  goog.asserts.assert(this.updateTimer_, 'Should only be called by timer');\n  goog.asserts.assert(this.updatePeriod_ >= 0,\n                      'There should be an update period');\n\n  shaka.log.info('Updating manifest...');\n\n  this.updateTimer_ = null;\n  var startTime = Date.now();\n\n  this.requestManifest_().then(function() {\n    // Detect a call to stop()\n    if (!this.networkingEngine_)\n      return;\n\n    // Ensure the next update occurs within |updatePeriod_| seconds by taking\n    // into account the time it took to update the manifest.\n    var endTime = Date.now();\n    this.setUpdateTimer_((endTime - startTime) / 1000.0);\n  }.bind(this)).catch(function(error) {\n    goog.asserts.assert(error instanceof shaka.util.Error,\n                        'Should only receive a Shaka error');\n    this.onError_(error);\n\n    // Try updating again, but ensure we haven't been destroyed.\n    if (this.networkingEngine_) {\n      this.setUpdateTimer_(0);\n    }\n  }.bind(this));\n};\n\n\n/**\n * Sets the update timer.  Does nothing if the manifest does not specify an\n * update period.\n *\n * @param {number} offset An offset, in seconds, to apply to the manifest's\n *   update period.\n * @private\n */\nshaka.dash.DashParser.prototype.setUpdateTimer_ = function(offset) {\n  if (this.updatePeriod_ < 0)\n    return;\n  goog.asserts.assert(this.updateTimer_ == null,\n                      'Timer should not be already set');\n\n  var period =\n      Math.max(shaka.dash.DashParser.MIN_UPDATE_PERIOD_, this.updatePeriod_);\n  var interval = Math.max(period - offset, 0);\n  shaka.log.debug('updateInterval', interval);\n\n  var callback = this.onUpdate_.bind(this);\n  this.updateTimer_ = window.setTimeout(callback, 1000 * interval);\n};\n\n\n/**\n * Creates a new inheritance frame for the given element.\n *\n * @param {!Element} elem\n * @param {?shaka.dash.DashParser.InheritanceFrame} parent\n * @param {Array.<string>} baseUris\n * @return {shaka.dash.DashParser.InheritanceFrame}\n * @private\n */\nshaka.dash.DashParser.prototype.createFrame_ = function(\n    elem, parent, baseUris) {\n  goog.asserts.assert(parent || baseUris,\n                      'Must provide either parent or baseUris');\n  var MpdUtils = shaka.dash.MpdUtils;\n  var XmlUtils = shaka.util.XmlUtils;\n  parent = parent || /** @type {shaka.dash.DashParser.InheritanceFrame} */ ({\n    contentType: '',\n    mimeType: '',\n    codecs: '',\n    frameRate: undefined\n  });\n  baseUris = baseUris || parent.baseUris;\n\n  var parseNumber = XmlUtils.parseNonNegativeInt;\n  var evalDivision = XmlUtils.evalDivision;\n  var uris = XmlUtils.findChildren(elem, 'BaseURL').map(XmlUtils.getContents);\n\n  var contentType = elem.getAttribute('contentType') || parent.contentType;\n  var mimeType = elem.getAttribute('mimeType') || parent.mimeType;\n  var codecs = elem.getAttribute('codecs') || parent.codecs;\n  var frameRate = XmlUtils.parseAttr(elem, 'frameRate',\n      evalDivision) || parent.frameRate;\n\n  if (!contentType) {\n    contentType = shaka.dash.DashParser.guessContentType_(mimeType, codecs);\n  }\n\n  return {\n    baseUris: MpdUtils.resolveUris(baseUris, uris),\n    segmentBase: XmlUtils.findChild(elem, 'SegmentBase') || parent.segmentBase,\n    segmentList: XmlUtils.findChild(elem, 'SegmentList') || parent.segmentList,\n    segmentTemplate:\n        XmlUtils.findChild(elem, 'SegmentTemplate') || parent.segmentTemplate,\n    width: XmlUtils.parseAttr(elem, 'width', parseNumber) || parent.width,\n    height: XmlUtils.parseAttr(elem, 'height', parseNumber) || parent.height,\n    contentType: contentType,\n    mimeType: mimeType,\n    codecs: codecs,\n    frameRate: frameRate,\n    id: elem.getAttribute('id')\n  };\n};\n\n\n/**\n * Creates the StreamSet objects for the given AdaptationSets.  This will group\n * stream sets according to which streams it can switch to.  If AdaptationSet\n * A can switch to B, it is assumed that B can switch to A (as well as any\n * stream that A can switch to).\n *\n * @param {!Array.<shaka.dash.DashParser.AdaptationInfo>} adaptationSets\n * @return {!Array.<shakaExtern.StreamSet>}\n * @private\n */\nshaka.dash.DashParser.prototype.createStreamSets_ = function(adaptationSets) {\n  var Functional = shaka.util.Functional;\n  /**\n   * A map of ID to the group it belongs to.  Multiple IDs can map to the same\n   * group.  Each entry in the group will map back to the same array.\n   * @type {!Object.<string, !Array.<shaka.dash.DashParser.AdaptationInfo>>}\n   */\n  var groupMap = {};\n\n  // Create an initial map of all AS.\n  adaptationSets.forEach(function(set) { groupMap[set.id] = [set]; });\n\n  // Merge any AdaptationSets that can switch to each other.\n  adaptationSets.forEach(function(set) {\n    var group = groupMap[set.id];\n    set.switchableIds.forEach(function(id) {\n      var otherGroup = groupMap[id];\n      if (!otherGroup || otherGroup == group)\n        return;\n\n      // Merge the other group into the new one.\n      group.push.apply(group, otherGroup);\n\n      // Update each ID of the old group to map to the new group.\n      otherGroup.forEach(function(other) {\n        groupMap[other.id] = group;\n      });\n    });\n  });\n\n  /** @type {!Array.<shakaExtern.StreamSet>} */\n  var ret = [];\n  /** @type {!Array.<!Array.<shaka.dash.DashParser.AdaptationInfo>>} */\n  var seenGroups = [];\n\n  shaka.util.MapUtils.values(groupMap).forEach(function(group) {\n    if (seenGroups.indexOf(group) >= 0)\n      return;\n\n    seenGroups.push(group);\n\n    // First group AdaptationSets by type.\n    var setsByType = new shaka.util.MultiMap();\n    group.forEach(function(set) {\n      setsByType.push(set.contentType || '', set);\n    });\n\n    setsByType.keys().forEach(function(type) {\n      // Finally group AdaptationSets of the same type and group by language,\n      // then squash them into the same StreamSetInfo.\n      var setsByLang = new shaka.util.MultiMap();\n      setsByType.get(type).forEach(function(set) {\n        setsByLang.push(set.language, set);\n      });\n\n      setsByLang.keys().forEach(function(lang) {\n        var sets =\n            /** @type {!Array.<shaka.dash.DashParser.AdaptationInfo>} */ (\n                setsByLang.get(lang));\n\n        /** @type {shakaExtern.StreamSet} */\n        var streamSet = {\n          language: lang,\n          type: type,\n          primary: sets.some(function(s) { return s.main; }),\n          drmInfos:\n              sets.map(function(s) { return s.drmInfos; })\n                  .reduce(Functional.collapseArrays, []),\n          streams:\n              sets.map(function(s) { return s.streams; })\n                  .reduce(Functional.collapseArrays, [])\n        };\n        ret.push(streamSet);\n      });  // forEach lang\n    });  // forEach type\n  });  // map groupId\n\n  return ret;\n};\n\n\n/**\n * Verifies that a Representation has exactly one Segment* element.  Prints\n * warnings if there is a problem.\n *\n * @param {shaka.dash.DashParser.InheritanceFrame} frame\n * @return {boolean} True if the Representation is usable; otherwise return\n *   false.\n * @private\n */\nshaka.dash.DashParser.prototype.verifyRepresentation_ = function(frame) {\n  var n = 0;\n  n += frame.segmentBase ? 1 : 0;\n  n += frame.segmentList ? 1 : 0;\n  n += frame.segmentTemplate ? 1 : 0;\n\n  if (n == 0) {\n    // TODO: extend with the list of MIME types registered to TextEngine.\n    if (frame.contentType == 'text' || frame.contentType == 'application') {\n      return true;\n    } else {\n      shaka.log.warning(\n          'Representation does not contain a segment information source:',\n          'the Representation must contain one of SegmentBase, SegmentList,',\n          'SegmentTemplate, or explicitly indicate that it is \"text\".',\n          frame);\n      return false;\n    }\n  }\n\n  if (n != 1) {\n    shaka.log.warning(\n        'Representation contains multiple segment information sources:',\n        'the Representation should only contain one of SegmentBase,',\n        'SegmentList, or SegmentTemplate.',\n        frame);\n    if (frame.segmentBase) {\n      shaka.log.info('Using SegmentBase by default.');\n      frame.segmentList = null;\n      frame.segmentTemplate = null;\n    } else {\n      goog.asserts.assert(frame.segmentList, 'There should be a SegmentList');\n      shaka.log.info('Using SegmentList by default.');\n      frame.segmentTemplate = null;\n    }\n  }\n\n  return true;\n};\n\n\n/**\n * Makes a request to the given URI and calculates the clock offset.\n *\n * @param {!Array.<string>} baseUris\n * @param {string} uri\n * @param {string} method\n * @return {!Promise.<number>}\n * @private\n */\nshaka.dash.DashParser.prototype.requestForTiming_ =\n    function(baseUris, uri, method) {\n  var requestUris = shaka.dash.MpdUtils.resolveUris(baseUris, [uri]);\n  var request = shaka.net.NetworkingEngine.makeRequest(\n      requestUris, this.config_.retryParameters);\n  request.method = method;\n  var type = shaka.net.NetworkingEngine.RequestType.MANIFEST;\n  return this.networkingEngine_.request(type, request).then(function(response) {\n    var text;\n    if (method == 'HEAD') {\n      if (!response.headers || !response.headers['date'])\n        return 0;\n\n      text = response.headers['date'];\n    } else {\n      text = shaka.util.StringUtils.fromUTF8(response.data);\n    }\n\n    var date = Date.parse(text);\n    return isNaN(date) ? 0 : (date - Date.now());\n  });\n};\n\n\n/**\n * Parses an array of UTCTiming elements.\n *\n * @param {!Array.<string>} baseUris\n * @param {!Array.<!Element>} elems\n * @param {boolean} isLive\n * @return {!Promise.<number>}\n * @private\n */\nshaka.dash.DashParser.prototype.parseUtcTiming_ =\n    function(baseUris, elems, isLive) {\n  var schemesAndValues = elems.map(function(elem) {\n    return {\n      scheme: elem.getAttribute('schemeIdUri'),\n      value: elem.getAttribute('value')\n    };\n  });\n\n  // If there's nothing specified in the manifest, but we have a default from\n  // the config, use that.\n  var clockSyncUri = this.config_.dash.clockSyncUri;\n  if (isLive && !schemesAndValues.length && clockSyncUri) {\n    schemesAndValues.push({\n      scheme: 'urn:mpeg:dash:utc:http-head:2014',\n      value: clockSyncUri\n    });\n  }\n\n  var Functional = shaka.util.Functional;\n  return Functional.createFallbackPromiseChain(schemesAndValues, function(sv) {\n    var scheme = sv.scheme;\n    var value = sv.value;\n    switch (scheme) {\n      // See DASH IOP Guidelines Section 4.7\n      // http://goo.gl/CQFNJT\n      case 'urn:mpeg:dash:utc:http-head:2014':\n      // Some old ISO23009-1 drafts used 2012.\n      case 'urn:mpeg:dash:utc:http-head:2012':\n        return this.requestForTiming_(baseUris, value, 'HEAD');\n      case 'urn:mpeg:dash:utc:http-xsdate:2014':\n      case 'urn:mpeg:dash:utc:http-iso:2014':\n      case 'urn:mpeg:dash:utc:http-xsdate:2012':\n      case 'urn:mpeg:dash:utc:http-iso:2012':\n        return this.requestForTiming_(baseUris, value, 'GET');\n      case 'urn:mpeg:dash:utc:direct:2014':\n      case 'urn:mpeg:dash:utc:direct:2012':\n        var date = Date.parse(value);\n        return isNaN(date) ? 0 : (date - Date.now());\n\n      case 'urn:mpeg:dash:utc:http-ntp:2014':\n      case 'urn:mpeg:dash:utc:ntp:2014':\n      case 'urn:mpeg:dash:utc:sntp:2014':\n        shaka.log.warning('NTP UTCTiming scheme is not supported');\n        return Promise.reject();\n      default:\n        shaka.log.warning(\n            'Unrecognized scheme in UTCTiming element', scheme);\n        return Promise.reject();\n    }\n  }.bind(this)).catch(function() {\n    if (isLive) {\n      shaka.log.warning(\n          'A UTCTiming element should always be given in live manifests! ' +\n          'This content may not play on clients with bad clocks!');\n    }\n    return 0;\n  });\n};\n\n\n/**\n * Makes a network request on behalf of SegmentBase.createStream.\n *\n * @param {!Array.<string>} uris\n * @param {?number} startByte\n * @param {?number} endByte\n * @return {!Promise.<!ArrayBuffer>}\n * @private\n */\nshaka.dash.DashParser.prototype.requestInitSegment_ = function(\n    uris, startByte, endByte) {\n  var requestType = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n  var request = shaka.net.NetworkingEngine.makeRequest(\n      uris, this.config_.retryParameters);\n  if (startByte != null) {\n    var end = (endByte != null ? endByte : '');\n    request.headers['Range'] = 'bytes=' + startByte + '-' + end;\n  }\n\n  return this.networkingEngine_.request(requestType, request)\n      .then(function(response) { return response.data; });\n};\n\n\n/**\n * Response filter that looks for presence of EMSG\n * boxes in segments. If a box is found, depending on the content it\n * either triggers the manifest update or dispatches an event with the\n * box content to the application.\n *\n * @param {shaka.net.NetworkingEngine.RequestType} type\n * @param {!shakaExtern.Response} response\n * @private\n */\nshaka.dash.DashParser.prototype.emsgResponseFilter_ = function(type, response) {\n  // Only look for segment responses:\n  if (type == shaka.net.NetworkingEngine.RequestType.SEGMENT) {\n    var reader = new shaka.util.DataViewReader(new DataView(response.data),\n        shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n    var boxSize = shaka.util.Mp4Parser.findBox(\n        shaka.dash.DashParser.BOX_TYPE_EMSG, reader);\n    if (boxSize != shaka.util.Mp4Parser.BOX_NOT_FOUND) {\n      var start = reader.getPosition() - 8;\n      var end = start + boxSize;\n      // skip version and flags\n      reader.skip(4);\n      var scheme_id = reader.readTerminatedString();\n      // scheme_id of \"urn:mpeg:dash:event:2012\" means it's\n      // time to update the manifest\n      if (scheme_id == shaka.dash.DashParser.DASH_EMSG_SCHEME_ID_URI) {\n        // trigger manifest update\n        this.requestManifest_();\n      } else {\n        // read rest of the data and dispatch event to the application\n        var value = reader.readTerminatedString();\n        var timescale = reader.readUint32();\n        var presentationTimeDelta = reader.readUint32();\n        var eventDuration = reader.readUint32();\n        var id = reader.readUint32();\n        var messageData = reader.readBytes(end - reader.getPosition());\n\n        /** @type {shakaExtern.EmsgInfo} */\n        var emsg = {\n          schemeIdUri: scheme_id,\n          value: value,\n          timescale: timescale,\n          presentationTimeDelta: presentationTimeDelta,\n          eventDuration: eventDuration,\n          id: id,\n          messageData: messageData\n        };\n\n        var event = new shaka.util.FakeEvent(\n            'emsg', { 'detail': emsg });\n        this.onEvent_(event);\n      }\n    }\n  }\n};\n\n\n/**\n * Guess the content type based on MIME type and codecs.\n *\n * @param {string} mimeType\n * @param {string} codecs\n * @return {string}\n * @private\n */\nshaka.dash.DashParser.guessContentType_ = function(mimeType, codecs) {\n  var fullMimeType = shaka.util.StreamUtils.getFullMimeType(mimeType, codecs);\n\n  if (shaka.media.TextEngine.isTypeSupported(fullMimeType)) {\n    // If it's supported by TextEngine, it's definitely text.\n    // We don't check MediaSourceEngine, because that would report support\n    // for platform-supported video and audio types as well.\n    return 'text';\n  }\n\n  // Otherwise, just split the MIME type.  This handles video and audio\n  // types well.\n  return mimeType.split('/')[0];\n};\n\n\n/** @const {number} */\nshaka.dash.DashParser.BOX_TYPE_EMSG = 0x656D7367;\n\n\n/** @const {string} */\nshaka.dash.DashParser.DASH_EMSG_SCHEME_ID_URI = 'urn:mpeg:dash:event:2012';\n\n\nshaka.media.ManifestParser.registerParserByExtension(\n    'mpd', shaka.dash.DashParser);\nshaka.media.ManifestParser.registerParserByMime(\n    'application/dash+xml', shaka.dash.DashParser);\n\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/dash/mpd_utils.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.dash.MpdUtils');\n\ngoog.require('goog.Uri');\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.XmlUtils');\n\n\n/**\n * @namespace shaka.dash.MpdUtils\n * @summary MPD processing utility functions.\n */\n\n\n/**\n * Specifies how tolerant the player is to inaccurate segment start times and\n * end times within a manifest. For example, gaps or overlaps between segments\n * in a SegmentTimeline which are greater than or equal to this value will\n * result in a warning message.\n *\n * @const {number}\n */\nshaka.dash.MpdUtils.GAP_OVERLAP_TOLERANCE_SECONDS = 1 / 15;\n\n\n/**\n * @typedef {{\n *   start: number,\n *   unscaledStart: number,\n *   end: number\n * }}\n *\n * @description\n * Defines a time range of a media segment.  Times are in seconds.\n *\n * @property {number} start\n *   The start time of the range.\n * @property {number} unscaledStart\n *   The start time of the range in representation timescale units.\n * @property {number} end\n *   The end time (exclusive) of the range.\n */\nshaka.dash.MpdUtils.TimeRange;\n\n\n/**\n * @typedef {{\n *   timescale: number,\n *   segmentDuration: ?number,\n *   startNumber: number,\n *   presentationTimeOffset: number,\n *   unscaledPresentationTimeOffset: number,\n *   timeline: Array.<shaka.dash.MpdUtils.TimeRange>\n * }}\n *\n * @description\n * Contains common information between SegmentList and SegmentTemplate items.\n *\n * @property {number} timescale\n *   The time-scale of the representation.\n * @property {?number} segmentDuration\n *   The duration of the segments in seconds, if given.\n * @property {number} startNumber\n *   The start number of the segments; 1 or greater.\n * @property {number} presentationTimeOffset\n *   The presentationTimeOffset of the representation, in seconds.\n * @property {number} unscaledPresentationTimeOffset\n *   The presentationTimeOffset of the representation, in timescale units.\n * @property {Array.<shaka.dash.MpdUtils.TimeRange>} timeline\n *   The timeline of the representation, if given.  Times in seconds.\n */\nshaka.dash.MpdUtils.SegmentInfo;\n\n\n/**\n * Fills a SegmentTemplate URI template. This function does not validate the\n * resulting URI.\n *\n * @param {string} uriTemplate\n * @param {?string} representationId\n * @param {?number} number\n * @param {?number} bandwidth\n * @param {?number} time\n * @return {string} A URI string.\n * @see ISO/IEC 23009-1:2014 section 5.3.9.4.4\n */\nshaka.dash.MpdUtils.fillUriTemplate = function(\n    uriTemplate, representationId, number, bandwidth, time) {\n  if (time !== null) {\n    goog.asserts.assert(Math.abs(time - Math.round(time)) < 0.2,\n                        'Calculated $Time$ values must be close to integers!');\n    time = Math.round(time);\n  }\n\n  /** @type {!Object.<string, ?number|?string>} */\n  var valueTable = {\n    'RepresentationID': representationId,\n    'Number': number,\n    'Bandwidth': bandwidth,\n    'Time': time\n  };\n\n  var re = /\\$(RepresentationID|Number|Bandwidth|Time)?(?:%0([0-9]+)d)?\\$/g;\n  var uri = uriTemplate.replace(re, function(match, name, widthString) {\n    if (match == '$$') {\n      return '$';\n    }\n\n    var value = valueTable[name];\n    goog.asserts.assert(value !== undefined, 'Unrecognized identifier');\n\n    // Note that |value| may be 0 or ''.\n    if (value == null) {\n      shaka.log.warning(\n          'URL template does not have an available substitution for identifier',\n          '\"' + name + '\":',\n          uriTemplate);\n      return match;\n    }\n\n    if (name == 'RepresentationID' && widthString) {\n      shaka.log.warning(\n          'URL template should not contain a width specifier for identifier',\n          '\"RepresentationID\":',\n          uriTemplate);\n      widthString = undefined;\n    }\n\n    var valueString = value.toString();\n\n    // Create padding string.\n    var width = window.parseInt(widthString, 10) || 1;\n    var paddingSize = Math.max(0, width - valueString.length);\n    var padding = (new Array(paddingSize + 1)).join('0');\n\n    return padding + valueString;\n  });\n\n  return uri;\n};\n\n\n/**\n * Expands a SegmentTimeline into an array-based timeline.  The results are in\n * seconds.\n *\n * @param {!Element} segmentTimeline\n * @param {number} timescale\n * @param {number} presentationTimeOffset\n * @param {number} periodDuration The Period's duration in seconds.\n *   Infinity indicates that the Period continues indefinitely.\n * @return {!Array.<shaka.dash.MpdUtils.TimeRange>}\n */\nshaka.dash.MpdUtils.createTimeline = function(\n    segmentTimeline, timescale, presentationTimeOffset, periodDuration) {\n  goog.asserts.assert(\n      timescale > 0 && timescale < Infinity,\n      'timescale must be a positive, finite integer');\n  goog.asserts.assert(periodDuration > 0,\n                      'period duration must be a positive integer');\n\n  // Alias.\n  var XmlUtils = shaka.util.XmlUtils;\n\n  var timePoints = XmlUtils.findChildren(segmentTimeline, 'S');\n\n  /** @type {!Array.<shaka.dash.MpdUtils.TimeRange>} */\n  var timeline = [];\n  var lastEndTime = 0;\n\n  for (var i = 0; i < timePoints.length; ++i) {\n    var timePoint = timePoints[i];\n    var t = XmlUtils.parseAttr(timePoint, 't', XmlUtils.parseNonNegativeInt);\n    var d = XmlUtils.parseAttr(timePoint, 'd', XmlUtils.parseNonNegativeInt);\n    var r = XmlUtils.parseAttr(timePoint, 'r', XmlUtils.parseInt);\n\n    // Adjust start considering the presentation time offset\n    if (t != null)\n      t -= presentationTimeOffset;\n\n    if (!d) {\n      shaka.log.warning(\n          '\"S\" element must have a duration:',\n          'ignoring the remaining \"S\" elements.',\n          timePoint);\n      return timeline;\n    }\n\n    var startTime = t != null ? t : lastEndTime;\n\n    var repeat = r || 0;\n    if (repeat < 0) {\n      if (i + 1 < timePoints.length) {\n        var nextTimePoint = timePoints[i + 1];\n        var nextStartTime = XmlUtils.parseAttr(\n            nextTimePoint, 't', XmlUtils.parseNonNegativeInt);\n        if (nextStartTime == null) {\n          shaka.log.warning(\n              '\"S\" element cannot have a negative repeat',\n              'if the next \"S\" element does not have a valid start time:',\n              'ignoring the remaining \"S\" elements.',\n              timePoint);\n          return timeline;\n        } else if (startTime >= nextStartTime) {\n          shaka.log.warning(\n              '\"S\" element cannot have a negative repeat',\n              'if its start time exceeds the next \"S\" element\\'s start time:',\n              'ignoring the remaining \"S\" elements.',\n              timePoint);\n          return timeline;\n        }\n        repeat = Math.ceil((nextStartTime - startTime) / d) - 1;\n      } else {\n        if (periodDuration == Infinity) {\n          // The DASH spec. actually allows the last \"S\" element to have a\n          // negative repeat value even when the Period has an infinite\n          // duration. No one uses this feature and no one ever should, ever.\n          shaka.log.warning(\n              'The last \"S\" element cannot have a negative repeat',\n              'if the Period has an infinite duration:',\n              'ignoring the last \"S\" element.',\n              timePoint);\n          return timeline;\n        } else if (startTime / timescale >= periodDuration) {\n          shaka.log.warning(\n              'The last \"S\" element cannot have a negative repeat',\n              'if its start time exceeds the Period\\'s duration:',\n              'igoring the last \"S\" element.',\n              timePoint);\n          return timeline;\n        }\n        repeat = Math.ceil((periodDuration * timescale - startTime) / d) - 1;\n      }\n    }\n\n    // The end of the last segment may end before the start of the current\n    // segment (a gap) or may end after the start of the current segment (an\n    // overlap). If there is a gap/overlap then stretch/compress the end of\n    // the last segment to the start of the current segment.\n    //\n    // Note: it is possible to move the start of the current segment to the\n    // end of the last segment, but this would complicate the computation of\n    // the $Time$ placeholder later on.\n    if ((timeline.length > 0) && (startTime != lastEndTime)) {\n      var delta = startTime - lastEndTime;\n\n      if (Math.abs(delta / timescale) >=\n          shaka.dash.MpdUtils.GAP_OVERLAP_TOLERANCE_SECONDS) {\n        shaka.log.warning(\n            'SegmentTimeline contains a large gap/overlap:',\n            'the content may have errors in it.',\n            timePoint);\n      }\n\n      timeline[timeline.length - 1].end = startTime / timescale;\n    }\n\n    for (var j = 0; j <= repeat; ++j) {\n      var endTime = startTime + d;\n      var item = {\n        start: startTime / timescale,\n        end: endTime / timescale,\n        unscaledStart: startTime\n      };\n      timeline.push(item);\n\n      startTime = endTime;\n      lastEndTime = endTime;\n    }\n  }\n\n  return timeline;\n};\n\n\n/**\n * Expands the first SegmentReference so it begins at the start of its Period\n * if it already begins close to the start of its Period, and expands or\n * contracts the last SegmentReference so it ends at the end of its Period for\n * VOD presentations.\n *\n * @param {boolean} dynamic\n * @param {?number} periodDuration\n * @param {!Array.<!shaka.media.SegmentReference>} references\n */\nshaka.dash.MpdUtils.fitSegmentReferences = function(\n    dynamic, periodDuration, references) {\n  if (references.length == 0)\n    return;\n\n  /** @const {number} */\n  var tolerance = shaka.dash.MpdUtils.GAP_OVERLAP_TOLERANCE_SECONDS;\n\n  var firstReference = references[0];\n  if (firstReference.startTime <= tolerance) {\n    // Note: if the segment actually starts past 0, the video element should\n    // automatically jump the gap since the gap is small.\n    references[0] =\n        new shaka.media.SegmentReference(\n            firstReference.position,\n            0, firstReference.endTime,\n            firstReference.getUris,\n            firstReference.startByte, firstReference.endByte);\n  }\n\n  if (dynamic)\n    return;\n  goog.asserts.assert(periodDuration != null,\n                      'Period duration must be known for static content!');\n  goog.asserts.assert(periodDuration != Infinity,\n                      'Period duration must be finite for static content!');\n\n  var lastReference = references[references.length - 1];\n\n  // Sanity check.\n  goog.asserts.assert(\n      lastReference.startTime < periodDuration,\n      'lastReference cannot begin after the end of the Period');\n  if (lastReference.startTime > periodDuration) return;\n\n  // Log warning if necessary.\n  if (lastReference.endTime <= periodDuration - tolerance) {\n    shaka.log.warning(\n        'The last segment should not end before the end of the Period.',\n        lastReference);\n  } else if (lastReference.endTime >= periodDuration + tolerance) {\n    shaka.log.warning(\n        'The last segment should not end after the end of the Period.',\n        lastReference);\n  }\n\n  // Adjust the last SegmentReference.\n  references[references.length - 1] =\n      new shaka.media.SegmentReference(\n          lastReference.position,\n          lastReference.startTime, periodDuration,\n          lastReference.getUris,\n          lastReference.startByte, lastReference.endByte);\n};\n\n\n/**\n * Resolves an array of relative URIs to the given base URIs.  This will result\n * in M*N number of URIs.\n *\n * @param {!Array.<string>} baseUris\n * @param {!Array.<string>} relativeUris\n * @return {!Array.<string>}\n */\nshaka.dash.MpdUtils.resolveUris = function(baseUris, relativeUris) {\n  var Functional = shaka.util.Functional;\n  if (relativeUris.length == 0)\n    return baseUris;\n\n  var relativeAsGoog =\n      relativeUris.map(function(uri) { return new goog.Uri(uri); });\n  // Resolve each URI relative to each base URI, creating an Array of Arrays.\n  // Then flatten the Arrays into a single Array.\n  return baseUris.map(function(uri) { return new goog.Uri(uri); })\n    .map(function(base) { return relativeAsGoog.map(base.resolve.bind(base)); })\n    .reduce(Functional.collapseArrays, [])\n    .map(function(uri) { return uri.toString(); });\n};\n\n\n/**\n * Parses common segment info for SegmentList and SegmentTemplate.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {function(?shaka.dash.DashParser.InheritanceFrame):Element} callback\n *   Gets the element that contains the segment info.\n * @return {shaka.dash.MpdUtils.SegmentInfo}\n */\nshaka.dash.MpdUtils.parseSegmentInfo = function(context, callback) {\n  goog.asserts.assert(\n      callback(context.representation),\n      'There must be at least one element of the given type.');\n  var MpdUtils = shaka.dash.MpdUtils;\n  var XmlUtils = shaka.util.XmlUtils;\n\n  var timescaleStr = MpdUtils.inheritAttribute(context, callback, 'timescale');\n  var timescale = 1;\n  if (timescaleStr) {\n    timescale = XmlUtils.parsePositiveInt(timescaleStr) || 1;\n  }\n\n  var durationStr = MpdUtils.inheritAttribute(context, callback, 'duration');\n  var segmentDuration = XmlUtils.parsePositiveInt(durationStr || '');\n  if (segmentDuration) {\n    segmentDuration /= timescale;\n  }\n\n  var startNumberStr =\n      MpdUtils.inheritAttribute(context, callback, 'startNumber');\n  var presentationTimeOffset =\n      MpdUtils.inheritAttribute(context, callback, 'presentationTimeOffset');\n  var startNumber = XmlUtils.parseNonNegativeInt(startNumberStr || '');\n  if (startNumberStr == null || startNumber == null)\n    startNumber = 1;\n\n  var timelineNode =\n      MpdUtils.inheritChild(context, callback, 'SegmentTimeline');\n  /** @type {Array.<shaka.dash.MpdUtils.TimeRange>} */\n  var timeline = null;\n  if (timelineNode) {\n    timeline = MpdUtils.createTimeline(\n        timelineNode, timescale, Number(presentationTimeOffset),\n        context.periodInfo.duration || Infinity);\n  }\n\n  var pto = (Number(presentationTimeOffset) / timescale) || 0;\n  return {\n    timescale: timescale,\n    segmentDuration: segmentDuration,\n    startNumber: startNumber,\n    presentationTimeOffset: pto,\n    unscaledPresentationTimeOffset: Number(presentationTimeOffset),\n    timeline: timeline\n  };\n};\n\n\n/**\n * Searches the inheritance for a Segment* with the given attribute.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {function(?shaka.dash.DashParser.InheritanceFrame):Element} callback\n *   Gets the Element that contains the attribute to inherit.\n * @param {string} attribute\n * @return {?string}\n */\nshaka.dash.MpdUtils.inheritAttribute = function(context, callback, attribute) {\n  var Functional = shaka.util.Functional;\n  goog.asserts.assert(\n      callback(context.representation),\n      'There must be at least one element of the given type');\n\n  /** @type {!Array.<!Element>} */\n  var nodes = [\n    callback(context.representation),\n    callback(context.adaptationSet),\n    callback(context.period)\n  ].filter(Functional.isNotNull);\n\n  return nodes\n      .map(function(s) { return s.getAttribute(attribute); })\n      .reduce(function(all, part) { return all || part; });\n};\n\n\n/**\n * Searches the inheritance for a Segment* with the given child.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {function(?shaka.dash.DashParser.InheritanceFrame):Element} callback\n *   Gets the Element that contains the child to inherit.\n * @param {string} child\n * @return {Element}\n */\nshaka.dash.MpdUtils.inheritChild = function(context, callback, child) {\n  var Functional = shaka.util.Functional;\n  goog.asserts.assert(\n      callback(context.representation),\n      'There must be at least one element of the given type');\n\n  /** @type {!Array.<!Element>} */\n  var nodes = [\n    callback(context.representation),\n    callback(context.adaptationSet),\n    callback(context.period)\n  ].filter(Functional.isNotNull);\n\n  var XmlUtils = shaka.util.XmlUtils;\n  return nodes\n      .map(function(s) { return XmlUtils.findChild(s, child); })\n      .reduce(function(all, part) { return all || part; });\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/dash/segment_base.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.dash.SegmentBase');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.dash.MpdUtils');\ngoog.require('shaka.log');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.Mp4SegmentIndexParser');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.WebmSegmentIndexParser');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.XmlUtils');\n\n\n/**\n * @namespace shaka.dash.SegmentBase\n * @summary A set of functions for parsing SegmentBase elements.\n */\n\n\n/**\n * Creates an init segment reference from a Context object.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {function(?shaka.dash.DashParser.InheritanceFrame):Element} callback\n * @return {shaka.media.InitSegmentReference}\n */\nshaka.dash.SegmentBase.createInitSegment = function(context, callback) {\n  var MpdUtils = shaka.dash.MpdUtils;\n  var XmlUtils = shaka.util.XmlUtils;\n\n  var initialization =\n      MpdUtils.inheritChild(context, callback, 'Initialization');\n  if (!initialization)\n    return null;\n\n  var resolvedUris = context.representation.baseUris;\n  var uri = initialization.getAttribute('sourceURL');\n  if (uri) {\n    resolvedUris =\n        MpdUtils.resolveUris(context.representation.baseUris, [uri]);\n  }\n\n  var startByte = 0;\n  var endByte = null;\n  var range = XmlUtils.parseAttr(initialization, 'range', XmlUtils.parseRange);\n  if (range) {\n    startByte = range.start;\n    endByte = range.end;\n  }\n\n  var getUris = function() { return resolvedUris; };\n  return new shaka.media.InitSegmentReference(getUris, startByte, endByte);\n};\n\n\n/**\n * Creates a new Stream object.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {shaka.dash.DashParser.RequestInitSegmentCallback} requestInitSegment\n * @throws shaka.util.Error When there is a parsing error.\n * @return {shaka.dash.DashParser.StreamInfo}\n */\nshaka.dash.SegmentBase.createStream = function(context, requestInitSegment) {\n  goog.asserts.assert(context.representation.segmentBase,\n                      'Should only be called with SegmentBase');\n  // Since SegmentBase does not need updates, simply treat any call as\n  // the initial parse.\n  var MpdUtils = shaka.dash.MpdUtils;\n  var SegmentBase = shaka.dash.SegmentBase;\n\n  var presentationTimeOffset = MpdUtils.inheritAttribute(\n      context, SegmentBase.fromInheritance_, 'presentationTimeOffset');\n\n  var init =\n      SegmentBase.createInitSegment(context, SegmentBase.fromInheritance_);\n  var index = SegmentBase.createSegmentIndex_(\n      context, requestInitSegment, init, Number(presentationTimeOffset));\n\n  return {\n    createSegmentIndex: index.createSegmentIndex,\n    findSegmentPosition: index.findSegmentPosition,\n    getSegmentReference: index.getSegmentReference,\n    initSegmentReference: init,\n    presentationTimeOffset: Number(presentationTimeOffset) || 0\n  };\n};\n\n\n/**\n * Creates segment index info for the given info.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {shaka.dash.DashParser.RequestInitSegmentCallback} requestInitSegment\n * @param {shaka.media.InitSegmentReference} init\n * @param {!Array.<string>} uris\n * @param {number} startByte\n * @param {?number} endByte\n * @param {string} containerType\n * @param {number} presentationTimeOffset\n * @return {shaka.dash.DashParser.SegmentIndexFunctions}\n */\nshaka.dash.SegmentBase.createSegmentIndexFromUris = function(\n    context, requestInitSegment, init, uris,\n    startByte, endByte, containerType, presentationTimeOffset) {\n  var presentationTimeline = context.presentationTimeline;\n  var periodStartTime = context.periodInfo.start;\n  var periodDuration = context.periodInfo.duration;\n\n  // Create a local variable to bind to so we can set to null to help the GC.\n  var localRequest = requestInitSegment;\n  var segmentIndex = null;\n  var create = function() {\n    var async = [\n      localRequest(uris, startByte, endByte),\n      containerType == 'webm' ?\n          localRequest(init.getUris(), init.startByte, init.endByte) :\n          null\n    ];\n\n    localRequest = null;\n    return Promise.all(async).then(function(results) {\n      var indexData = results[0];\n      var initData = results[1] || null;\n      var references = null;\n\n      if (containerType == 'mp4') {\n        references = shaka.media.Mp4SegmentIndexParser(\n            indexData, startByte, uris, presentationTimeOffset);\n      } else {\n        goog.asserts.assert(initData, 'WebM requires init data');\n        var parser = new shaka.media.WebmSegmentIndexParser();\n        references = parser.parse(indexData, initData, uris,\n            presentationTimeOffset);\n      }\n\n      shaka.dash.MpdUtils.fitSegmentReferences(\n          context.dynamic, periodDuration, references);\n      presentationTimeline.notifySegments(periodStartTime, references);\n\n      // Since containers are never updated, we don't need to store the\n      // segmentIndex in the map.\n      goog.asserts.assert(!segmentIndex,\n                          'Should not call createSegmentIndex twice');\n      segmentIndex = new shaka.media.SegmentIndex(references);\n    });\n  };\n  var get = function(i) {\n    goog.asserts.assert(segmentIndex, 'Must call createSegmentIndex first');\n    return segmentIndex.get(i);\n  };\n  var find = function(t) {\n    goog.asserts.assert(segmentIndex, 'Must call createSegmentIndex first');\n    return segmentIndex.find(t);\n  };\n\n  return {\n    createSegmentIndex: create,\n    findSegmentPosition: find,\n    getSegmentReference: get\n  };\n};\n\n\n/**\n * @param {?shaka.dash.DashParser.InheritanceFrame} frame\n * @return {Element}\n * @private\n */\nshaka.dash.SegmentBase.fromInheritance_ = function(frame) {\n  return frame.segmentBase;\n};\n\n\n/**\n * Creates segment index info from a Context object.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {shaka.dash.DashParser.RequestInitSegmentCallback} requestInitSegment\n * @param {shaka.media.InitSegmentReference} init\n * @param {number} presentationTimeOffset\n * @return {shaka.dash.DashParser.SegmentIndexFunctions}\n * @throws shaka.util.Error When there is a parsing error.\n * @private\n */\nshaka.dash.SegmentBase.createSegmentIndex_ = function(\n    context, requestInitSegment, init, presentationTimeOffset) {\n  var MpdUtils = shaka.dash.MpdUtils;\n  var SegmentBase = shaka.dash.SegmentBase;\n  var XmlUtils = shaka.util.XmlUtils;\n\n  var contentType = context.representation.contentType;\n  var containerType = context.representation.mimeType.split('/')[1];\n  if (contentType != 'text' && containerType != 'mp4' &&\n      containerType != 'webm') {\n    shaka.log.error(\n        'SegmentBase specifies an unsupported container type.',\n        context.representation);\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_UNSUPPORTED_CONTAINER);\n  }\n\n  if ((containerType == 'webm') && !init) {\n    shaka.log.error(\n        'SegmentBase does not contain sufficient segment information:',\n        'the SegmentBase uses a WebM container,',\n        'but does not contain an Initialization element.',\n        context.representation);\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_WEBM_MISSING_INIT);\n  }\n\n  var representationIndex = MpdUtils.inheritChild(\n      context, SegmentBase.fromInheritance_, 'RepresentationIndex');\n  var indexRangeElem = MpdUtils.inheritAttribute(\n      context, SegmentBase.fromInheritance_, 'indexRange');\n\n  var indexUris = context.representation.baseUris;\n  var indexRange = XmlUtils.parseRange(indexRangeElem || '');\n  if (representationIndex) {\n    var representationUri = representationIndex.getAttribute('sourceURL');\n    if (representationUri) {\n      indexUris = MpdUtils.resolveUris(\n          context.representation.baseUris, [representationUri]);\n    }\n\n    indexRange = XmlUtils.parseAttr(\n        representationIndex, 'range', XmlUtils.parseRange, indexRange);\n  }\n\n  if (!indexRange) {\n    shaka.log.error(\n        'SegmentBase does not contain sufficient segment information:',\n        'the SegmentBase does not contain @indexRange',\n        'or a RepresentationIndex element.',\n        context.representation);\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n  }\n\n  return shaka.dash.SegmentBase.createSegmentIndexFromUris(\n      context, requestInitSegment, init, indexUris, indexRange.start,\n      indexRange.end, containerType, presentationTimeOffset);\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/dash/segment_list.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.dash.SegmentList');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.dash.MpdUtils');\ngoog.require('shaka.dash.SegmentBase');\ngoog.require('shaka.log');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.XmlUtils');\n\n\n/**\n * @namespace shaka.dash.SegmentList\n * @summary A set of functions for parsing SegmentList elements.\n */\n\n\n/**\n * Creates a new Stream object or updates the Stream in the manifest.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {!Object.<string, !shaka.media.SegmentIndex>} segmentIndexMap\n * @return {shaka.dash.DashParser.StreamInfo}\n */\nshaka.dash.SegmentList.createStream = function(context, segmentIndexMap) {\n  goog.asserts.assert(context.representation.segmentList,\n                      'Should only be called with SegmentList');\n  var SegmentList = shaka.dash.SegmentList;\n\n  var init = shaka.dash.SegmentBase.createInitSegment(\n      context, SegmentList.fromInheritance_);\n  var info = SegmentList.parseSegmentListInfo_(context);\n\n  SegmentList.checkSegmentListInfo_(context, info);\n\n  /** @type {shaka.media.SegmentIndex} */\n  var segmentIndex = null;\n  var id = null;\n  if (context.period.id && context.representation.id) {\n    // Only check/store the index if period and representation IDs are set.\n    id = context.period.id + ',' + context.representation.id;\n    segmentIndex = segmentIndexMap[id];\n  }\n\n  var references = SegmentList.createSegmentReferences_(\n      context.periodInfo.duration, info.startNumber,\n      context.representation.baseUris, info);\n  shaka.dash.MpdUtils.fitSegmentReferences(\n      context.dynamic, context.periodInfo.duration, references);\n  if (segmentIndex) {\n    segmentIndex.merge(references);\n    var start = context.presentationTimeline.getSegmentAvailabilityStart();\n    segmentIndex.evict(start - context.periodInfo.start);\n  } else {\n    context.presentationTimeline.notifySegments(\n        context.periodInfo.start, references);\n    segmentIndex = new shaka.media.SegmentIndex(references);\n    if (id)\n      segmentIndexMap[id] = segmentIndex;\n  }\n\n  return {\n    createSegmentIndex: Promise.resolve.bind(Promise),\n    findSegmentPosition: segmentIndex.find.bind(segmentIndex),\n    getSegmentReference: segmentIndex.get.bind(segmentIndex),\n    initSegmentReference: init,\n    presentationTimeOffset: info.presentationTimeOffset\n  };\n};\n\n\n/**\n * @typedef {{\n *   mediaUri: string,\n *   start: number,\n *   end: ?number\n * }}\n *\n * @property {string} mediaUri\n *   The URI of the segment.\n * @property {number} start\n *   The start byte of the segment.\n * @property {?number} end\n *   The end byte of the segment, or null.\n */\nshaka.dash.SegmentList.MediaSegment;\n\n\n/**\n * @typedef {{\n *   segmentDuration: ?number,\n *   startTime: number,\n *   startNumber: number,\n *   presentationTimeOffset: number,\n *   timeline: Array.<shaka.dash.MpdUtils.TimeRange>,\n *   mediaSegments: !Array.<shaka.dash.SegmentList.MediaSegment>\n * }}\n * @private\n *\n * @description\n * Contains information about a SegmentList.\n *\n * @property {?number} segmentDuration\n *   The duration of the segments, if given.\n * @property {number} startTime\n *   The start time of the first segment, in seconds.\n * @property {number} startNumber\n *   The start number of the segments; 1 or greater.\n * @property {number} presentationTimeOffset\n *   The presentationTimeOffset of the representation, in seconds.\n * @property {Array.<shaka.dash.MpdUtils.TimeRange>} timeline\n *   The timeline of the representation, if given.  Times in seconds.\n * @property {!Array.<shaka.dash.SegmentList.MediaSegment>} mediaSegments\n *   The URI and byte-ranges of the media segments.\n */\nshaka.dash.SegmentList.SegmentListInfo;\n\n\n/**\n * @param {?shaka.dash.DashParser.InheritanceFrame} frame\n * @return {Element}\n * @private\n */\nshaka.dash.SegmentList.fromInheritance_ = function(frame) {\n  return frame.segmentList;\n};\n\n\n/**\n * Parses the SegmentList items to create an info object.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @return {shaka.dash.SegmentList.SegmentListInfo}\n * @private\n */\nshaka.dash.SegmentList.parseSegmentListInfo_ = function(context) {\n  var SegmentList = shaka.dash.SegmentList;\n  var MpdUtils = shaka.dash.MpdUtils;\n\n  var mediaSegments = SegmentList.parseMediaSegments_(context);\n  var segmentInfo =\n      MpdUtils.parseSegmentInfo(context, SegmentList.fromInheritance_);\n\n  var startNumber = segmentInfo.startNumber;\n  if (startNumber === 0) {\n    shaka.log.warning('SegmentList@startNumber must be > 0');\n    startNumber = 1;\n  }\n\n  var startTime = 0;\n  if (segmentInfo.segmentDuration) {\n    // See DASH sec. 5.3.9.5.3\n    // Don't use presentationTimeOffset for @duration.\n    startTime = segmentInfo.segmentDuration * (startNumber - 1);\n  } else if (segmentInfo.timeline && segmentInfo.timeline.length > 0) {\n    // The presentationTimeOffset was considered in timeline creation\n    startTime = segmentInfo.timeline[0].start;\n  }\n\n  return {\n    segmentDuration: segmentInfo.segmentDuration,\n    startTime: startTime,\n    startNumber: startNumber,\n    presentationTimeOffset: segmentInfo.presentationTimeOffset,\n    timeline: segmentInfo.timeline,\n    mediaSegments: mediaSegments\n  };\n};\n\n\n/**\n * Checks whether a SegmentListInfo object is valid.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {shaka.dash.SegmentList.SegmentListInfo} info\n * @throws shaka.util.Error When there is a parsing error.\n * @private\n */\nshaka.dash.SegmentList.checkSegmentListInfo_ = function(context, info) {\n  if (!info.segmentDuration && !info.timeline &&\n      info.mediaSegments.length > 1) {\n    shaka.log.warning(\n        'SegmentList does not contain sufficient segment information:',\n        'the SegmentList specifies multiple segments,',\n        'but does not specify a segment duration or timeline.',\n        context.representation);\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n  }\n\n  if (!info.segmentDuration && !context.periodInfo.duration && !info.timeline &&\n      info.mediaSegments.length == 1) {\n    shaka.log.warning(\n        'SegmentList does not contain sufficient segment information:',\n        'the SegmentList specifies one segment,',\n        'but does not specify a segment duration, period duration,',\n        'or timeline.',\n        context.representation);\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n  }\n\n  if (info.timeline && info.timeline.length == 0) {\n    shaka.log.warning(\n        'SegmentList does not contain sufficient segment information:',\n        'the SegmentList has an empty timeline.',\n        context.representation);\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n  }\n};\n\n\n/**\n * Creates an array of segment references for the given data.\n *\n * @param {?number} periodDuration in seconds.\n * @param {number} startNumber\n * @param {!Array.<string>} baseUris\n * @param {shaka.dash.SegmentList.SegmentListInfo} info\n * @return {!Array.<!shaka.media.SegmentReference>}\n * @private\n */\nshaka.dash.SegmentList.createSegmentReferences_ = function(\n    periodDuration, startNumber, baseUris, info) {\n  var MpdUtils = shaka.dash.MpdUtils;\n\n  var max = info.mediaSegments.length;\n  if (info.timeline && info.timeline.length != info.mediaSegments.length) {\n    max = Math.min(info.timeline.length, info.mediaSegments.length);\n    shaka.log.warning(\n        'The number of items in the segment timeline and the number of segment',\n        'URLs do not match, truncating', info.mediaSegments.length, 'to', max);\n  }\n\n  /** @type {!Array.<!shaka.media.SegmentReference>} */\n  var references = [];\n  var prevEndTime = info.startTime;\n  for (var i = 0; i < max; i++) {\n    var segment = info.mediaSegments[i];\n    var mediaUri = MpdUtils.resolveUris(baseUris, [segment.mediaUri]);\n\n    var startTime = prevEndTime;\n    var endTime;\n\n    if (info.segmentDuration != null) {\n      endTime = startTime + info.segmentDuration;\n    } else if (info.timeline) {\n      // Ignore the timepoint start since they are continuous.\n      endTime = info.timeline[i].end;\n    } else {\n      // If segmentDuration and timeline are null then there must\n      // only be one segment.\n      goog.asserts.assert(\n          info.mediaSegments.length == 1 && periodDuration,\n          'There should only be one segment with a Period duration.');\n      endTime = startTime + periodDuration;\n    }\n\n    var getUris = (function(uris) { return uris; }.bind(null, mediaUri));\n    references.push(\n        new shaka.media.SegmentReference(\n            i + startNumber, startTime, endTime, getUris, segment.start,\n            segment.end));\n    prevEndTime = endTime;\n  }\n\n  return references;\n};\n\n\n/**\n * Parses the media URIs from the context.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @return {!Array.<shaka.dash.SegmentList.MediaSegment>}\n * @private\n */\nshaka.dash.SegmentList.parseMediaSegments_ = function(context) {\n  var Functional = shaka.util.Functional;\n  /** @type {!Array.<!Element>} */\n  var segmentLists = [\n    context.representation.segmentList,\n    context.adaptationSet.segmentList,\n    context.period.segmentList\n  ].filter(Functional.isNotNull);\n\n  var XmlUtils = shaka.util.XmlUtils;\n  // Search each SegmentList for one with at least one SegmentURL element,\n  // select the first one, and convert each SegmentURL element to a tuple.\n  return segmentLists\n      .map(function(node) { return XmlUtils.findChildren(node, 'SegmentURL'); })\n      .reduce(function(all, part) { return all.length > 0 ? all : part; })\n      .map(function(urlNode) {\n        if (urlNode.getAttribute('indexRange') &&\n            !context.indexRangeWarningGiven) {\n          context.indexRangeWarningGiven = true;\n          shaka.log.warning(\n              'We do not support the SegmentURL@indexRange attribute on ' +\n              'SegmentList.  We only use the SegmentList@duration attribute ' +\n              'or SegmentTimeline, which must be accurate.');\n        }\n\n        var uri = urlNode.getAttribute('media');\n        var range = XmlUtils.parseAttr(\n            urlNode, 'mediaRange', XmlUtils.parseRange, {start: 0, end: null});\n        return {mediaUri: uri, start: range.start, end: range.end};\n      });\n};\n\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/dash/segment_template.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.dash.SegmentTemplate');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.dash.MpdUtils');\ngoog.require('shaka.dash.SegmentBase');\ngoog.require('shaka.log');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.Error');\n\n\n/**\n * @namespace shaka.dash.SegmentTemplate\n * @summary A set of functions for parsing SegmentTemplate elements.\n */\n\n\n/**\n * Creates a new Stream object or updates the Stream in the manifest.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {shaka.dash.DashParser.RequestInitSegmentCallback} requestInitSegment\n * @param {!Object.<string, !shaka.media.SegmentIndex>} segmentIndexMap\n * @param {boolean} isUpdate True if the manifest is being updated.\n * @throws shaka.util.Error When there is a parsing error.\n * @return {shaka.dash.DashParser.StreamInfo}\n */\nshaka.dash.SegmentTemplate.createStream = function(\n    context, requestInitSegment, segmentIndexMap, isUpdate) {\n  goog.asserts.assert(context.representation.segmentTemplate,\n                      'Should only be called with SegmentTemplate');\n  var SegmentTemplate = shaka.dash.SegmentTemplate;\n\n  var init = SegmentTemplate.createInitSegment_(context);\n  var info = SegmentTemplate.parseSegmentTemplateInfo_(context);\n\n  SegmentTemplate.checkSegmentTemplateInfo_(context, info);\n\n  /** @type {?shaka.dash.DashParser.SegmentIndexFunctions} */\n  var segmentIndexFunctions = null;\n  if (info.indexTemplate) {\n    segmentIndexFunctions = SegmentTemplate.createFromIndexTemplate_(\n        context, requestInitSegment, init, info);\n  } else if (info.segmentDuration) {\n    if (!isUpdate) {\n      context.presentationTimeline.notifyMaxSegmentDuration(\n          info.segmentDuration);\n    }\n    segmentIndexFunctions = SegmentTemplate.createFromDuration_(context, info);\n  } else {\n    /** @type {shaka.media.SegmentIndex} */\n    var segmentIndex = null;\n    var id = null;\n    if (context.period.id && context.representation.id) {\n      // Only check/store the index if period and representation IDs are set.\n      id = context.period.id + ',' + context.representation.id;\n      segmentIndex = segmentIndexMap[id];\n    }\n\n    var references = SegmentTemplate.createFromTimeline_(context, info);\n    shaka.dash.MpdUtils.fitSegmentReferences(\n        context.dynamic, context.periodInfo.duration, references);\n    if (segmentIndex) {\n      segmentIndex.merge(references);\n      var start = context.presentationTimeline.getSegmentAvailabilityStart();\n      segmentIndex.evict(start - context.periodInfo.start);\n    } else {\n      context.presentationTimeline.notifySegments(\n          context.periodInfo.start, references);\n      segmentIndex = new shaka.media.SegmentIndex(references);\n      if (id)\n        segmentIndexMap[id] = segmentIndex;\n    }\n\n    segmentIndexFunctions = {\n      createSegmentIndex: Promise.resolve.bind(Promise),\n      findSegmentPosition: segmentIndex.find.bind(segmentIndex),\n      getSegmentReference: segmentIndex.get.bind(segmentIndex)\n    };\n  }\n\n  return {\n    createSegmentIndex: segmentIndexFunctions.createSegmentIndex,\n    findSegmentPosition: segmentIndexFunctions.findSegmentPosition,\n    getSegmentReference: segmentIndexFunctions.getSegmentReference,\n    initSegmentReference: init,\n    presentationTimeOffset: info.presentationTimeOffset\n  };\n};\n\n\n/**\n * @typedef {{\n *   timescale: number,\n *   segmentDuration: ?number,\n *   startNumber: number,\n *   presentationTimeOffset: number,\n *   unscaledPresentationTimeOffset: number,\n *   timeline: Array.<shaka.dash.MpdUtils.TimeRange>,\n *   mediaTemplate: ?string,\n *   indexTemplate: ?string\n * }}\n * @private\n *\n * @description\n * Contains information about a SegmentTemplate.\n *\n * @property {number} timescale\n *   The time-scale of the representation.\n * @property {?number} segmentDuration\n *   The duration of the segments in seconds, if given.\n * @property {number} startNumber\n *   The start number of the segments; 1 or greater.\n * @property {number} presentationTimeOffset\n *   The presentationTimeOffset of the representation, in seconds.\n * @property {number} unscaledPresentationTimeOffset\n *   The presentationTimeOffset of the representation, in timescale units.\n * @property {Array.<shaka.dash.MpdUtils.TimeRange>} timeline\n *   The timeline of the representation, if given.  Times in seconds.\n * @property {?string} mediaTemplate\n *   The media URI template, if given.\n * @property {?string} indexTemplate\n *   The index URI template, if given.\n */\nshaka.dash.SegmentTemplate.SegmentTemplateInfo;\n\n\n/**\n * @param {?shaka.dash.DashParser.InheritanceFrame} frame\n * @return {Element}\n * @private\n */\nshaka.dash.SegmentTemplate.fromInheritance_ = function(frame) {\n  return frame.segmentTemplate;\n};\n\n\n/**\n * Parses a SegmentTemplate element into an info object.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @return {shaka.dash.SegmentTemplate.SegmentTemplateInfo}\n * @private\n */\nshaka.dash.SegmentTemplate.parseSegmentTemplateInfo_ = function(context) {\n  var SegmentTemplate = shaka.dash.SegmentTemplate;\n  var MpdUtils = shaka.dash.MpdUtils;\n  var segmentInfo =\n      MpdUtils.parseSegmentInfo(context, SegmentTemplate.fromInheritance_);\n\n  var media = MpdUtils.inheritAttribute(\n      context, SegmentTemplate.fromInheritance_, 'media');\n  var index = MpdUtils.inheritAttribute(\n      context, SegmentTemplate.fromInheritance_, 'index');\n\n  return {\n    segmentDuration: segmentInfo.segmentDuration,\n    timescale: segmentInfo.timescale,\n    startNumber: segmentInfo.startNumber,\n    presentationTimeOffset: segmentInfo.presentationTimeOffset,\n    unscaledPresentationTimeOffset: segmentInfo.unscaledPresentationTimeOffset,\n    timeline: segmentInfo.timeline,\n    mediaTemplate: media,\n    indexTemplate: index\n  };\n};\n\n\n/**\n * Verifies a SegmentTemplate info object.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {shaka.dash.SegmentTemplate.SegmentTemplateInfo} info\n * @throws shaka.util.Error When there is a parsing error.\n * @private\n */\nshaka.dash.SegmentTemplate.checkSegmentTemplateInfo_ = function(context, info) {\n  var n = 0;\n  n += info.indexTemplate ? 1 : 0;\n  n += info.timeline ? 1 : 0;\n  n += info.segmentDuration ? 1 : 0;\n\n  if (n == 0) {\n    shaka.log.error(\n        'SegmentTemplate does not contain any segment information:',\n        'the SegmentTemplate must contain either an index URL template',\n        'a SegmentTimeline, or a segment duration.',\n        context.representation);\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n  } else if (n != 1) {\n    shaka.log.warning(\n        'SegmentTemplate containes multiple segment information sources:',\n        'the SegmentTemplate should only contain an index URL template,',\n        'a SegmentTimeline or a segment duration.',\n        context.representation);\n    if (info.indexTemplate) {\n      shaka.log.info('Using the index URL template by default.');\n      info.timeline = null;\n      info.segmentDuration = null;\n    } else {\n      goog.asserts.assert(info.timeline, 'There should be a timeline');\n      shaka.log.info('Using the SegmentTimeline by default.');\n      info.segmentDuration = null;\n    }\n  }\n\n  if (!info.indexTemplate && !info.mediaTemplate) {\n    shaka.log.error(\n        'SegmentTemplate does not contain sufficient segment information:',\n        'the SegmentTemplate\\'s media URL template is missing.',\n        context.representation);\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n  }\n};\n\n\n/**\n * Creates segment index functions from a index URL template.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {shaka.dash.DashParser.RequestInitSegmentCallback} requestInitSegment\n * @param {shaka.media.InitSegmentReference} init\n * @param {shaka.dash.SegmentTemplate.SegmentTemplateInfo} info\n * @throws shaka.util.Error When there is a parsing error.\n * @return {shaka.dash.DashParser.SegmentIndexFunctions}\n * @private\n */\nshaka.dash.SegmentTemplate.createFromIndexTemplate_ = function(\n    context, requestInitSegment, init, info) {\n  var MpdUtils = shaka.dash.MpdUtils;\n\n  // Determine the container type.\n  var containerType = context.representation.mimeType.split('/')[1];\n  if ((containerType != 'mp4') && (containerType != 'webm')) {\n    shaka.log.error(\n        'SegmentTemplate specifies an unsupported container type.',\n        context.representation);\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_UNSUPPORTED_CONTAINER);\n  }\n\n  if ((containerType == 'webm') && !init) {\n    shaka.log.error(\n        'SegmentTemplate does not contain sufficient segment information:',\n        'the SegmentTemplate uses a WebM container,',\n        'but does not contain an initialization URL template.',\n        context.representation);\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.DASH_WEBM_MISSING_INIT);\n  }\n\n  goog.asserts.assert(info.indexTemplate, 'must be using index template');\n  var filledTemplate = MpdUtils.fillUriTemplate(\n      info.indexTemplate, context.representation.id,\n      null, context.bandwidth || null, null);\n\n  var resolvedUris =\n      MpdUtils.resolveUris(context.representation.baseUris, [filledTemplate]);\n  return shaka.dash.SegmentBase.createSegmentIndexFromUris(\n      context, requestInitSegment, init, resolvedUris, 0, null, containerType,\n      info.presentationTimeOffset);\n};\n\n\n/**\n * Creates segment index functions from a segment duration.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {shaka.dash.SegmentTemplate.SegmentTemplateInfo} info\n * @return {shaka.dash.DashParser.SegmentIndexFunctions}\n * @private\n */\nshaka.dash.SegmentTemplate.createFromDuration_ = function(context, info) {\n  goog.asserts.assert(info.mediaTemplate,\n                      'There should be a media template with duration');\n  var MpdUtils = shaka.dash.MpdUtils;\n\n  var periodDuration = context.periodInfo.duration;\n  var segmentDuration = info.segmentDuration;\n  var startNumber = info.startNumber;\n  var timescale = info.timescale;\n\n  var template = info.mediaTemplate;\n  var bandwidth = context.bandwidth || null;\n  var id = context.representation.id;\n  var baseUris = context.representation.baseUris;\n\n  var find = function(periodTime) {\n    if (periodTime < 0)\n      return null;\n    else if (periodDuration && periodTime >= periodDuration)\n      return null;\n\n    return Math.floor(periodTime / segmentDuration);\n  };\n  var get = function(position) {\n    var segmentStart = position * segmentDuration;\n\n    // Do not construct segments references that should not exist.\n    if (segmentStart < 0)\n      return null;\n    else if (periodDuration && segmentStart >= periodDuration)\n      return null;\n\n    var getUris = function() {\n      var mediaUri = MpdUtils.fillUriTemplate(\n          template, id, position + startNumber, bandwidth,\n          segmentStart * timescale);\n      return MpdUtils.resolveUris(baseUris, [mediaUri]);\n    };\n\n    return new shaka.media.SegmentReference(\n        position, segmentStart, segmentStart + segmentDuration, getUris, 0,\n        null);\n  };\n\n  return {\n    createSegmentIndex: Promise.resolve.bind(Promise),\n    findSegmentPosition: find,\n    getSegmentReference: get\n  };\n};\n\n\n/**\n * Creates segment references from a timeline.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @param {shaka.dash.SegmentTemplate.SegmentTemplateInfo} info\n * @return {!Array.<!shaka.media.SegmentReference>}\n * @private\n */\nshaka.dash.SegmentTemplate.createFromTimeline_ = function(context, info) {\n  goog.asserts.assert(info.mediaTemplate,\n                      'There should be a media template with a timeline');\n  var MpdUtils = shaka.dash.MpdUtils;\n\n  /** @type {!Array.<!shaka.media.SegmentReference>} */\n  var references = [];\n  for (var i = 0; i < info.timeline.length; i++) {\n    var start = info.timeline[i].start;\n    var unscaledStart = info.timeline[i].unscaledStart;\n    var end = info.timeline[i].end;\n\n    // Note: i = k - 1, where k indicates the k'th segment listed in the MPD.\n    // (See section 5.3.9.5.3 of the DASH spec.)\n    var segmentReplacement = i + info.startNumber;\n\n    // Consider the presentation time offset in segment uri computation\n    var timeReplacement = unscaledStart +\n        info.unscaledPresentationTimeOffset;\n    var createUris = (function(\n            template, repId, bandwidth, baseUris, segmentId, time) {\n          var mediaUri = MpdUtils.fillUriTemplate(\n              template, repId, segmentId, bandwidth, time);\n          return MpdUtils.resolveUris(baseUris, [mediaUri])\n              .map(function(g) { return g.toString(); });\n        }.bind(null, info.mediaTemplate, context.representation.id,\n               context.bandwidth || null, context.representation.baseUris,\n               segmentReplacement, timeReplacement));\n\n    references.push(new shaka.media.SegmentReference(\n        segmentReplacement, start, end, createUris, 0, null));\n  }\n\n  return references;\n};\n\n\n/**\n * Creates an init segment reference from a context object.\n *\n * @param {shaka.dash.DashParser.Context} context\n * @return {shaka.media.InitSegmentReference}\n * @private\n */\nshaka.dash.SegmentTemplate.createInitSegment_ = function(context) {\n  var MpdUtils = shaka.dash.MpdUtils;\n  var SegmentTemplate = shaka.dash.SegmentTemplate;\n\n  var initialization = MpdUtils.inheritAttribute(\n      context, SegmentTemplate.fromInheritance_, 'initialization');\n  if (!initialization)\n    return null;\n\n  var repId = context.representation.id;\n  var bandwidth = context.bandwidth || null;\n  var baseUris = context.representation.baseUris;\n  var getUris = function() {\n    goog.asserts.assert(initialization, 'Should have returned earler');\n    var filledTemplate = MpdUtils.fillUriTemplate(\n        initialization, repId, null, bandwidth, null);\n    var resolvedUris = MpdUtils.resolveUris(baseUris, [filledTemplate]);\n    return resolvedUris;\n  };\n\n  return new shaka.media.InitSegmentReference(getUris, 0, null);\n};\n\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/debug/asserts.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('goog.asserts');\n\n\n/**\n * @namespace goog.asserts\n * @summary An assertion framework which is compiled out for deployment.\n *   NOTE: this is not the closure library version.  This uses the same name so\n *   the closure compiler will be able to use the conditions to assist type\n *   checking.\n */\n\n\n/**\n * @define {boolean} true to enable asserts, false otherwise.\n */\ngoog.define('goog.asserts.ENABLE_ASSERTS', goog.DEBUG);\n\n\n/** @type {function(*, string)} */\ngoog.asserts.assert = function() {};\n\n\n/** @private */\ngoog.asserts.patchAssert_ = function() {\n  var assert = console.assert;\n\n  if (!assert) {\n    console.assert = function() {};\n  } else if (!assert.bind) {\n    // IE 9 does not provide a .bind for the built-in console functions.\n    console.assert = function() {\n      assert.apply(console, arguments);\n    };\n  }\n};\n\n\n// Install assert functions.\nif (goog.asserts.ENABLE_ASSERTS) {\n  goog.asserts.patchAssert_();\n\n  goog.asserts.assert = console.assert.bind(console);\n}\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/debug/timer.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.timer');\n\ngoog.require('shaka.log');\n\n\n/**\n * @namespace shaka.timer\n * @summary A performance timing framework.\n *   Used in both debugging and production builds.\n */\n\n\n/**\n * Begins a timer.\n *\n * @param {string} name\n */\nshaka.timer.begin = function(name) {\n  shaka.timer.timers_[name] = {\n    begin: shaka.timer.now_(),\n    end: NaN\n  };\n};\n\n\n/**\n * End a timer and log (debug) the elapsed time.\n * Does nothing if the timer has not begun.\n *\n * @param {string} name\n */\nshaka.timer.end = function(name) {\n  var record = shaka.timer.timers_[name];\n  if (!record) {\n    return;\n  }\n\n  record.end = shaka.timer.now_();\n  var diff = record.end - record.begin;\n  shaka.log.debug(name + ': ' + diff.toFixed(3) + 'ms');\n};\n\n\n/**\n * Log (debug) the diff between two or more completed timers and return it.\n * Does nothing if not all of the timers have begun.\n *\n * @param {string} name1\n * @param {string} name2\n * @param {...string} var_args\n * @return {number} The diff between the timers, or NaN if they have not all\n *   completed.\n */\nshaka.timer.diff = function(name1, name2, var_args) {\n  var t1 = shaka.timer.get(name1);\n  var t2 = shaka.timer.get(name2);\n  if (!t1 || !t2) {\n    return NaN;\n  }\n  var diff = t1 - t2;\n  var name = name1 + ' - ' + name2;\n\n  for (var i = 2; i < arguments.length; ++i) {\n    var name3 = arguments[i];\n    var t3 = shaka.timer.get(name3);\n    if (!t3) {\n      return NaN;\n    }\n    diff -= t3;\n    name += ' - ' + name3;\n  }\n\n  shaka.log.debug(name + ': ' + diff.toFixed(3) + 'ms');\n  return diff;\n};\n\n\n/**\n * Query a timer.\n *\n * @param {string} name\n * @return {number} The elapsed time in milliseconds, if the timer is complete.\n *   Returns NaN if the timer doesn't exist or hasn't ended yet.\n */\nshaka.timer.get = function(name) {\n  var record = shaka.timer.timers_[name];\n  if (!record || !record.end) {\n    return NaN;\n  }\n\n  return record.end - record.begin;\n};\n\n\n/** @private {function():number} */\nshaka.timer.now_ = window.performance && window.performance.now ?\n                       window.performance.now.bind(window.performance) :\n                       Date.now;\n\n\n/** @private {!Object.<string, {begin: number, end: number}>} */\nshaka.timer.timers_ = {};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/media/drm_engine.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.DrmEngine');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.ArrayUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.MapUtils');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.Timer');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n\n/**\n * @constructor\n * @param {!shaka.net.NetworkingEngine} networkingEngine\n * @param {function(!shaka.util.Error)} onError Called when an error occurs.\n * @param {function(!Object.<string, string>)} onKeyStatus Called when key\n *   status changes.  Argument is a map of hex key IDs to statuses.\n * @struct\n * @implements {shaka.util.IDestroyable}\n */\nshaka.media.DrmEngine = function(networkingEngine, onError, onKeyStatus) {\n  /** @private {Array.<string>} */\n  this.supportedTypes_ = null;\n\n  /** @private {MediaKeys} */\n  this.mediaKeys_ = null;\n\n  /** @private {HTMLMediaElement} */\n  this.video_ = null;\n\n  /** @private {boolean} */\n  this.initialized_ = false;\n\n  /** @private {?shakaExtern.DrmInfo} */\n  this.currentDrmInfo_ = null;\n\n  /** @private {shaka.util.EventManager} */\n  this.eventManager_ = new shaka.util.EventManager();\n\n  /** @private {!Array.<shaka.media.DrmEngine.ActiveSession>} */\n  this.activeSessions_ = [];\n\n  /** @private {!Array.<string>} */\n  this.offlineSessionIds_ = [];\n\n  /** @private {!shaka.util.PublicPromise} */\n  this.allSessionsLoaded_ = new shaka.util.PublicPromise();\n\n  /** @private {shaka.net.NetworkingEngine} */\n  this.networkingEngine_ = networkingEngine;\n\n  /** @private {?shakaExtern.DrmConfiguration} */\n  this.config_ = null;\n\n  /** @private {?function(!shaka.util.Error)} */\n  this.onError_ = (function(err) {\n    this.allSessionsLoaded_.reject(err);\n    onError(err);\n  }.bind(this));\n\n  /** @private {!Object.<string, string>} */\n  this.keyStatusByKeyId_ = {};\n\n  /** @private {?function(!Object.<string, string>)} */\n  this.onKeyStatus_ = onKeyStatus;\n\n  /** @private {shaka.util.Timer} */\n  this.keyStatusTimer_ = new shaka.util.Timer(\n      this.processKeyStatusChanges_.bind(this));\n\n  /** @private {boolean} */\n  this.destroyed_ = false;\n\n  /** @private {boolean} */\n  this.isOffline_ = false;\n\n  // Add a catch to the Promise to avoid console logs about uncaught errors.\n  this.allSessionsLoaded_.catch(function() {});\n};\n\n\n/**\n * @typedef {{\n *   loaded: boolean,\n *   initData: Uint8Array,\n *   session: !MediaKeySession,\n *   updatePromise: shaka.util.PublicPromise\n * }}\n *\n * @description A record to track sessions and suppress duplicate init data.\n * @property {boolean} loaded\n *   True once the key status has been updated (to a non-pending state).  This\n *   does not mean the session is 'usable'.\n * @property {Uint8Array} initData\n *   The init data used to create the session.\n * @property {!MediaKeySession} session\n *   The session object.\n * @property {shaka.util.PublicPromise} updatePromise\n *   An optional Promise that will be resolved/rejected on the next update()\n *   call.  This is used to track the 'license-release' message when calling\n *   remove().\n */\nshaka.media.DrmEngine.ActiveSession;\n\n\n/** @override */\nshaka.media.DrmEngine.prototype.destroy = function() {\n  var Functional = shaka.util.Functional;\n  this.destroyed_ = true;\n\n  var async = this.activeSessions_.map(function(activeSession) {\n    // Ignore any errors when closing the sessions.  One such error would be\n    // an invalid state error triggered by closing a session which has not\n    // generated any key requests.\n    // Chrome sometimes returns |undefined|: https://crbug.com/690664\n    var p = activeSession.session.close() || Promise.resolve();\n    return p.catch(Functional.noop);\n  });\n  this.allSessionsLoaded_.reject();\n\n  if (this.eventManager_)\n    async.push(this.eventManager_.destroy());\n\n  if (this.video_) {\n    goog.asserts.assert(!this.video_.src, 'video src must be removed first!');\n    async.push(this.video_.setMediaKeys(null).catch(Functional.noop));\n  }\n\n  if (this.keyStatusTimer_) {\n    this.keyStatusTimer_.cancel();\n  }\n  this.keyStatusTimer_ = null;\n\n  this.currentDrmInfo_ = null;\n  this.supportedTypes_ = null;\n  this.mediaKeys_ = null;\n  this.video_ = null;\n  this.eventManager_ = null;\n  this.activeSessions_ = [];\n  this.offlineSessionIds_ = [];\n  this.networkingEngine_ = null;  // We don't own it, don't destroy() it.\n  this.config_ = null;\n  this.onError_ = null;\n\n  return Promise.all(async);\n};\n\n\n/**\n * Called by the Player to provide an updated configuration any time it changes.\n * Must be called at least once before init().\n *\n * @param {shakaExtern.DrmConfiguration} config\n */\nshaka.media.DrmEngine.prototype.configure = function(config) {\n  this.config_ = config;\n};\n\n\n/**\n * Negotiate for a key system and set up MediaKeys.\n * @param {!shakaExtern.Manifest} manifest The manifest is read for MIME type\n *   and DRM information to query EME. If the 'clearKeys' configuration is\n *   used, the manifest will be modified to force the use of Clear Key.\n * @param {boolean} offline True if we are storing or loading offline content.\n * @return {!Promise} Resolved if/when a key system has been chosen.\n */\nshaka.media.DrmEngine.prototype.init = function(manifest, offline) {\n  goog.asserts.assert(this.config_,\n      'DrmEngine configure() must be called before init()!');\n\n  /** @type {!Object.<string, MediaKeySystemConfiguration>} */\n  var configsByKeySystem = {};\n\n  /** @type {!Array.<string>} */\n  var keySystemsInOrder = [];\n\n  // |isOffline_| determines what kind of session to create.  The argument to\n  // |prepareMediaKeyConfigs_| determines the kind of CDM to query for.  So\n  // we still need persistent state when we are loading offline sessions.\n  this.isOffline_ = offline;\n  this.offlineSessionIds_ = manifest.offlineSessionIds;\n  this.prepareMediaKeyConfigs_(\n      manifest, offline || manifest.offlineSessionIds.length > 0,\n      configsByKeySystem, keySystemsInOrder);\n\n  if (!keySystemsInOrder.length) {\n    // Unencrypted.\n    this.initialized_ = true;\n    return Promise.resolve();\n  }\n\n  return this.queryMediaKeys_(configsByKeySystem, keySystemsInOrder);\n};\n\n\n/**\n * Attach MediaKeys to the video element and start processing events.\n * @param {HTMLMediaElement} video\n * @return {!Promise}\n */\nshaka.media.DrmEngine.prototype.attach = function(video) {\n  if (!this.mediaKeys_) {\n    // Unencrypted, or so we think.  We listen for encrypted events in order to\n    // warn when the stream is encrypted, even though the manifest does not know\n    // it.\n    this.eventManager_.listen(video, 'encrypted', function(event) {\n      // Don't complain about this twice.\n      this.eventManager_.unlisten(video, 'encrypted');\n      this.onError_(new shaka.util.Error(\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.ENCRYPTED_CONTENT_WITHOUT_DRM_INFO));\n    }.bind(this));\n    return Promise.resolve();\n  }\n\n  this.video_ = video;\n\n  var setMediaKeys = this.video_.setMediaKeys(this.mediaKeys_);\n  setMediaKeys = setMediaKeys.catch(function(exception) {\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Category.DRM,\n        shaka.util.Error.Code.FAILED_TO_ATTACH_TO_VIDEO,\n        exception.message));\n  });\n\n  var setServerCertificate = null;\n  if (this.currentDrmInfo_.serverCertificate) {\n    setServerCertificate = this.mediaKeys_.setServerCertificate(\n        this.currentDrmInfo_.serverCertificate);\n    setServerCertificate = setServerCertificate.catch(function(exception) {\n      return Promise.reject(new shaka.util.Error(\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.INVALID_SERVER_CERTIFICATE,\n          exception.message));\n    });\n  }\n\n  return Promise.all([setMediaKeys, setServerCertificate]).then(function() {\n    if (this.destroyed_) return Promise.reject();\n\n    this.createOrLoad();\n    if (!this.currentDrmInfo_.initData.length &&\n        !this.offlineSessionIds_.length) {\n      // Explicit init data for any one stream or an offline session is\n      // sufficient to suppress 'encrypted' events for all streams.\n      var onEncrypted = /** @type {shaka.util.EventManager.ListenerType} */(\n          this.onEncrypted_.bind(this));\n      this.eventManager_.listen(this.video_, 'encrypted', onEncrypted);\n    }\n  }.bind(this)).catch(function(error) {\n    if (this.destroyed_) return Promise.resolve();  // Ignore destruction errors\n    return Promise.reject(error);\n  }.bind(this));\n};\n\n\n/**\n * Removes the given offline sessions and deletes their data.  Must call init()\n * before this.  This will wait until the 'license-release' message is handled\n * and the resulting Promise will be rejected if there is an error with that.\n *\n * @param {!Array.<string>} sessions\n * @return {!Promise}\n */\nshaka.media.DrmEngine.prototype.removeSessions = function(sessions) {\n  goog.asserts.assert(this.mediaKeys_ || !sessions.length,\n                      'Must call init() before removeSessions');\n  return Promise.all(sessions.map(function(sessionId) {\n    return this.loadOfflineSession_(sessionId).then(function(session) {\n      // This will be null on error, such as session not found.\n      if (session) {\n        var p = new shaka.util.PublicPromise();\n        // TODO: Consider adding a timeout to get the 'message' event.\n        // Note that the 'message' event will get raised after the remove()\n        // promise resolves.\n\n        for (var i = 0; i < this.activeSessions_.length; i++) {\n          if (this.activeSessions_[i].session == session) {\n            this.activeSessions_[i].updatePromise = p;\n            break;\n          }\n        }\n        return Promise.all([session.remove(), p]);\n      }\n    }.bind(this));\n  }.bind(this)));\n};\n\n\n/**\n * Creates the sessions for the init data and waits for them to become ready.\n *\n * @return {!Promise}\n */\nshaka.media.DrmEngine.prototype.createOrLoad = function() {\n  var initDatas = this.currentDrmInfo_ ? this.currentDrmInfo_.initData : [];\n  initDatas.forEach(function(initDataOverride) {\n    this.createTemporarySession_(\n        initDataOverride.initDataType, initDataOverride.initData);\n  }.bind(this));\n  this.offlineSessionIds_.forEach(function(sessionId) {\n    this.loadOfflineSession_(sessionId);\n  }.bind(this));\n\n  if (!initDatas.length && !this.offlineSessionIds_.length)\n    this.allSessionsLoaded_.resolve();\n  return this.allSessionsLoaded_;\n};\n\n\n/** @return {boolean} */\nshaka.media.DrmEngine.prototype.initialized = function() {\n  return this.initialized_;\n};\n\n\n/** @return {string} */\nshaka.media.DrmEngine.prototype.keySystem = function() {\n  return this.currentDrmInfo_ ? this.currentDrmInfo_.keySystem : '';\n};\n\n\n/**\n * Returns an array of the media types supported by the current key system.\n * These will be full mime types (e.g. 'video/webm; codecs=\"vp8\"').\n *\n * @return {Array.<string>}\n */\nshaka.media.DrmEngine.prototype.getSupportedTypes = function() {\n  return this.supportedTypes_;\n};\n\n\n/**\n * Returns the ID of the sessions currently active.\n *\n * @return {!Array.<string>}\n */\nshaka.media.DrmEngine.prototype.getSessionIds = function() {\n  return this.activeSessions_.map(function(session) {\n    return session.session.sessionId;\n  });\n};\n\n\n/**\n * Returns the DrmInfo that was used to initialize the current key system.\n *\n * @return {?shakaExtern.DrmInfo}\n */\nshaka.media.DrmEngine.prototype.getDrmInfo = function() {\n  return this.currentDrmInfo_;\n};\n\n\n/**\n * @param {!shakaExtern.Manifest} manifest\n * @param {boolean} offline True if we are storing or loading offline content.\n * @param {!Object.<string, MediaKeySystemConfiguration>} configsByKeySystem\n *   (Output parameter.)  A dictionary of configs, indexed by key system.\n * @param {!Array.<string>} keySystemsInOrder\n *   (Output parameter.)  A list of key systems in the order in which we\n *   encounter them.\n * @see https://goo.gl/nwdYnY for MediaKeySystemConfiguration spec\n * @private\n */\nshaka.media.DrmEngine.prototype.prepareMediaKeyConfigs_ =\n    function(manifest, offline, configsByKeySystem, keySystemsInOrder) {\n  var clearKeyDrmInfo = this.configureClearKey_();\n\n  manifest.periods.forEach(function(period) {\n    period.streamSets.forEach(function(streamSet) {\n      if (streamSet.type == 'text')\n        return;  // skip\n\n      // clearKey config overrides manifest DrmInfo if present.\n      // The manifest is modified so that filtering in Player still works.\n      if (clearKeyDrmInfo) {\n        streamSet.drmInfos = [clearKeyDrmInfo];\n      }\n\n      streamSet.drmInfos.forEach(function(drmInfo) {\n        this.fillInDrmInfoDefaults_(drmInfo);\n\n        var config = configsByKeySystem[drmInfo.keySystem];\n        if (!config) {\n          config = {\n            // ignore initDataTypes\n            audioCapabilities: [],\n            videoCapabilities: [],\n            distinctiveIdentifier: 'optional',\n            persistentState: offline ? 'required' : 'optional',\n            sessionTypes: [offline ? 'persistent-license' : 'temporary'],\n            label: drmInfo.keySystem,\n            drmInfos: []  // tracked by us, ignored by EME\n          };\n          configsByKeySystem[drmInfo.keySystem] = config;\n          keySystemsInOrder.push(drmInfo.keySystem);\n        }\n\n        config.drmInfos.push(drmInfo);\n\n        if (drmInfo.distinctiveIdentifierRequired)\n          config.distinctiveIdentifier = 'required';\n\n        if (drmInfo.persistentStateRequired)\n          config.persistentState = 'required';\n\n        /** @type {!Array.<!MediaKeySystemMediaCapability>} */\n        var capabilities = (streamSet.type == 'video') ?\n            config.videoCapabilities : config.audioCapabilities;\n        /** @type {string} */\n        var robustness = ((streamSet.type == 'video') ?\n            drmInfo.videoRobustness : drmInfo.audioRobustness) || '';\n\n        streamSet.streams.forEach(function(stream) {\n          var fullMimeType = stream.mimeType;\n          if (stream.codecs) {\n            fullMimeType += '; codecs=\"' + stream.codecs + '\"';\n          }\n\n          // Some DRM license providers requires that we have a default\n          // KID from manifest in the wrapped license request\n          // and needs to be accessible in a request filter\n          if (stream.keyId) {\n            drmInfo.keyIds.push(stream.keyId);\n          }\n\n          capabilities.push({\n            robustness: robustness,\n            contentType: fullMimeType\n          });\n        }.bind(this));  // streamSet.streams.forEach\n      }.bind(this));  // streamSet.drmInfos.forEach\n    }.bind(this));  // period.streamSets.forEach\n  }.bind(this));  // manifest.perios.forEach\n};\n\n\n/**\n * @param {!Object.<string, MediaKeySystemConfiguration>} configsByKeySystem\n *   A dictionary of configs, indexed by key system.\n * @param {!Array.<string>} keySystemsInOrder\n *   A list of key systems in the order in which we should query them.\n *   On a browser which supports multiple key systems, the order may indicate\n *   a real preference for the application.\n * @return {!Promise} Resolved if/when a key system has been chosen.\n * @private\n */\nshaka.media.DrmEngine.prototype.queryMediaKeys_ =\n    function(configsByKeySystem, keySystemsInOrder) {\n  if (keySystemsInOrder.length == 1 && keySystemsInOrder[0] == '') {\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Category.DRM,\n        shaka.util.Error.Code.NO_RECOGNIZED_KEY_SYSTEMS));\n  }\n\n  // Wait to reject this initial Promise until we have built the entire chain.\n  var instigator = new shaka.util.PublicPromise();\n  var p = instigator;\n\n  // Try key systems with configured license servers first.  We only have to try\n  // key systems without configured license servers for diagnostic reasons, so\n  // that we can differentiate between \"none of these key systems are available\"\n  // and \"some are available, but you did not configure them properly.\"  The\n  // former takes precedence.\n  [true, false].forEach(function(shouldHaveLicenseServer) {\n    keySystemsInOrder.forEach(function(keySystem) {\n      var config = configsByKeySystem[keySystem];\n\n      var hasLicenseServer = config.drmInfos.some(function(info) {\n        return !!info.licenseServerUri;\n      });\n      if (hasLicenseServer != shouldHaveLicenseServer) return;\n\n      // If there are no tracks of a type, these should be not present.\n      // Otherwise the query will fail.\n      if (config.audioCapabilities.length == 0) {\n        delete config.audioCapabilities;\n      }\n      if (config.videoCapabilities.length == 0) {\n        delete config.videoCapabilities;\n      }\n\n      p = p.catch(function() {\n        if (this.destroyed_) return Promise.reject();\n        return navigator.requestMediaKeySystemAccess(keySystem, [config]);\n      }.bind(this));\n    }.bind(this));\n  }.bind(this));\n\n  p = p.catch(function() {\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Category.DRM,\n        shaka.util.Error.Code.REQUESTED_KEY_SYSTEM_CONFIG_UNAVAILABLE));\n  });\n\n  p = p.then(function(mediaKeySystemAccess) {\n    if (this.destroyed_) return Promise.reject();\n\n    // TODO: Remove once Edge has released a fix for https://goo.gl/qMeV7v\n    var isEdge = navigator.userAgent.indexOf('Edge/') >= 0;\n\n    // Store the capabilities of the key system.\n    var realConfig = mediaKeySystemAccess.getConfiguration();\n    var audioCaps = realConfig.audioCapabilities || [];\n    var videoCaps = realConfig.videoCapabilities || [];\n    var caps = audioCaps.concat(videoCaps);\n    this.supportedTypes_ = caps.map(function(c) { return c.contentType; });\n    if (isEdge) {\n      // Edge 14 does not report correct capabilities.  It will only report the\n      // first MIME type even if the others are supported.  To work around this,\n      // set the supported types to null, which Player will use as a signal that\n      // the information is not available.\n      // See: https://goo.gl/qMeV7v\n      this.supportedTypes_ = null;\n    }\n    goog.asserts.assert(!this.supportedTypes_ || this.supportedTypes_.length,\n                        'We should get at least one supported MIME type');\n\n    var originalConfig = configsByKeySystem[mediaKeySystemAccess.keySystem];\n    this.createCurrentDrmInfo_(\n        mediaKeySystemAccess.keySystem, originalConfig,\n        originalConfig.drmInfos);\n\n    if (!this.currentDrmInfo_.licenseServerUri) {\n      return Promise.reject(new shaka.util.Error(\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.NO_LICENSE_SERVER_GIVEN));\n    }\n\n    return mediaKeySystemAccess.createMediaKeys();\n  }.bind(this)).then(function(mediaKeys) {\n    if (this.destroyed_) return Promise.reject();\n\n    this.mediaKeys_ = mediaKeys;\n    this.initialized_ = true;\n  }.bind(this)).catch(function(exception) {\n    if (this.destroyed_) return Promise.resolve();  // Ignore destruction errors\n\n    // Don't rewrap a shaka.util.Error from earlier in the chain:\n    this.currentDrmInfo_ = null;\n    this.supportedTypes_ = null;\n    if (exception instanceof shaka.util.Error) {\n      return Promise.reject(exception);\n    }\n\n    // We failed to create MediaKeys.  This generally shouldn't happen.\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Category.DRM,\n        shaka.util.Error.Code.FAILED_TO_CREATE_CDM,\n        exception.message));\n  }.bind(this));\n\n  instigator.reject();\n  return p;\n};\n\n\n/**\n * Use this.config_ to fill in missing values in drmInfo.\n * @param {shakaExtern.DrmInfo} drmInfo\n * @private\n */\nshaka.media.DrmEngine.prototype.fillInDrmInfoDefaults_ = function(drmInfo) {\n  var keySystem = drmInfo.keySystem;\n\n  if (!keySystem) {\n    // This is a placeholder from the manifest parser for an unrecognized key\n    // system.  Skip this entry, to avoid logging nonsensical errors.\n    return;\n  }\n\n  if (!drmInfo.licenseServerUri) {\n    var server = this.config_.servers[keySystem];\n    if (server) {\n      drmInfo.licenseServerUri = server;\n    } else {\n      shaka.log.error('No license server configured for ' + keySystem);\n    }\n  }\n\n  if (!drmInfo.keyIds) {\n    drmInfo.keyIds = [];\n  }\n\n  var advanced = this.config_.advanced[keySystem];\n  if (advanced) {\n    if (!drmInfo.distinctiveIdentifierRequired) {\n      drmInfo.distinctiveIdentifierRequired =\n          advanced.distinctiveIdentifierRequired;\n    }\n\n    if (!drmInfo.persistentStateRequired) {\n      drmInfo.persistentStateRequired = advanced.persistentStateRequired;\n    }\n\n    if (!drmInfo.videoRobustness) {\n      drmInfo.videoRobustness = advanced.videoRobustness;\n    }\n\n    if (!drmInfo.audioRobustness) {\n      drmInfo.audioRobustness = advanced.audioRobustness;\n    }\n\n    if (!drmInfo.serverCertificate) {\n      drmInfo.serverCertificate = advanced.serverCertificate;\n    }\n  }\n};\n\n\n/**\n * Create a DrmInfo using configured clear keys.\n * The server URI will be a data URI which decodes to a clearkey license.\n * @return {?shakaExtern.DrmInfo} or null if clear keys are not configured.\n * @private\n * @see https://goo.gl/6nPdhF for the spec on the clearkey license format.\n */\nshaka.media.DrmEngine.prototype.configureClearKey_ = function() {\n  var hasClearKeys = !shaka.util.MapUtils.empty(this.config_.clearKeys);\n  if (!hasClearKeys) return null;\n\n  var StringUtils = shaka.util.StringUtils;\n  var Uint8ArrayUtils = shaka.util.Uint8ArrayUtils;\n  var keys = [];\n  var keyIds = [];\n\n  for (var keyIdHex in this.config_.clearKeys) {\n    var keyHex = this.config_.clearKeys[keyIdHex];\n\n    var keyId = Uint8ArrayUtils.fromHex(keyIdHex);\n    var key = Uint8ArrayUtils.fromHex(keyHex);\n    var keyObj = {\n      kty: 'oct',\n      kid: Uint8ArrayUtils.toBase64(keyId, false),\n      k: Uint8ArrayUtils.toBase64(key, false)\n    };\n\n    keys.push(keyObj);\n    keyIds.push(keyObj.kid);\n  }\n\n  var jwkSet = {keys: keys};\n  var license = JSON.stringify(jwkSet);\n\n  // Use the keyids init data since is suggested by EME.\n  // Suggestion: https://goo.gl/R72xp4\n  // Format: https://goo.gl/75RCP6\n  var initDataStr = JSON.stringify({'kids': keyIds});\n  var initData = new Uint8Array(StringUtils.toUTF8(initDataStr));\n  var initDatas = [{initData: initData, initDataType: 'keyids'}];\n\n  return {\n    keySystem: 'org.w3.clearkey',\n    licenseServerUri: 'data:application/json;base64,' + window.btoa(license),\n    distinctiveIdentifierRequired: false,\n    persistentStateRequired: false,\n    audioRobustness: '',\n    videoRobustness: '',\n    serverCertificate: null,\n    initData: initDatas,\n    keyIds: []\n  };\n};\n\n\n/**\n * Creates a DrmInfo object describing the settings used to initialize the\n * engine.\n *\n * @param {string} keySystem\n * @param {MediaKeySystemConfiguration} config\n * @param {!Array.<shakaExtern.DrmInfo>} drmInfos\n * @private\n */\nshaka.media.DrmEngine.prototype.createCurrentDrmInfo_ = function(\n    keySystem, config, drmInfos) {\n  /** @type {!Array.<string>} */\n  var licenseServers = [];\n\n  /** @type {!Array.<!Uint8Array>} */\n  var serverCerts = [];\n\n  /** @type {!Array.<!shakaExtern.InitDataOverride>} */\n  var initDatas = [];\n\n  /** @type {!Array.<string>} */\n  var keyIds = [];\n\n  this.processDrmInfos_(drmInfos, licenseServers, serverCerts, initDatas,\n      keyIds);\n\n  if (serverCerts.length > 1) {\n    shaka.log.warning('Multiple unique server certificates found! ' +\n                      'Only the first will be used.');\n  }\n\n  if (licenseServers.length > 1) {\n    shaka.log.warning('Multiple unique license server URIs found! ' +\n                      'Only the first will be used.');\n  }\n\n  // TODO: This only works when all DrmInfo have the same robustness.\n  var audioRobustness =\n      config.audioCapabilities ? config.audioCapabilities[0].robustness : '';\n  var videoRobustness =\n      config.videoCapabilities ? config.videoCapabilities[0].robustness : '';\n  this.currentDrmInfo_ = {\n    keySystem: keySystem,\n    licenseServerUri: licenseServers[0],\n    distinctiveIdentifierRequired: (config.distinctiveIdentifier == 'required'),\n    persistentStateRequired: (config.persistentState == 'required'),\n    audioRobustness: audioRobustness,\n    videoRobustness: videoRobustness,\n    serverCertificate: serverCerts[0],\n    initData: initDatas,\n    keyIds: keyIds\n  };\n};\n\n\n/**\n * Extract license server, server cert, and init data from DrmInfos, taking\n * care to eliminate duplicates.\n *\n * @param {!Array.<shakaExtern.DrmInfo>} drmInfos\n * @param {!Array.<string>} licenseServers\n * @param {!Array.<!Uint8Array>} serverCerts\n * @param {!Array.<!shakaExtern.InitDataOverride>} initDatas\n * @param {!Array.<string>} keyIds\n * @private\n */\nshaka.media.DrmEngine.prototype.processDrmInfos_ =\n    function(drmInfos, licenseServers, serverCerts, initDatas, keyIds) {\n  /**\n   * @param {shakaExtern.InitDataOverride} a\n   * @param {shakaExtern.InitDataOverride} b\n   * @return {boolean}\n   */\n  function initDataOverrideEqual(a, b) {\n    return a.initDataType == b.initDataType &&\n           shaka.util.Uint8ArrayUtils.equal(a.initData, b.initData);\n  }\n\n  drmInfos.forEach(function(drmInfo) {\n    // Aliases:\n    var ArrayUtils = shaka.util.ArrayUtils;\n    var Uint8ArrayUtils = shaka.util.Uint8ArrayUtils;\n\n    // Build an array of unique license servers.\n    if (licenseServers.indexOf(drmInfo.licenseServerUri) == -1) {\n      licenseServers.push(drmInfo.licenseServerUri);\n    }\n\n    // Build an array of unique server certs.\n    if (drmInfo.serverCertificate) {\n      if (ArrayUtils.indexOf(serverCerts, drmInfo.serverCertificate,\n                             Uint8ArrayUtils.equal) == -1) {\n        serverCerts.push(drmInfo.serverCertificate);\n      }\n    }\n\n    // Build an array of unique init datas.\n    if (drmInfo.initData) {\n      drmInfo.initData.forEach(function(initDataOverride) {\n        if (ArrayUtils.indexOf(initDatas, initDataOverride,\n                               initDataOverrideEqual) == -1) {\n          initDatas.push(initDataOverride);\n        }\n      });\n    }\n\n    if (drmInfo.keyIds) {\n      for (var i = 0; i < drmInfo.keyIds.length; ++i) {\n        if (keyIds.indexOf(drmInfo.keyIds[i]) == -1) {\n          keyIds.push(drmInfo.keyIds[i]);\n        }\n      }\n    }\n  });\n};\n\n\n/**\n * @param {!MediaEncryptedEvent} event\n * @private\n */\nshaka.media.DrmEngine.prototype.onEncrypted_ = function(event) {\n  // Aliases:\n  var Uint8ArrayUtils = shaka.util.Uint8ArrayUtils;\n\n  var initData = new Uint8Array(event.initData);\n\n  // Suppress duplicate init data.\n  // Note that some init data are extremely large and can't portably be used as\n  // keys in a dictionary.\n  for (var i = 0; i < this.activeSessions_.length; ++i) {\n    if (Uint8ArrayUtils.equal(initData, this.activeSessions_[i].initData)) {\n      shaka.log.debug('Ignoring duplicate init data.');\n      return;\n    }\n  }\n\n  this.createTemporarySession_(event.initDataType, initData);\n};\n\n\n/**\n * @param {string} sessionId\n * @return {!Promise.<MediaKeySession>}\n * @private\n */\nshaka.media.DrmEngine.prototype.loadOfflineSession_ = function(sessionId) {\n  var session;\n  try {\n    session = this.mediaKeys_.createSession('persistent-license');\n  } catch (exception) {\n    var error = new shaka.util.Error(\n        shaka.util.Error.Category.DRM,\n        shaka.util.Error.Code.FAILED_TO_CREATE_SESSION,\n        exception.message);\n    this.onError_(error);\n    return Promise.reject(error);\n  }\n\n  this.eventManager_.listen(session, 'message',\n      /** @type {shaka.util.EventManager.ListenerType} */(\n          this.onSessionMessage_.bind(this)));\n  this.eventManager_.listen(session, 'keystatuseschange',\n      this.onKeyStatusesChange_.bind(this));\n\n  var activeSession =\n      {initData: null, session: session, loaded: false, updatePromise: null};\n  this.activeSessions_.push(activeSession);\n\n  return session.load(sessionId).then(function(present) {\n    if (this.destroyed_) return;\n\n    if (!present) {\n      var i = this.activeSessions_.indexOf(activeSession);\n      goog.asserts.assert(i >= 0, 'Session must be in the array');\n      this.activeSessions_.splice(i, 1);\n\n      this.onError_(new shaka.util.Error(\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.OFFLINE_SESSION_REMOVED));\n      return;\n    }\n\n    // TODO: We should get a key status change event.  Remove once Chrome CDM\n    // is fixed.\n    activeSession.loaded = true;\n    if (this.activeSessions_.every(function(s) { return s.loaded; }))\n      this.allSessionsLoaded_.resolve();\n\n    return session;\n  }.bind(this), function(error) {\n    if (this.destroyed_) return;\n\n    var i = this.activeSessions_.indexOf(activeSession);\n    goog.asserts.assert(i >= 0, 'Session must be in the array');\n    this.activeSessions_.splice(i, 1);\n\n    this.onError_(new shaka.util.Error(\n        shaka.util.Error.Category.DRM,\n        shaka.util.Error.Code.FAILED_TO_CREATE_SESSION,\n        error.message));\n  }.bind(this));\n};\n\n\n/**\n * @param {string} initDataType\n * @param {!Uint8Array} initData\n * @private\n */\nshaka.media.DrmEngine.prototype.createTemporarySession_ =\n    function(initDataType, initData) {\n  var session;\n  try {\n    if (this.isOffline_) {\n      session = this.mediaKeys_.createSession('persistent-license');\n    } else {\n      session = this.mediaKeys_.createSession();\n    }\n  } catch (exception) {\n    this.onError_(new shaka.util.Error(\n        shaka.util.Error.Category.DRM,\n        shaka.util.Error.Code.FAILED_TO_CREATE_SESSION,\n        exception.message));\n    return;\n  }\n\n  this.eventManager_.listen(session, 'message',\n      /** @type {shaka.util.EventManager.ListenerType} */(\n          this.onSessionMessage_.bind(this)));\n  this.eventManager_.listen(session, 'keystatuseschange',\n      this.onKeyStatusesChange_.bind(this));\n  this.activeSessions_.push({\n    initData: initData,\n    session: session,\n    loaded: false,\n    updatePromise: null\n  });\n\n  session.generateRequest(initDataType, initData.buffer).catch(function(error) {\n    if (this.destroyed_) return;\n\n    for (var i = 0; i < this.activeSessions_.length; ++i) {\n      if (this.activeSessions_[i].session == session) {\n        this.activeSessions_.splice(i, 1);\n        break;\n      }\n    }\n    this.onError_(new shaka.util.Error(\n        shaka.util.Error.Category.DRM,\n        shaka.util.Error.Code.FAILED_TO_GENERATE_LICENSE_REQUEST,\n        error.message));\n  }.bind(this));\n};\n\n\n/**\n * @param {!MediaKeyMessageEvent} event\n * @private\n */\nshaka.media.DrmEngine.prototype.onSessionMessage_ = function(event) {\n  /** @type {!MediaKeySession} */\n  var session = event.target;\n\n  var updatePromise;\n  for (var i = 0; i < this.activeSessions_.length; i++) {\n    if (this.activeSessions_[i].session == session) {\n      updatePromise = this.activeSessions_[i].updatePromise;\n      break;\n    }\n  }\n\n  var requestType = shaka.net.NetworkingEngine.RequestType.LICENSE;\n  var request = shaka.net.NetworkingEngine.makeRequest(\n      [this.currentDrmInfo_.licenseServerUri], this.config_.retryParameters);\n  request.body = event.message;\n  request.method = 'POST';\n  // NOTE: allowCrossSiteCredentials can be set in a request filter.\n\n  if (this.currentDrmInfo_.keySystem == 'com.microsoft.playready') {\n    this.unpackPlayReadyRequest_(request);\n  }\n\n  this.networkingEngine_.request(requestType, request)\n      .then(function(response) {\n        if (this.destroyed_) return Promise.reject();\n\n        // Request succeeded, now pass the response to the CDM.\n        return session.update(response.data).then(function() {\n          if (updatePromise)\n            updatePromise.resolve();\n        });\n      }.bind(this), function(error) {\n        // Ignore destruction errors\n        if (this.destroyed_) return Promise.resolve();\n\n        // Request failed!\n        goog.asserts.assert(error instanceof shaka.util.Error,\n                            'Wrong NetworkingEngine error type!');\n        var shakaErr = new shaka.util.Error(\n            shaka.util.Error.Category.DRM,\n            shaka.util.Error.Code.LICENSE_REQUEST_FAILED,\n            error);\n        this.onError_(shakaErr);\n        if (updatePromise)\n          updatePromise.reject(shakaErr);\n      }.bind(this)).catch(function(error) {\n        // Ignore destruction errors\n        if (this.destroyed_) return Promise.resolve();\n\n        // Session update failed!\n        var shakaErr = new shaka.util.Error(\n            shaka.util.Error.Category.DRM,\n            shaka.util.Error.Code.LICENSE_RESPONSE_REJECTED,\n            error.message);\n        this.onError_(shakaErr);\n        if (updatePromise)\n          updatePromise.reject(shakaErr);\n      }.bind(this));\n};\n\n\n/**\n * Unpack PlayReady license requests.  Modifies the request object.\n * @param {shakaExtern.Request} request\n * @private\n */\nshaka.media.DrmEngine.prototype.unpackPlayReadyRequest_ = function(request) {\n  // The PlayReady license message as it comes from the CDM can't be directly\n  // delivered to a license server.  Other CDMs do not seem to need this kind\n  // of special handling.\n\n  // The raw license message is UTF-16-encoded XML.  We need to unpack the\n  // Challenge element (base64-encoded string containing the actual license\n  // request) and any HttpHeader elements (sent as request headers).\n\n  // Example XML:\n\n  // <PlayReadyKeyMessage type=\"LicenseAcquisition\">\n  //   <LicenseAcquisition Version=\"1\">\n  //     <Challenge encoding=\"base64encoded\">{Base64Data}</Challenge>\n  //     <HttpHeaders>\n  //       <HttpHeader>\n  //         <name>Content-Type</name>\n  //         <value>text/xml; charset=utf-8</value>\n  //       </HttpHeader>\n  //       <HttpHeader>\n  //         <name>SOAPAction</name>\n  //         <value>http://schemas.microsoft.com/DRM/etc/etc</value>\n  //       </HttpHeader>\n  //     </HttpHeaders>\n  //   </LicenseAcquisition>\n  // </PlayReadyKeyMessage>\n\n  var xml = shaka.util.StringUtils.fromUTF16(\n      request.body, true /* littleEndian */);\n  var dom = new DOMParser().parseFromString(xml, 'application/xml');\n\n  // Set request headers.\n  var headers = dom.getElementsByTagName('HttpHeader');\n  for (var i = 0; i < headers.length; ++i) {\n    var name = headers[i].querySelector('name');\n    var value = headers[i].querySelector('value');\n    goog.asserts.assert(name && value, 'Malformed PlayReady headers!');\n    request.headers[name.textContent] = value.textContent;\n  }\n\n  // Unpack the base64-encoded challenge.\n  var challenge = dom.querySelector('Challenge');\n  goog.asserts.assert(challenge, 'Malformed PlayReady challenge!');\n  goog.asserts.assert(challenge.getAttribute('encoding') == 'base64encoded',\n                      'Unexpected PlayReady challenge encoding!');\n  request.body =\n      shaka.util.Uint8ArrayUtils.fromBase64(challenge.textContent).buffer;\n};\n\n\n/**\n * @param {!Event} event\n * @private\n * @suppress {invalidCasts} to swap keyId and status\n */\nshaka.media.DrmEngine.prototype.onKeyStatusesChange_ = function(event) {\n  var session = /** @type {!MediaKeySession} */(event.target);\n\n  // Locate the session in the active sessions list.\n  var i;\n  for (i = 0; i < this.activeSessions_.length; ++i) {\n    if (this.activeSessions_[i].session == session) {\n      break;\n    }\n  }\n  goog.asserts.assert(i < this.activeSessions_.length,\n                      'Key status change for inactive session!');\n  if (i == this.activeSessions_.length) return;\n\n  var keyStatusMap = session.keyStatuses;\n  var hasExpiredKeys = false;\n\n  keyStatusMap.forEach(function(status, keyId) {\n    // The spec has changed a few times on the exact order of arguments here.\n    // As of 2016-06-30, Edge has the order reversed compared to the current\n    // EME spec.  Given the back and forth in the spec, it may not be the only\n    // one.  Try to detect this and compensate:\n    if (typeof keyId == 'string') {\n      var tmp = keyId;\n      keyId = /** @type {ArrayBuffer} */(status);\n      status = /** @type {string} */(tmp);\n    }\n\n    // Microsoft's implementation in Edge seems to present key IDs as\n    // little-endian UUIDs, rather than big-endian or just plain array of bytes.\n    // standard: 6e 5a 1d 26 - 27 57 - 47 d7 - 80 46 ea a5 d1 d3 4b 5a\n    // on Edge:  26 1d 5a 6e - 57 27 - d7 47 - 80 46 ea a5 d1 d3 4b 5a\n    // Bug filed: https://goo.gl/gnRSkJ\n\n    // NOTE that we skip this if byteLength != 16.  This is used for the IE11\n    // and Edge 12 EME polyfill, which uses single-byte dummy key IDs.\n    if (this.currentDrmInfo_.keySystem == 'com.microsoft.playready' &&\n        keyId.byteLength == 16) {\n      // Read out some fields in little-endian:\n      var dataView = new DataView(keyId);\n      var part0 = dataView.getUint32(0, true /* LE */);\n      var part1 = dataView.getUint16(4, true /* LE */);\n      var part2 = dataView.getUint16(6, true /* LE */);\n      // Write it back in big-endian:\n      dataView.setUint32(0, part0, false /* BE */);\n      dataView.setUint16(4, part1, false /* BE */);\n      dataView.setUint16(6, part2, false /* BE */);\n    }\n\n    // Microsoft's implementation in IE11 and Edge seems to never set key\n    // status to 'usable'.  It is stuck forever at 'status-pending'.  In spite\n    // of this, the keys do seem to be usable and content plays correctly.\n    // Bug filed: https://goo.gl/fcXEy1\n    if (this.currentDrmInfo_.keySystem == 'com.microsoft.playready' &&\n        status == 'status-pending') {\n      status = 'usable';\n    }\n\n    if (status != 'status-pending') {\n      this.activeSessions_[i].loaded = true;\n      if (this.activeSessions_.every(function(s) { return s.loaded; }))\n        this.allSessionsLoaded_.resolve();\n    }\n\n    if (status == 'expired') {\n      hasExpiredKeys = true;\n    }\n\n    var keyIdHex = shaka.util.Uint8ArrayUtils.toHex(new Uint8Array(keyId));\n\n    this.keyStatusByKeyId_[keyIdHex] = status;\n  }.bind(this));\n\n  // If the session has expired, close it.\n  // Some CDMs do not have sub-second time resolution, so the key status may\n  // fire with hundreds of milliseconds left until the stated expiration time.\n  var msUntilExpiration = session.expiration - Date.now();\n  if (msUntilExpiration < 0 || (hasExpiredKeys && msUntilExpiration < 1000)) {\n    // If this is part of a remove(), we don't want to close the session until\n    // the update is complete.  Otherwise, we will orphan the session.\n    if (!this.activeSessions_[i].updatePromise) {\n      shaka.log.debug('Session has expired', session);\n      this.activeSessions_.splice(i, 1);\n      session.close();\n    }\n  }\n\n  // Batch up key status changes before checking them or notifying Player.\n  // This handles cases where the statuses of multiple sessions are set\n  // simultaneously by the browser before dispatching key status changes for\n  // each of them.  By batching these up, we only send one status change event\n  // and at most one EXPIRED error on expiration.\n  this.keyStatusTimer_.schedule(0.1);\n};\n\n\n/**\n * @private\n */\nshaka.media.DrmEngine.prototype.processKeyStatusChanges_ = function() {\n  // If all keys are expired, fire an error.\n  var allExpired = shaka.util.MapUtils.every(\n      this.keyStatusByKeyId_, function(keyId, status) {\n        return status == 'expired';\n      });\n  if (allExpired) {\n    this.onError_(new shaka.util.Error(\n        shaka.util.Error.Category.DRM,\n        shaka.util.Error.Code.EXPIRED));\n  }\n\n  this.onKeyStatus_(this.keyStatusByKeyId_);\n};\n\n\n/**\n * Returns true if the browser has recent EME APIs.\n *\n * @return {boolean}\n */\nshaka.media.DrmEngine.isBrowserSupported = function() {\n  var basic =\n      !!window.MediaKeys &&\n      !!window.navigator &&\n      !!window.navigator.requestMediaKeySystemAccess &&\n      !!window.MediaKeySystemAccess &&\n      !!window.MediaKeySystemAccess.prototype.getConfiguration;\n\n  return basic;\n};\n\n\n/**\n * Returns a Promise to a map of EME support for well-known key systems.\n *\n * @return {!Promise.<!Object.<string, ?shakaExtern.DrmSupportType>>}\n */\nshaka.media.DrmEngine.probeSupport = function() {\n  goog.asserts.assert(shaka.media.DrmEngine.isBrowserSupported(),\n                      'Must have basic EME support');\n\n  var tests = [];\n  var testKeySystems = [\n    'org.w3.clearkey',\n    'com.widevine.alpha',\n    'com.microsoft.playready',\n    'com.apple.fps.2_0',\n    'com.apple.fps.1_0',\n    'com.apple.fps',\n    'com.adobe.primetime'\n  ];\n\n  var basicVideoCapabilities = [\n    { contentType: 'video/mp4; codecs=\"avc1.42E01E\"' },\n    { contentType: 'video/webm; codecs=\"vp8\"' }\n  ];\n\n  var basicConfig = {\n    videoCapabilities: basicVideoCapabilities\n  };\n  var offlineConfig = {\n    videoCapabilities: basicVideoCapabilities,\n    persistentState: 'required',\n    sessionTypes: ['persistent-license']\n  };\n\n  // Try the offline config first, then fall back to the basic config.\n  var configs = [offlineConfig, basicConfig];\n\n  var support = {};\n  testKeySystems.forEach(function(keySystem) {\n    var p = navigator.requestMediaKeySystemAccess(keySystem, configs)\n        .then(function(access) {\n          // Edge doesn't return supported session types, but current versions\n          // do not support persistent-license.  If sessionTypes is missing,\n          // assume no support for persistent-license.\n          // TODO: polyfill Edge to return known supported session types.\n          // Edge bug: https://goo.gl/z0URJ0\n          // Firefox does return supported session types, but will still let you\n          // create a session even if the type is unsupported.\n          // Firefox bug: https://goo.gl/lB4H3i\n          var sessionTypes = access.getConfiguration().sessionTypes;\n          var persistentState = sessionTypes ?\n              sessionTypes.indexOf('persistent-license') >= 0 : false;\n          support[keySystem] = {persistentState: persistentState};\n          return access.createMediaKeys();\n        }).catch(function() {\n          // Either the request failed or createMediaKeys failed.\n          // Either way, write null to the support object.\n          support[keySystem] = null;\n        });\n    tests.push(p);\n  });\n\n  return Promise.all(tests).then(function() {\n    return support;\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/media/manifest_parser.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.ManifestParser');\n\ngoog.require('goog.Uri');\ngoog.require('shaka.log');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.Error');\n\n\n/**\n * @namespace shaka.media.ManifestParser\n * @summary An interface to register manifest parsers.\n * @exportDoc\n */\n\n\n/**\n * Contains the parser factory functions indexed by MIME type.\n *\n * @type {!Object.<string, shakaExtern.ManifestParser.Factory>}\n */\nshaka.media.ManifestParser.parsersByMime = {};\n\n\n/**\n * Contains the parser factory functions indexed by file extension.\n *\n * @type {!Object.<string, shakaExtern.ManifestParser.Factory>}\n */\nshaka.media.ManifestParser.parsersByExtension = {};\n\n\n/**\n * Registers a manifest parser by file extension.\n *\n * @param {string} extension The file extension of the manifest.\n * @param {shakaExtern.ManifestParser.Factory} parserFactory The factory\n *   used to create parser instances.\n * @export\n */\nshaka.media.ManifestParser.registerParserByExtension = function(\n    extension, parserFactory) {\n  shaka.media.ManifestParser.parsersByExtension[extension] = parserFactory;\n};\n\n\n/**\n * Registers a manifest parser by MIME type.\n *\n * @param {string} mimeType The MIME type of the manifest.\n * @param {shakaExtern.ManifestParser.Factory} parserFactory The factory\n *   used to create parser instances.\n * @export\n */\nshaka.media.ManifestParser.registerParserByMime = function(\n    mimeType, parserFactory) {\n  shaka.media.ManifestParser.parsersByMime[mimeType] = parserFactory;\n};\n\n\n/**\n * Returns a map of manifest support for well-known types.\n *\n * @return {!Object.<string, boolean>}\n */\nshaka.media.ManifestParser.probeSupport = function() {\n  // Make sure all registered parsers are shown.\n  var support = {};\n  for (var type in shaka.media.ManifestParser.parsersByMime) {\n    support[type] = true;\n  }\n  for (var type in shaka.media.ManifestParser.parsersByExtension) {\n    support[type] = true;\n  }\n\n  // Make sure all well-known types are tested as well, just to show an explicit\n  // false for things people might be expecting.\n  var testMimeTypes = [\n    // DASH\n    'application/dash+xml',\n    // HLS\n    'application/x-mpegurl',\n    'application/vnd.apple.mpegurl',\n    // SmoothStreaming\n    'application/vnd.ms-sstr+xml'\n  ];\n  var testExtensions = [\n    // DASH\n    'mpd',\n    // HLS\n    'm3u8',\n    // SmoothStreaming\n    'ism'\n  ];\n\n  testMimeTypes.forEach(function(type) {\n    support[type] = !!shaka.media.ManifestParser.parsersByMime[type];\n  });\n  testExtensions.forEach(function(type) {\n    support[type] = !!shaka.media.ManifestParser.parsersByExtension[type];\n  });\n\n  return support;\n};\n\n\n/**\n * Finds a manifest parser factory to parse the given manifest.\n *\n * @param {string} manifestUri\n * @param {!shaka.net.NetworkingEngine} netEngine\n * @param {shakaExtern.RetryParameters} retryParams\n * @param {shakaExtern.ManifestParser.Factory=} opt_manifestParserFactory\n * @return {!Promise.<shakaExtern.ManifestParser.Factory>}\n */\nshaka.media.ManifestParser.getFactory = function(\n    manifestUri, netEngine, retryParams, opt_manifestParserFactory) {\n  var factory = opt_manifestParserFactory;\n  var extension;\n\n  if (!factory) {\n    // Try to choose a manifest parser by file extension.\n    var uriObj = new goog.Uri(manifestUri);\n    var uriPieces = uriObj.getPath().split('/');\n    var uriFilename = uriPieces.pop();\n    var filenamePieces = uriFilename.split('.');\n    // Only one piece means there is no extension.\n    if (filenamePieces.length > 1) {\n      extension = filenamePieces.pop().toLowerCase();\n      factory = shaka.media.ManifestParser.parsersByExtension[extension];\n    }\n  }\n\n  if (factory)\n    return Promise.resolve(factory);\n\n  // Try to choose a manifest parser by MIME type.\n  var headRequest =\n      shaka.net.NetworkingEngine.makeRequest([manifestUri], retryParams);\n  headRequest.method = 'HEAD';\n  var type = shaka.net.NetworkingEngine.RequestType.MANIFEST;\n\n  return netEngine.request(type, headRequest).then(\n      function(response) {\n        var mimeType = response.headers['content-type'];\n        // https://goo.gl/yzKDRx says this header should always be available,\n        // but just to be safe:\n        if (mimeType) {\n          mimeType = mimeType.toLowerCase();\n        }\n        factory = shaka.media.ManifestParser.parsersByMime[mimeType];\n        if (!factory) {\n          shaka.log.error(\n              'Unable to guess manifest type by file extension ' +\n              'or by MIME type.', extension, mimeType);\n          return Promise.reject(new shaka.util.Error(\n              shaka.util.Error.Category.MANIFEST,\n              shaka.util.Error.Code.UNABLE_TO_GUESS_MANIFEST_TYPE,\n              manifestUri));\n        }\n        return factory;\n      }, function(error) {\n        shaka.log.error('HEAD request to guess manifest type failed!', error);\n        return Promise.reject(error);\n      });\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/media/media_source_engine.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.MediaSourceEngine');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.TextEngine');\ngoog.require('shaka.media.TimeRangesUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.PublicPromise');\n\n\n\n/**\n * MediaSourceEngine wraps all operations on MediaSource and SourceBuffers.\n * All asynchronous operations return a Promise, and all operations are\n * internally synchronized and serialized as needed.  Operations that can\n * be done in parallel will be done in parallel.\n *\n * @param {HTMLMediaElement} video The video element, used to read error codes\n *   when MediaSource operations fail.\n * @param {MediaSource} mediaSource The MediaSource, which must be in the\n *   'open' state.\n * @param {TextTrack} textTrack The TextTrack to use for subtitles/captions.\n *\n * @struct\n * @constructor\n * @implements {shaka.util.IDestroyable}\n */\nshaka.media.MediaSourceEngine = function(video, mediaSource, textTrack) {\n  goog.asserts.assert(mediaSource.readyState == 'open',\n                      'The MediaSource should be in the \\'open\\' state.');\n\n  /** @private {HTMLMediaElement} */\n  this.video_ = video;\n\n  /** @private {MediaSource} */\n  this.mediaSource_ = mediaSource;\n\n  /** @private {TextTrack} */\n  this.textTrack_ = textTrack;\n\n  /** @private {!Object.<string, SourceBuffer>} */\n  this.sourceBuffers_ = {};\n\n  /** @private {shaka.media.TextEngine} */\n  this.textEngine_ = null;\n\n  /**\n   * @private {!Object.<string,\n   *                    !Array.<shaka.media.MediaSourceEngine.Operation>>}\n   */\n  this.queues_ = {};\n\n  /** @private {shaka.util.EventManager} */\n  this.eventManager_ = new shaka.util.EventManager();\n\n  /** @private {boolean} */\n  this.destroyed_ = false;\n};\n\n\n/**\n * @typedef {{\n *   start: function(),\n *   p: !shaka.util.PublicPromise\n * }}\n *\n * @summary An operation in queue.\n * @property {function()} start\n *   The function which starts the operation.\n * @property {!shaka.util.PublicPromise} p\n *   The PublicPromise which is associated with this operation.\n */\nshaka.media.MediaSourceEngine.Operation;\n\n\n/**\n * Checks if a certain type is supported.\n *\n * @param {string} mimeType\n * @return {boolean}\n */\nshaka.media.MediaSourceEngine.isTypeSupported = function(mimeType) {\n  return shaka.media.TextEngine.isTypeSupported(mimeType) ||\n         MediaSource.isTypeSupported(mimeType);\n};\n\n\n/**\n * Returns true if the browser has the basic APIs we need.\n *\n * @return {boolean}\n */\nshaka.media.MediaSourceEngine.isBrowserSupported = function() {\n  return !!window.MediaSource;\n};\n\n\n/**\n * Returns a map of MediaSource support for well-known types.\n *\n * @return {!Object.<string, boolean>}\n */\nshaka.media.MediaSourceEngine.probeSupport = function() {\n  goog.asserts.assert(shaka.media.MediaSourceEngine.isBrowserSupported(),\n                      'Requires basic support');\n  var support = {};\n  var testMimeTypes = [\n    // MP4 types\n    'video/mp4; codecs=\"avc1.42E01E\"',\n    'video/mp4; codecs=\"avc3.42E01E\"',\n    'video/mp4; codecs=\"hvc1.1.6.L93.90\"',\n    'audio/mp4; codecs=\"mp4a.40.2\"',\n    'audio/mp4; codecs=\"ac-3\"',\n    'audio/mp4; codecs=\"ec-3\"',\n    // WebM types\n    'video/webm; codecs=\"vp8\"',\n    'video/webm; codecs=\"vp9\"',\n    'video/webm; codecs=\"av1\"',\n    'audio/webm; codecs=\"vorbis\"',\n    'audio/webm; codecs=\"opus\"',\n    // MPEG2 TS types (video/ is also used for audio: http://goo.gl/tYHXiS)\n    'video/mp2t; codecs=\"avc1.42E01E\"',\n    'video/mp2t; codecs=\"avc3.42E01E\"',\n    'video/mp2t; codecs=\"hvc1.1.6.L93.90\"',\n    'video/mp2t; codecs=\"mp4a.40.2\"',\n    'video/mp2t; codecs=\"ac-3\"',\n    'video/mp2t; codecs=\"ec-3\"',\n    'video/mp2t; codecs=\"mp4a.40.2\"',\n    // WebVTT types\n    'text/vtt',\n    'application/mp4; codecs=\"wvtt\"',\n    // TTML types\n    'application/ttml+xml',\n    'application/mp4; codecs=\"stpp\"'\n  ];\n\n  testMimeTypes.forEach(function(type) {\n    support[type] = shaka.media.MediaSourceEngine.isTypeSupported(type);\n    var basicType = type.split(';')[0];\n    support[basicType] = support[basicType] || support[type];\n  });\n\n  return support;\n};\n\n\n/**\n * @override\n */\nshaka.media.MediaSourceEngine.prototype.destroy = function() {\n  var Functional = shaka.util.Functional;\n  this.destroyed_ = true;\n\n  var cleanup = [];\n\n  for (var contentType in this.queues_) {\n    // Make a local copy of the queue and the first item.\n    var q = this.queues_[contentType];\n    var inProgress = q[0];\n\n    // Drop everything else out of the queue.\n    this.queues_[contentType] = q.slice(0, 1);\n\n    // We will wait for this item to complete/fail.\n    if (inProgress) {\n      cleanup.push(inProgress.p.catch(Functional.noop));\n    }\n\n    // The rest will be rejected silently if possible.\n    for (var i = 1; i < q.length; ++i) {\n      q[i].p.catch(Functional.noop);\n      q[i].p.reject();\n    }\n  }\n\n  if (this.textEngine_) {\n    cleanup.push(this.textEngine_.destroy());\n  }\n\n  return Promise.all(cleanup).then(function() {\n    this.eventManager_.destroy();\n    this.eventManager_ = null;\n    this.video_ = null;\n    this.mediaSource_ = null;\n    this.textTrack_ = null;\n    this.textEngine_ = null;\n    this.sourceBuffers_ = {};\n    if (!COMPILED) {\n      for (var contentType in this.queues_) {\n        goog.asserts.assert(\n            this.queues_[contentType].length == 0,\n            contentType + ' queue should be empty after destroy!');\n      }\n    }\n    this.queues_ = {};\n  }.bind(this));\n};\n\n\n/**\n * @param {!Object.<string, string>} typeConfig A map of content types to full\n *   MIME types.  For example: { 'audio': 'audio/webm; codecs=\"vorbis\"',\n *   'video': 'video/webm; codecs=\"vp9\"', 'text': 'text/vtt' }.\n *   All types given must be supported.\n * @param {boolean} useRelativeCueTimestamps\n *\n * @throws InvalidAccessError if blank MIME types are given\n * @throws NotSupportedError if unsupported MIME types are given\n * @throws QuotaExceededError if the browser can't support that many buffers\n */\nshaka.media.MediaSourceEngine.prototype.init =\n    function(typeConfig, useRelativeCueTimestamps) {\n\n  for (var contentType in typeConfig) {\n    var mimeType = typeConfig[contentType];\n    goog.asserts.assert(\n        shaka.media.MediaSourceEngine.isTypeSupported(mimeType),\n        'Type negotiation should happen before MediaSourceEngine.init!');\n\n    if (contentType == 'text') {\n      this.textEngine_ =\n          new shaka.media.TextEngine(this.textTrack_,\n                                     mimeType,\n                                     useRelativeCueTimestamps);\n    } else {\n      var sourceBuffer = this.mediaSource_.addSourceBuffer(mimeType);\n      this.eventManager_.listen(\n          sourceBuffer, 'error', this.onError_.bind(this, contentType));\n      this.eventManager_.listen(\n          sourceBuffer, 'updateend', this.onUpdateEnd_.bind(this, contentType));\n      this.sourceBuffers_[contentType] = sourceBuffer;\n      this.queues_[contentType] = [];\n    }\n  }\n};\n\n\n/**\n * Gets the first timestamp in buffer for the given content type.\n *\n * @param {string} contentType\n * @return {?number} The timestamp in seconds, or null if nothing is buffered.\n */\nshaka.media.MediaSourceEngine.prototype.bufferStart = function(contentType) {\n  if (contentType == 'text') {\n    return this.textEngine_.bufferStart();\n  }\n  return shaka.media.TimeRangesUtils.bufferStart(\n      this.getBuffered_(contentType));\n};\n\n\n/**\n * Gets the last timestamp in buffer for the given content type.\n *\n * @param {string} contentType\n * @return {?number} The timestamp in seconds, or null if nothing is buffered.\n */\nshaka.media.MediaSourceEngine.prototype.bufferEnd = function(contentType) {\n  if (contentType == 'text') {\n    return this.textEngine_.bufferEnd();\n  }\n  return shaka.media.TimeRangesUtils.bufferEnd(this.getBuffered_(contentType));\n};\n\n\n/**\n * Computes how far ahead of the given timestamp is buffered for the given\n * content type.\n *\n * @param {string} contentType\n * @param {number} time\n * @param {number=} opt_tolerance An optional tolerance for range start times.\n *   Counts a range starting anywhere from time to time + opt_tolerance.\n * @return {number} The amount of time buffered ahead in seconds.\n */\nshaka.media.MediaSourceEngine.prototype.bufferedAheadOf =\n    function(contentType, time, opt_tolerance) {\n  var bufferedAhead;\n  if (contentType == 'text') {\n    bufferedAhead = this.textEngine_.bufferedAheadOf(time);\n    if (!bufferedAhead && opt_tolerance) {\n      bufferedAhead = this.textEngine_.bufferedAheadOf(\n          time + opt_tolerance);\n      if (bufferedAhead) bufferedAhead += opt_tolerance;\n    }\n  } else {\n    var buffered = this.getBuffered_(contentType);\n    bufferedAhead = shaka.media.TimeRangesUtils.bufferedAheadOfThreshold(\n        buffered, time, opt_tolerance || 0);\n  }\n  return bufferedAhead;\n};\n\n\n/**\n * @param {string} contentType\n * @return {TimeRanges} The buffered ranges for the given content type, or\n *   null if the buffered ranges could not be obtained.\n * @private\n */\nshaka.media.MediaSourceEngine.prototype.getBuffered_ = function(contentType) {\n  try {\n    return this.sourceBuffers_[contentType].buffered;\n  } catch (exception) {\n    // Note: previous MediaSource errors may cause access to |buffered| to\n    // throw.\n    shaka.log.error('failed to get buffered range for ' + contentType,\n                    exception);\n    return null;\n  }\n};\n\n\n/**\n * Enqueue an operation to append data to the SourceBuffer.\n * Start and end times are needed for TextEngine, but not for MediaSource.\n * Start and end times may be null for initialization segments, if present they\n * are relative to the presentation timeline.\n *\n * @param {string} contentType\n * @param {!ArrayBuffer} data\n * @param {?number} startTime\n * @param {?number} endTime\n * @return {!Promise}\n */\nshaka.media.MediaSourceEngine.prototype.appendBuffer =\n    function(contentType, data, startTime, endTime) {\n  if (contentType == 'text') {\n    return this.textEngine_.appendBuffer(data, startTime, endTime);\n  }\n  return this.enqueueOperation_(\n      contentType,\n      this.append_.bind(this, contentType, data));\n};\n\n\n/**\n * Enqueue an operation to remove data from the SourceBuffer.\n *\n * @param {string} contentType\n * @param {number} startTime\n * @param {number} endTime\n * @return {!Promise}\n */\nshaka.media.MediaSourceEngine.prototype.remove =\n    function(contentType, startTime, endTime) {\n  // On IE11, this operation would be permitted, but would have no effect!\n  // See https://github.com/google/shaka-player/issues/251\n  goog.asserts.assert(endTime < Number.MAX_VALUE,\n      'remove() with MAX_VALUE or Infinity is not IE-compatible!');\n  if (contentType == 'text') {\n    return this.textEngine_.remove(startTime, endTime);\n  }\n  return this.enqueueOperation_(\n      contentType,\n      this.remove_.bind(this, contentType, startTime, endTime));\n};\n\n\n/**\n * Enqueue an operation to clear the SourceBuffer.\n *\n * @param {string} contentType\n * @return {!Promise}\n */\nshaka.media.MediaSourceEngine.prototype.clear = function(contentType) {\n  if (contentType == 'text') {\n    return this.textEngine_.remove(0, Infinity);\n  }\n  // Note that not all platforms allow clearing to Infinity.\n  return this.enqueueOperation_(\n      contentType,\n      this.remove_.bind(this, contentType, 0, this.mediaSource_.duration));\n};\n\n\n/**\n * Enqueue an operation to flush the SourceBuffer.\n * This is a workaround for what we believe is a Chromecast bug.\n *\n * @param {string} contentType\n * @return {!Promise}\n */\nshaka.media.MediaSourceEngine.prototype.flush = function(contentType) {\n  // Flush the pipeline.  Necessary on Chromecast, even though we have removed\n  // everything.\n  if (contentType == 'text') {\n    // Nothing to flush for text.\n    return Promise.resolve();\n  }\n  return this.enqueueOperation_(\n      contentType,\n      this.flush_.bind(this, contentType));\n};\n\n\n/**\n * Sets the timestamp offset for the given content type.\n *\n * @param {string} contentType\n * @param {number} timestampOffset The timestamp offset. Segments which start\n *   at time t will be inserted at time t + timestampOffset instead. This\n *   value does not affect segments which have already been inserted.\n * @return {!Promise}\n */\nshaka.media.MediaSourceEngine.prototype.setTimestampOffset = function(\n    contentType, timestampOffset) {\n  if (contentType == 'text') {\n    this.textEngine_.setTimestampOffset(timestampOffset);\n    return Promise.resolve();\n  }\n  return this.enqueueOperation_(\n      contentType,\n      this.setTimestampOffset_.bind(this, contentType, timestampOffset));\n};\n\n\n/**\n * Sets the append window end for the given content type.\n *\n * @param {string} contentType\n * @param {number} appendWindowEnd The timestamp to set the append window end\n *   to. Media beyond this value will be truncated.\n * @return {!Promise}\n */\nshaka.media.MediaSourceEngine.prototype.setAppendWindowEnd = function(\n    contentType, appendWindowEnd) {\n  if (contentType == 'text') {\n    this.textEngine_.setAppendWindowEnd(appendWindowEnd);\n    return Promise.resolve();\n  }\n  return Promise.all([\n    // Queue an abort() to help MSE splice together overlapping segments.\n    // We set appendWindowEnd when we change periods in DASH content, and the\n    // period transition may result in overlap.\n    this.enqueueOperation_(\n        contentType,\n        this.abort_.bind(this, contentType)),\n    this.enqueueOperation_(\n        contentType,\n        this.setAppendWindowEnd_.bind(this, contentType, appendWindowEnd))\n  ]);\n};\n\n\n/**\n * @param {string=} opt_reason Valid reasons are 'network' and 'decode'.\n * @return {!Promise}\n * @see http://w3c.github.io/media-source/#idl-def-EndOfStreamError\n */\nshaka.media.MediaSourceEngine.prototype.endOfStream = function(opt_reason) {\n  return this.enqueueBlockingOperation_(function() {\n    // Chrome won't let me pass undefined, but it will let me omit the\n    // argument.  Firefox does not have this problem.\n    // TODO: File a bug about this.\n    if (opt_reason) {\n      this.mediaSource_.endOfStream(opt_reason);\n    } else {\n      this.mediaSource_.endOfStream();\n    }\n  }.bind(this));\n};\n\n\n/**\n * We only support increasing duration at this time.  Decreasing duration\n * causes the MSE removal algorithm to run, which results in an 'updateend'\n * event.  Supporting this scenario would be complicated, and is not currently\n * needed.\n *\n * @param {number} duration\n * @return {!Promise}\n */\nshaka.media.MediaSourceEngine.prototype.setDuration = function(duration) {\n  goog.asserts.assert(\n      isNaN(this.mediaSource_.duration) ||\n          this.mediaSource_.duration <= duration,\n      'duration cannot decrease: ' + this.mediaSource_.duration + ' -> ' +\n          duration);\n  return this.enqueueBlockingOperation_(function() {\n    this.mediaSource_.duration = duration;\n  }.bind(this));\n};\n\n\n/**\n * Get the current MediaSource duration.\n *\n * @return {number}\n */\nshaka.media.MediaSourceEngine.prototype.getDuration = function() {\n  return this.mediaSource_.duration;\n};\n\n\n/**\n * Append data to the SourceBuffer.\n * @param {string} contentType\n * @param {!ArrayBuffer} data\n * @throws QuotaExceededError if the browser's buffer is full\n * @private\n */\nshaka.media.MediaSourceEngine.prototype.append_ =\n    function(contentType, data) {\n  // This will trigger an 'updateend' event.\n  this.sourceBuffers_[contentType].appendBuffer(data);\n};\n\n\n/**\n * Remove data from the SourceBuffer.\n * @param {string} contentType\n * @param {number} startTime\n * @param {number} endTime\n * @private\n */\nshaka.media.MediaSourceEngine.prototype.remove_ =\n    function(contentType, startTime, endTime) {\n  if (endTime <= startTime) {\n    // Ignore removal of inverted or empty ranges.\n    // Fake 'updateend' event to resolve the operation.\n    this.onUpdateEnd_(contentType);\n    return;\n  }\n\n  // This will trigger an 'updateend' event.\n  this.sourceBuffers_[contentType].remove(startTime, endTime);\n};\n\n\n/**\n * Call abort() on the SourceBuffer.\n * This resets MSE's last_decode_timestamp on all track buffers, which should\n * trigger the splicing logic for overlapping segments.\n * @param {string} contentType\n * @private\n */\nshaka.media.MediaSourceEngine.prototype.abort_ = function(contentType) {\n  // Save the append window end, which is reset on abort().\n  var appendWindowEnd = this.sourceBuffers_[contentType].appendWindowEnd;\n\n  // This will not trigger an 'updateend' event, since nothing is happening.\n  // This is only to reset MSE internals, not to abort an actual operation.\n  this.sourceBuffers_[contentType].abort();\n\n  // Restore the append window end.\n  this.sourceBuffers_[contentType].appendWindowEnd = appendWindowEnd;\n\n  // Fake 'updateend' event to resolve the operation.\n  this.onUpdateEnd_(contentType);\n};\n\n\n/**\n * Nudge the playhead to force the media pipeline to be flushed.\n * This seems to be necessary on Chromecast to get new content to replace old\n * content.\n * @param {string} contentType\n * @private\n */\nshaka.media.MediaSourceEngine.prototype.flush_ = function(contentType) {\n  // Never use flush_ if there's data.  It causes a hiccup in playback.\n  goog.asserts.assert(\n      this.video_.buffered.length == 0,\n      'MediaSourceEngine.flush_ should only be used after clearing all data!');\n\n  // Seeking forces the pipeline to be flushed.\n  this.video_.currentTime -= 0.001;\n\n  // Fake 'updateend' event to resolve the operation.\n  this.onUpdateEnd_(contentType);\n};\n\n\n/**\n * Set the SourceBuffer's timestamp offset.\n * @param {string} contentType\n * @param {number} timestampOffset\n * @private\n */\nshaka.media.MediaSourceEngine.prototype.setTimestampOffset_ =\n    function(contentType, timestampOffset) {\n  this.sourceBuffers_[contentType].timestampOffset = timestampOffset;\n\n  // Fake 'updateend' event to resolve the operation.\n  this.onUpdateEnd_(contentType);\n};\n\n\n/**\n * Set the SourceBuffer's append window end.\n * @param {string} contentType\n * @param {number} appendWindowEnd\n * @private\n */\nshaka.media.MediaSourceEngine.prototype.setAppendWindowEnd_ =\n    function(contentType, appendWindowEnd) {\n  var fudge = 1 / 25;  // one frame, assuming a low framerate\n  this.sourceBuffers_[contentType].appendWindowEnd = appendWindowEnd + fudge;\n\n  // Fake 'updateend' event to resolve the operation.\n  this.onUpdateEnd_(contentType);\n};\n\n\n/**\n * @param {string} contentType\n * @param {!Event} event\n * @private\n */\nshaka.media.MediaSourceEngine.prototype.onError_ =\n    function(contentType, event) {\n  var operation = this.queues_[contentType][0];\n  goog.asserts.assert(operation, 'Spurious error event!');\n  goog.asserts.assert(!this.sourceBuffers_[contentType].updating,\n                      'SourceBuffer should not be updating on error!');\n  var code = this.video_.error ? this.video_.error.code : 0;\n  operation.p.reject(new shaka.util.Error(\n      shaka.util.Error.Category.MEDIA,\n      shaka.util.Error.Code.MEDIA_SOURCE_OPERATION_FAILED,\n      code));\n  // Do not pop from queue.  An 'updateend' event will fire next, and to avoid\n  // synchronizing these two event handlers, we will allow that one to pop from\n  // the queue as normal.  Note that because the operation has already been\n  // rejected, the call to resolve() in the 'updateend' handler will have no\n  // effect.\n};\n\n\n/**\n * @param {string} contentType\n * @private\n */\nshaka.media.MediaSourceEngine.prototype.onUpdateEnd_ = function(contentType) {\n  var operation = this.queues_[contentType][0];\n  goog.asserts.assert(operation, 'Spurious updateend event!');\n  if (!operation) return;\n  goog.asserts.assert(!this.sourceBuffers_[contentType].updating,\n                      'SourceBuffer should not be updating on updateend!');\n  operation.p.resolve();\n  this.popFromQueue_(contentType);\n};\n\n\n/**\n * Enqueue an operation and start it if appropriate.\n *\n * @param {string} contentType\n * @param {function()} start\n * @return {!Promise}\n * @private\n */\nshaka.media.MediaSourceEngine.prototype.enqueueOperation_ =\n    function(contentType, start) {\n  if (this.destroyed_) return Promise.reject();\n\n  var operation = {\n    start: start,\n    p: new shaka.util.PublicPromise()\n  };\n  this.queues_[contentType].push(operation);\n\n  if (this.queues_[contentType].length == 1) {\n    try {\n      operation.start();\n    } catch (exception) {\n      if (exception.name == 'QuotaExceededError') {\n        operation.p.reject(new shaka.util.Error(\n            shaka.util.Error.Category.MEDIA,\n            shaka.util.Error.Code.QUOTA_EXCEEDED_ERROR,\n            contentType));\n      } else {\n        operation.p.reject(new shaka.util.Error(\n            shaka.util.Error.Category.MEDIA,\n            shaka.util.Error.Code.MEDIA_SOURCE_OPERATION_THREW,\n            exception));\n      }\n      this.popFromQueue_(contentType);\n    }\n  }\n  return operation.p;\n};\n\n\n/**\n * Enqueue an operation which must block all other operations on all\n * SourceBuffers.\n *\n * @param {function()} run\n * @return {!Promise}\n * @private\n */\nshaka.media.MediaSourceEngine.prototype.enqueueBlockingOperation_ =\n    function(run) {\n  if (this.destroyed_) return Promise.reject();\n\n  var allWaiters = [];\n\n  // Enqueue a 'wait' operation onto each queue.\n  // This operation signals its readiness when it starts.\n  // When all wait operations are ready, the real operation takes place.\n  for (var contentType in this.sourceBuffers_) {\n    var ready = new shaka.util.PublicPromise();\n    var operation = {\n      start: function(ready) { ready.resolve(); }.bind(null, ready),\n      p: ready\n    };\n\n    this.queues_[contentType].push(operation);\n    allWaiters.push(ready);\n\n    if (this.queues_[contentType].length == 1) {\n      operation.start();\n    }\n  }\n\n  // Return a Promise to the real operation, which waits to begin until there\n  // are no other in-progress operations on any SourceBuffers.\n  return Promise.all(allWaiters).then(function() {\n    if (!COMPILED) {\n      // If we did it correctly, nothing is updating.\n      for (var contentType in this.sourceBuffers_) {\n        goog.asserts.assert(\n            this.sourceBuffers_[contentType].updating == false,\n            'SourceBuffers should not be updating after a blocking op!');\n      }\n    }\n\n    var ret;\n    // Run the real operation, which is synchronous.\n    try {\n      run();\n    } catch (exception) {\n      ret = Promise.reject(new shaka.util.Error(\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.MEDIA_SOURCE_OPERATION_THREW,\n          exception));\n    }\n\n    // Unblock the queues.\n    for (var contentType in this.sourceBuffers_) {\n      this.popFromQueue_(contentType);\n    }\n\n    return ret;\n  }.bind(this), function() {\n    // One of the waiters failed, which means we've been destroyed.\n    goog.asserts.assert(this.destroyed_, 'Should be destroyed by now');\n    // We haven't popped from the queue.  Canceled waiters have been removed by\n    // destroy.  What's left now should just be resolved waiters.  In uncompiled\n    // mode, we will maintain good hygiene and make sure the assert at the end\n    // of destroy passes.  In compiled mode, the queues are wiped in destroy.\n    if (!COMPILED) {\n      for (var contentType in this.sourceBuffers_) {\n        if (this.queues_[contentType].length) {\n          goog.asserts.assert(\n              this.queues_[contentType].length == 1,\n              'Should be at most one item in queue!');\n          goog.asserts.assert(\n              allWaiters.indexOf(this.queues_[contentType][0].p) != -1,\n              'The item in queue should be one of our waiters!');\n          this.queues_[contentType].shift();\n        }\n      }\n    }\n    return Promise.reject();\n  }.bind(this));\n};\n\n\n/**\n * Pop from the front of the queue and start a new operation.\n * @param {string} contentType\n * @private\n */\nshaka.media.MediaSourceEngine.prototype.popFromQueue_ = function(contentType) {\n  // Remove the in-progress operation, which is now complete.\n  this.queues_[contentType].shift();\n  // Retrieve the next operation, if any, from the queue and start it.\n  var next = this.queues_[contentType][0];\n  if (next) {\n    try {\n      next.start();\n    } catch (exception) {\n      next.p.reject(new shaka.util.Error(\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.MEDIA_SOURCE_OPERATION_THREW,\n          exception));\n      this.popFromQueue_(contentType);\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/media/mp4_segment_index_parser.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.Mp4SegmentIndexParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.DataViewReader');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Mp4Parser');\n\n\n/**\n * Parses SegmentReferences from an ISO BMFF SIDX structure.\n * @param {!ArrayBuffer} sidxData The MP4's container's SIDX.\n * @param {number} sidxOffset The SIDX's offset, in bytes, from the start of\n *   the MP4 container.\n * @param {!Array.<string>} uris The possible locations of the MP4 file that\n *   contains the segments.\n * @param {number} presentationTimeOffset\n * @return {!Array.<!shaka.media.SegmentReference>}\n * @throws {shaka.util.Error}\n */\nshaka.media.Mp4SegmentIndexParser = function(\n    sidxData, sidxOffset, uris, presentationTimeOffset) {\n  var references = [];\n\n  var reader = new shaka.util.DataViewReader(\n      new DataView(sidxData),\n      shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n\n  var boxSize = shaka.util.Mp4Parser.findBox(\n      shaka.media.Mp4SegmentIndexParser.BOX_TYPE, reader);\n\n  if (boxSize == shaka.util.Mp4Parser.BOX_NOT_FOUND) {\n    shaka.log.error('Invalid box type, expected \"sidx\".');\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.MP4_SIDX_WRONG_BOX_TYPE);\n  }\n\n  // Parse the FullBox structure.\n  var version = reader.readUint8();\n\n  // Skip flags (24 bits)\n  reader.skip(3);\n\n  // Parse the SIDX structure.\n  // Skip reference_ID (32 bits).\n  reader.skip(4);\n\n  var timescale = reader.readUint32();\n  goog.asserts.assert(timescale != 0, 'timescale cannot be 0');\n  if (timescale == 0) {\n    shaka.log.error('Invalid timescale.');\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.MP4_SIDX_INVALID_TIMESCALE);\n  }\n\n  var earliestPresentationTime;\n  var firstOffset;\n\n  if (version == 0) {\n    earliestPresentationTime = reader.readUint32();\n    firstOffset = reader.readUint32();\n  } else {\n    earliestPresentationTime = reader.readUint64();\n    firstOffset = reader.readUint64();\n  }\n\n  // Skip reserved (16 bits).\n  reader.skip(2);\n\n  // Add references.\n  var referenceCount = reader.readUint16();\n\n  // Substract the presentationTimeOffset\n  var unscaledStartTime = earliestPresentationTime - presentationTimeOffset;\n  var startByte = sidxOffset + boxSize + firstOffset;\n\n  for (var i = 0; i < referenceCount; i++) {\n    // |chunk| is 1 bit for |referenceType|, and 31 bits for |referenceSize|.\n    var chunk = reader.readUint32();\n    var referenceType = (chunk & 0x80000000) >>> 31;\n    var referenceSize = chunk & 0x7FFFFFFF;\n\n    var subsegmentDuration = reader.readUint32();\n\n    // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits\n    // for |sapDelta|.\n    reader.skip(4);\n\n    // If |referenceType| is 1 then the reference is to another SIDX.\n    // We do not support this.\n    if (referenceType == 1) {\n      shaka.log.error('Heirarchical SIDXs are not supported.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.MP4_SIDX_TYPE_NOT_SUPPORTED);\n    }\n\n    references.push(\n        new shaka.media.SegmentReference(\n            references.length,\n            unscaledStartTime / timescale,\n            (unscaledStartTime + subsegmentDuration) / timescale,\n            function() { return uris; },\n            startByte,\n            startByte + referenceSize - 1));\n\n    unscaledStartTime += subsegmentDuration;\n    startByte += referenceSize;\n  }\n\n  return references;\n};\n\n\n/**\n * Indicates the SIDX box structure. It is equal to the string 'sidx' as a\n * 32-bit unsigned integer.\n * @const {number}\n */\nshaka.media.Mp4SegmentIndexParser.BOX_TYPE = 0x73696478;\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/media/mp4_ttml_parser.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.Mp4TtmlParser');\n\ngoog.require('shaka.media.TextEngine');\ngoog.require('shaka.media.TtmlTextParser');\ngoog.require('shaka.util.DataViewReader');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Mp4Parser');\n\n\n/**\n * @namespace\n * @summary Extracts a TTML segment from an MP4 file and invokes the TTML parser\n *   to parse it.\n * @param {ArrayBuffer} data\n * @param {number} offset\n * @param {?number} segmentStartTime\n * @param {?number} segmentEndTime\n * @param {boolean} useRelativeCueTimestamps Only used by the VTT parser\n * @return {!Array.<!TextTrackCue>}\n * @export\n */\nshaka.media.Mp4TtmlParser =\n    function(data, offset, segmentStartTime,\n             segmentEndTime, useRelativeCueTimestamps) {\n  var reader = new shaka.util.DataViewReader(\n      new DataView(data),\n      shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n\n  var boxSize = shaka.util.Mp4Parser.findBox(\n      shaka.util.Mp4Parser.BOX_TYPE_MDAT, reader);\n  if (boxSize != shaka.util.Mp4Parser.BOX_NOT_FOUND) {\n    // mdat box found, use TtmlTextParser to parse the content\n    return shaka.media.TtmlTextParser(\n        reader.readBytes(boxSize - 8).buffer, offset,\n        segmentStartTime, segmentEndTime, false);\n  }\n  var stppBoxSize = shaka.util.Mp4Parser.findSampleDescriptionBox(\n      data, shaka.media.Mp4TtmlParser.BOX_TYPE_STPP);\n  if (stppBoxSize != shaka.util.Mp4Parser.BOX_NOT_FOUND) {\n    // a valid ttml init segment, no actual subtitles yet\n    return [];\n  } else {\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.INVALID_MP4_TTML);\n  }\n};\n\n\n/** @const {number} */\nshaka.media.Mp4TtmlParser.BOX_TYPE_STPP = 0x73747070;\n\n\nshaka.media.TextEngine.registerParser(\n    'application/mp4; codecs=\"stpp\"', shaka.media.Mp4TtmlParser);\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/media/mp4_vtt_parser.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.Mp4VttParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.TextEngine');\ngoog.require('shaka.media.VttTextParser');\ngoog.require('shaka.util.DataViewReader');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Mp4Parser');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.TextParser');\n\n\n/**\n * @namespace\n * @summary Extracts a VTT segment from an MP4 file and maps it to cue objects.\n * @param {ArrayBuffer} data\n * @param {number} offset\n * @param {?number} segmentStartTime\n * @param {?number} segmentEndTime\n * @param {boolean} useRelativeCueTimestamps Only used by the VTT parser\n * @return {!Array.<!TextTrackCue>}\n * @export\n */\nshaka.media.Mp4VttParser =\n    function(data, offset, segmentStartTime,\n             segmentEndTime, useRelativeCueTimestamps) {\n  var reader = new shaka.util.DataViewReader(\n      new DataView(data),\n      shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n  var boxSize = shaka.util.Mp4Parser.findBox(\n      shaka.util.Mp4Parser.BOX_TYPE_MDAT, reader);\n  if (boxSize != shaka.util.Mp4Parser.BOX_NOT_FOUND) {\n    // mdat box found, parse the content\n    // valid media segment should have start and end time\n    goog.asserts.assert(\n        segmentStartTime != null, 'start time should not be null');\n    goog.asserts.assert(segmentEndTime != null, 'end time should not be null');\n    return shaka.media.Mp4VttParser.parseData_(\n        reader.readBytes(boxSize - 8).buffer, offset,\n        segmentStartTime, segmentEndTime);\n  }\n  var wvttBoxSize = shaka.util.Mp4Parser.findSampleDescriptionBox(\n      data, shaka.media.Mp4VttParser.BOX_TYPE_WVTT);\n  if (wvttBoxSize != shaka.util.Mp4Parser.BOX_NOT_FOUND) {\n    // a valid vtt init segment, no actual subtitles yet\n    return [];\n  } else {\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.INVALID_MP4_VTT);\n  }\n};\n\n\n/**\n * Parses the content of the mdat MP4 box into cue objects.\n *\n * @param {ArrayBuffer} data\n * @param {number} offset\n * @param {number} segmentStartTime\n * @param {number} segmentEndTime\n * @return {!Array.<!TextTrackCue>}\n * @private\n */\nshaka.media.Mp4VttParser.parseData_ = function(\n    data, offset, segmentStartTime, segmentEndTime) {\n  var reader = new shaka.util.DataViewReader(\n      new DataView(data),\n      shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n\n  segmentStartTime += offset;\n  segmentEndTime += offset;\n\n  var result = [];\n  // Cues are represented as vttc boxes. Each box corresponds to a cue.\n  while (reader.hasMoreData()) {\n    var boxSize = shaka.util.Mp4Parser.findBox(\n        shaka.media.Mp4VttParser.BOX_TYPE_VTTC, reader);\n    if (boxSize == shaka.util.Mp4Parser.BOX_NOT_FOUND) {\n      // No more cues\n      break;\n    }\n    var cue = shaka.media.Mp4VttParser.parseCue_(\n        reader.readBytes(boxSize - 8).buffer,\n        segmentStartTime, segmentEndTime);\n    if (cue)\n      result.push(cue);\n  }\n\n  return result;\n};\n\n\n/**\n * Parses a vttc box into a cue.\n *\n * @param {ArrayBuffer} data\n * @param {number} segmentStartTime\n * @param {number} segmentEndTime\n * @return {TextTrackCue}\n * @private\n */\nshaka.media.Mp4VttParser.parseCue_ = function(\n    data, segmentStartTime, segmentEndTime) {\n  var reader = new shaka.util.DataViewReader(\n      new DataView(data),\n      shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n\n  var payload;\n  var settings;\n  var id;\n\n  while (reader.hasMoreData()) {\n    var startPosition = reader.getPosition();\n    var size = reader.readUint32();\n    var type = reader.readUint32();\n    var content = shaka.util.StringUtils.fromUTF8(\n        reader.readBytes(size - 8).buffer);\n    if (size == 1) {\n      size = reader.readUint64();\n    } else if (size == 0) {\n      size = reader.getLength() - startPosition;\n    }\n\n    switch (type) {\n      case shaka.media.Mp4VttParser.BOX_TYPE_PAYL:\n        payload = content;\n        break;\n      case shaka.media.Mp4VttParser.BOX_TYPE_IDEN:\n        id = content;\n        break;\n      case shaka.media.Mp4VttParser.BOX_TYPE_STTG:\n        settings = content;\n        break;\n      default:\n        break;\n    }\n  }\n  // payload box is mandatory\n  if (!payload) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.INVALID_MP4_VTT);\n  }\n\n  var cue = shaka.media.TextEngine.makeCue(\n      segmentStartTime, segmentEndTime, payload);\n  if (!cue)\n    return null;\n\n  if (id)\n    cue.id = id;\n  if (settings) {\n    var parser = new shaka.util.TextParser(settings);\n    var word = parser.readWord();\n    while (word) {\n      if (!shaka.media.VttTextParser.parseSetting(cue, word)) {\n        shaka.log.warning('VTT parser encountered an invalid VTT setting: ',\n                          word,\n                          ' The setting will be ignored.');\n      }\n      parser.skipWhitespace();\n      word = parser.readWord();\n    }\n  }\n\n  return cue;\n};\n\n\n/** @const {number} */\nshaka.media.Mp4VttParser.BOX_TYPE_WVTT = 0x77767474;\n\n\n/** @const {number} */\nshaka.media.Mp4VttParser.BOX_TYPE_VTTC = 0x76747463;\n\n\n/** @const {number} */\nshaka.media.Mp4VttParser.BOX_TYPE_PAYL = 0x7061796C;\n\n\n/** @const {number} */\nshaka.media.Mp4VttParser.BOX_TYPE_IDEN = 0x6964656F;\n\n\n/** @const {number} */\nshaka.media.Mp4VttParser.BOX_TYPE_STTG = 0x73747467;\n\n\nshaka.media.TextEngine.registerParser(\n    'application/mp4; codecs=\"wvtt\"', shaka.media.Mp4VttParser);\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/media/playhead.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.Playhead');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.PresentationTimeline');\ngoog.require('shaka.media.TimeRangesUtils');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.IDestroyable');\n\n\n\n/**\n * Creates a Playhead, which manages the video's current time.\n *\n * The Playhead provides mechanisms for setting the presentation's start time,\n * restricting seeking to valid time ranges, and stopping playback for startup\n * and re- buffering.\n *\n * @param {HTMLMediaElement} video\n * @param {!shaka.media.PresentationTimeline} timeline\n * @param {number} rebufferingGoal\n * @param {?number} startTime The playhead's initial position in seconds. If\n *   null, defaults to the start of the presentation for VOD and the live-edge\n *   for live.\n * @param {function(boolean)} onBuffering Called and passed true when stopped\n *   for buffering; called and passed false when proceeding after buffering.\n *   If passed true, the callback should not set the video's playback rate.\n * @param {function()} onSeek Called when the user agent seeks to a time within\n *   the presentation timeline.\n *\n * @constructor\n * @struct\n * @implements {shaka.util.IDestroyable}\n */\nshaka.media.Playhead = function(\n    video, timeline, rebufferingGoal, startTime, onBuffering, onSeek) {\n  /** @private {HTMLMediaElement} */\n  this.video_ = video;\n\n  /** @private {shaka.media.PresentationTimeline} */\n  this.timeline_ = timeline;\n\n  /** @private {number} */\n  this.rebufferingGoal_ = rebufferingGoal;\n\n  /**\n   * The playhead's initial position in seconds, or null if it should\n   * automatically be calculated later.\n   * @private {?number}\n   * @const\n   */\n  this.startTime_ = startTime;\n\n  /** @private {?function(boolean)} */\n  this.onBuffering_ = onBuffering;\n\n  /** @private {?function()} */\n  this.onSeek_ = onSeek;\n\n  /** @private {shaka.util.EventManager} */\n  this.eventManager_ = new shaka.util.EventManager();\n\n  /** @private {boolean} */\n  this.buffering_ = false;\n\n  /** @private {number} */\n  this.playbackRate_ = 1;\n\n  /** @private {?number} */\n  this.trickPlayIntervalId_ = null;\n\n  /** @private {?number} */\n  this.watchdogTimer_ = null;\n\n  // Check if the video has already loaded some metadata.\n  if (video.readyState > 0) {\n    this.onLoadedMetadata_();\n  } else {\n    this.eventManager_.listen(\n        video, 'loadedmetadata', this.onLoadedMetadata_.bind(this));\n  }\n\n  this.eventManager_.listen(video, 'ratechange', this.onRateChange_.bind(this));\n  this.startWatchdogTimer_();\n};\n\n\n/** @override */\nshaka.media.Playhead.prototype.destroy = function() {\n  var p = this.eventManager_.destroy();\n  this.eventManager_ = null;\n  this.cancelWatchdogTimer_();\n\n  if (this.trickPlayIntervalId_ != null) {\n    window.clearInterval(this.trickPlayIntervalId_);\n    this.trickPlayIntervalId_ = null;\n  }\n\n  this.video_ = null;\n  this.timeline_ = null;\n  this.onBuffering_ = null;\n  this.onSeek_ = null;\n\n  return p;\n};\n\n\n/** @param {number} rebufferingGoal */\nshaka.media.Playhead.prototype.setRebufferingGoal = function(rebufferingGoal) {\n  this.rebufferingGoal_ = rebufferingGoal;\n};\n\n\n/**\n * Gets the playhead's current (logical) position.\n *\n * @return {number}\n */\nshaka.media.Playhead.prototype.getTime = function() {\n  if (this.video_.readyState > 0) {\n    // Although we restrict the video's currentTime elsewhere, clamp it here to\n    // ensure any timing issues (e.g., the user agent seeks and calls this\n    // function before we receive the 'seeking' event) don't cause us to return\n    // a time outside the segment availability window.\n    return this.clampTime_(this.video_.currentTime);\n  }\n\n  return this.getStartTime_();\n};\n\n\n/**\n * Gets the playhead's initial position in seconds.\n *\n * @return {number}\n * @private\n */\nshaka.media.Playhead.prototype.getStartTime_ = function() {\n  if (this.startTime_) {\n    return this.clampTime_(this.startTime_);\n  }\n\n  var startTime;\n  if (this.timeline_.getDuration() < Infinity) {\n    // If the presentation is VOD, or if the presentation is live but has\n    // finished broadcasting, then start from the beginning.\n    startTime = this.timeline_.getEarliestStart();\n  } else {\n    // Otherwise, start near the live-edge, but ensure that the startup\n    // buffering goal can be met\n    startTime = Math.max(\n        this.timeline_.getSeekRangeEnd(),\n        this.timeline_.getEarliestStart());\n  }\n  return startTime;\n};\n\n\n/**\n * Stops the playhead for buffering, or resumes the playhead after buffering.\n *\n * @param {boolean} buffering True to stop the playhead; false to allow it to\n *   continue.\n */\nshaka.media.Playhead.prototype.setBuffering = function(buffering) {\n  if (buffering != this.buffering_) {\n    this.buffering_ = buffering;\n    this.setPlaybackRate(this.playbackRate_);\n    this.onBuffering_(buffering);\n  }\n};\n\n\n/**\n * Starts the watchdog timer.\n * @private\n */\nshaka.media.Playhead.prototype.startWatchdogTimer_ = function() {\n  this.cancelWatchdogTimer_();\n  this.watchdogTimer_ =\n      window.setTimeout(this.onWatchdogTimer_.bind(this), 250);\n};\n\n\n/**\n * Cancels the watchdog timer, if any.\n * @private\n */\nshaka.media.Playhead.prototype.cancelWatchdogTimer_ = function() {\n  if (this.watchdogTimer_) {\n    window.clearTimeout(this.watchdogTimer_);\n    this.watchdogTimer_ = null;\n  }\n};\n\n\n/**\n * Called on a recurring timer to detect buffering events.\n * @private\n */\nshaka.media.Playhead.prototype.onWatchdogTimer_ = function() {\n  this.watchdogTimer_ = null;\n  this.startWatchdogTimer_();\n\n  // This uses an intersection of buffered ranges for both audio and video, so\n  // it's an accurate way to determine if we are buffering or not.\n  var bufferedAhead = shaka.media.TimeRangesUtils.bufferedAheadOfThreshold(\n      this.video_.buffered, this.video_.currentTime, 0.1);\n  var bufferEnd = shaka.media.TimeRangesUtils.bufferEnd(this.video_.buffered);\n\n  var fudgeFactor = shaka.media.Playhead.FUDGE_FACTOR_;\n  var threshold = shaka.media.Playhead.UNDERFLOW_THRESHOLD_;\n\n  var duration;\n  if (this.timeline_.isLive()) {\n    duration = this.timeline_.getSegmentAvailabilityEnd() - fudgeFactor;\n  } else {\n    duration = this.video_.duration - fudgeFactor;\n  }\n\n  var atEnd = (bufferEnd >= duration) || (this.video_.ended);\n  if (!this.buffering_) {\n    // If there are no buffered ranges but the playhead is at the end of\n    // the video then we shouldn't enter a buffering state.\n    if (!atEnd && bufferedAhead < threshold) {\n      this.setBuffering(true);\n    }\n  } else {\n    if (atEnd || bufferedAhead >= this.rebufferingGoal_) {\n      this.setBuffering(false);\n    }\n  }\n};\n\n\n/**\n * Gets the current effective playback rate.  This may be negative even if the\n * browser does not directly support rewinding.\n * @return {number}\n */\nshaka.media.Playhead.prototype.getPlaybackRate = function() {\n  return this.playbackRate_;\n};\n\n\n/**\n * Sets the playback rate.\n * @param {number} rate\n */\nshaka.media.Playhead.prototype.setPlaybackRate = function(rate) {\n  if (this.trickPlayIntervalId_ != null) {\n    window.clearInterval(this.trickPlayIntervalId_);\n    this.trickPlayIntervalId_ = null;\n  }\n\n  this.playbackRate_ = rate;\n  // All major browsers support playback rates above zero.  Only need fake\n  // trick play for negative rates.\n  this.video_.playbackRate = (this.buffering_ || rate < 0) ? 0 : rate;\n\n  if (!this.buffering_ && rate < 0) {\n    // Defer creating the timer until we stop buffering.  This function will be\n    // called again from setBuffering().\n    this.trickPlayIntervalId_ = window.setInterval(function() {\n      this.video_.currentTime += rate / 4;\n    }.bind(this), 250);\n  }\n};\n\n\n/**\n * Handles a 'ratechange' event.\n *\n * @private\n */\nshaka.media.Playhead.prototype.onRateChange_ = function() {\n  // NOTE: This will not allow explicitly setting the playback rate to 0 while\n  // the playback rate is negative.  Pause will still work.\n  var expectedRate =\n      this.buffering_ || this.playbackRate_ < 0 ? 0 : this.playbackRate_;\n  if (this.video_.playbackRate != expectedRate) {\n    shaka.log.debug('Video playback rate changed to', this.video_.playbackRate);\n    this.setPlaybackRate(this.video_.playbackRate);\n  }\n};\n\n\n/**\n * Handles a 'loadedmetadata' event.\n *\n * @private\n */\nshaka.media.Playhead.prototype.onLoadedMetadata_ = function() {\n  this.eventManager_.unlisten(this.video_, 'loadedmetadata');\n\n  // Move the real playhead to the start time.\n  var targetTime = this.getStartTime_();\n  if (Math.abs(this.video_.currentTime - targetTime) < 0.001) {\n    this.eventManager_.listen(\n        this.video_, 'seeking', this.onSeeking_.bind(this));\n    this.eventManager_.listen(\n        this.video_, 'playing', this.onPlaying_.bind(this));\n  } else {\n    this.eventManager_.listen(\n        this.video_, 'seeking', this.onSeekingToStartTime_.bind(this));\n    this.video_.currentTime = targetTime;\n  }\n};\n\n\n/**\n * Handles the 'seeking' event from the initial jump to the start time (if\n * there is one).\n *\n * @private\n */\nshaka.media.Playhead.prototype.onSeekingToStartTime_ = function() {\n  goog.asserts.assert(this.video_.readyState > 0,\n                      'readyState should be greater than 0');\n  this.eventManager_.unlisten(this.video_, 'seeking');\n  this.eventManager_.listen(this.video_, 'seeking', this.onSeeking_.bind(this));\n  this.eventManager_.listen(this.video_, 'playing', this.onPlaying_.bind(this));\n};\n\n\n/**\n * Handles a 'seeking' event.\n *\n * @private\n */\nshaka.media.Playhead.prototype.onSeeking_ = function() {\n  goog.asserts.assert(this.video_.readyState > 0,\n                      'readyState should be greater than 0');\n\n  var currentTime = this.video_.currentTime;\n  var targetTime = this.reposition_(currentTime);\n\n  if (Math.abs(targetTime - currentTime) > 0.001) {\n    this.movePlayhead_(currentTime, targetTime);\n    return;\n  }\n\n  shaka.log.v1('Seek to ' + currentTime);\n  this.onSeek_();\n};\n\n\n/**\n * Handles a 'playing' event.\n *\n * @private\n */\nshaka.media.Playhead.prototype.onPlaying_ = function() {\n  goog.asserts.assert(this.video_.readyState > 0,\n                      'readyState should be greater than 0');\n\n  var currentTime = this.video_.currentTime;\n  var targetTime = this.reposition_(currentTime);\n\n  if (Math.abs(targetTime - currentTime) > 0.001)\n    this.movePlayhead_(currentTime, targetTime);\n};\n\n\n/**\n * Computes a new playhead position that's within the presentation timeline.\n *\n * @param {number} currentTime\n * @return {number} The time to reposition the playhead to.\n * @private\n */\nshaka.media.Playhead.prototype.reposition_ = function(currentTime) {\n  var timeline = this.timeline_;\n  var start = timeline.getEarliestStart();\n  var end = timeline.getSegmentAvailabilityEnd();\n\n  if (!timeline.isLive() ||\n      timeline.getSegmentAvailabilityDuration() == Infinity) {\n    // If the presentation is live but has an infinite segment availability\n    // duration then we can treat it as VOD since the start of the window is\n    // not moving.\n    if (currentTime < start) {\n      shaka.log.v1('Playhead before start.');\n      return start;\n    } else if (currentTime > end) {\n      shaka.log.v1('Playhead past end.');\n      return end;\n    }\n    return currentTime;\n  }\n\n  // TODO: Link to public doc that explains the following code.\n\n  var left = start + 1;\n  var safe = left + this.rebufferingGoal_;\n\n  if (currentTime >= safe && currentTime <= end) {\n    shaka.log.v1('Playhead in safe region.');\n    return currentTime;\n  }\n\n  var bufferedAhead = shaka.media.TimeRangesUtils.bufferedAheadOf(\n      this.video_.buffered, currentTime);\n  if ((bufferedAhead != 0) && (currentTime >= left && currentTime <= end)) {\n    shaka.log.v1('Playhead outside safe region & in buffered region.');\n    return currentTime;\n  } else if (currentTime > end) {\n    shaka.log.v1('Playhead past end.');\n    return end;\n  } else if ((end < safe) && (currentTime >= left && currentTime <= end)) {\n    // The segment availability window is so small we cannot reposition the\n    // playhead normally; however, since |currentTime| is within the window, we\n    // don't have to do anything.\n    shaka.log.v1('Playhead outside safe region & in unbuffered region,',\n                 'but cannot reposition the playhead.');\n    return currentTime;\n  }\n\n  // It's not safe to buffer from |currentTime|, so reposition the playhead.\n  shaka.log.v1('Playhead outside safe region & in unbuffered region,',\n               'or playhead before start');\n  return Math.min(safe + 2, end);\n};\n\n\n/**\n * Moves the playhead to the target time, triggering a call to onSeeking_().\n *\n * @param {number} currentTime\n * @param {number} targetTime\n * @private\n */\nshaka.media.Playhead.prototype.movePlayhead_ = function(\n    currentTime, targetTime) {\n  shaka.log.debug('Moving playhead...',\n                  'currentTime=' + currentTime,\n                  'targetTime=' + targetTime);\n  this.video_.currentTime = targetTime;\n\n  // Sometimes, IE and Edge ignore re-seeks.  Check every 100ms and try\n  // again if need be, up to 10 tries.\n  // Delay stats over 100 runs of a re-seeking integration test:\n  // IE     -   0ms -  47%\n  // IE     - 100ms -  63%\n  // Edge   -   0ms -   2%\n  // Edge   - 100ms -  40%\n  // Edge   - 200ms -  32%\n  // Edge   - 300ms -  24%\n  // Edge   - 400ms -   2%\n  // Chrome -   0ms - 100%\n  // TODO: File a bug on IE/Edge about this.\n  var tries = 0;\n  var recheck = (function() {\n    if (!this.video_) return;\n    if (tries++ >= 10) return;\n\n    if (this.video_.currentTime == currentTime) {\n      // Sigh.  Try again.\n      this.video_.currentTime = targetTime;\n      setTimeout(recheck, 100);\n    }\n  }).bind(this);\n  setTimeout(recheck, 100);\n};\n\n\n/**\n * Clamps the given time to the segment availability window.\n *\n * @param {number} time The time in seconds.\n * @return {number} The clamped time in seconds.\n * @private\n */\nshaka.media.Playhead.prototype.clampTime_ = function(time) {\n  var start = this.timeline_.getEarliestStart();\n  if (time < start) return start;\n\n  var end = this.timeline_.getSegmentAvailabilityEnd();\n  if (time > end) return end;\n\n  return time;\n};\n\n\n/**\n * The threshold for underflow, in seconds.  If there is less than this amount\n * of data buffered, we will consider the player to be out of data.\n *\n * @private {number}\n * @const\n */\nshaka.media.Playhead.UNDERFLOW_THRESHOLD_ = 0.5;\n\n\n/**\n * A fudge factor used when comparing buffered ranges to the duration to\n * determine if we have buffered all available content.\n *\n * @private {number}\n * @const\n */\nshaka.media.Playhead.FUDGE_FACTOR_ = 0.1;\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/media/presentation_timeline.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.PresentationTimeline');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.SegmentReference');\n\n\n\n/**\n * Creates a PresentationTimeline.\n *\n * @param {?number} presentationStartTime The wall-clock time, in seconds,\n *   when the presentation started or will start. Only required for live.\n * @param {number} presentationDelay The delay to give the presentation, in\n *   seconds.  Only required for live.\n *\n * @see {shakaExtern.Manifest}\n *\n * @constructor\n * @struct\n * @export\n */\nshaka.media.PresentationTimeline = function(\n    presentationStartTime, presentationDelay) {\n  /** @private {?number} */\n  this.presentationStartTime_ = presentationStartTime;\n\n  /** @private {number} */\n  this.presentationDelay_ = presentationDelay;\n\n  /** @private {number} */\n  this.duration_ = Infinity;\n\n  /** @private {number} */\n  this.segmentAvailabilityDuration_ = Infinity;\n\n  /** @private {?number} */\n  this.maxSegmentDuration_ = 1;\n\n  /** @private {number} */\n  this.maxFirstSegmentStartTime_ = 0;\n\n  /** @private {number} */\n  this.clockOffset_ = 0;\n\n  /** @private {boolean} */\n  this.static_ = true;\n};\n\n\n/**\n * @return {number} The presentation's duration in seconds.\n *   Infinity indicates that the presentation continues indefinitely.\n * @export\n */\nshaka.media.PresentationTimeline.prototype.getDuration = function() {\n  return this.duration_;\n};\n\n\n/**\n * Sets the presentation's duration.\n *\n * @param {number} duration The presentation's duration in seconds.\n *   Infinity indicates that the presentation continues indefinitely.\n * @export\n */\nshaka.media.PresentationTimeline.prototype.setDuration = function(duration) {\n  goog.asserts.assert(duration > 0, 'duration must be > 0');\n  this.duration_ = duration;\n};\n\n\n/**\n * Sets the clock offset, which is the the difference between the client's clock\n * and the server's clock, in milliseconds (i.e., serverTime = Date.now() +\n * clockOffset).\n *\n * @param {number} offset The clock offset, in ms.\n * @export\n */\nshaka.media.PresentationTimeline.prototype.setClockOffset = function(offset) {\n  this.clockOffset_ = offset;\n};\n\n\n/**\n * Sets the presentation's static flag.\n *\n * @param {boolean} isStatic If true, the presentation is static, meaning all\n *   segments are available at once.\n * @export\n */\nshaka.media.PresentationTimeline.prototype.setStatic = function(isStatic) {\n  // NOTE: the argument name is not \"static\" because that's a keyword in ES6\n  this.static_ = isStatic;\n};\n\n\n/**\n * Gets the presentation's segment availability duration, which is the amount\n * of time, in seconds, that the start of a segment remains available after the\n * live-edge moves past the end of that segment. Infinity indicates that\n * segments remain available indefinitely. For example, if your live\n * presentation has a 5 minute DVR window and your segments are 10 seconds long\n * then the segment availability duration should be 4 minutes and 50 seconds.\n *\n * @return {number} The presentation's segment availability duration.\n * @export\n */\nshaka.media.PresentationTimeline.prototype.getSegmentAvailabilityDuration =\n    function() {\n  return this.segmentAvailabilityDuration_;\n};\n\n\n/**\n * Sets the presentation's segment availability duration. The segment\n * availability duration should only be set for live.\n *\n * @param {number} segmentAvailabilityDuration The presentation's new segment\n *   availability duration in seconds.\n * @export\n */\nshaka.media.PresentationTimeline.prototype.setSegmentAvailabilityDuration =\n    function(segmentAvailabilityDuration) {\n  goog.asserts.assert(segmentAvailabilityDuration >= 0,\n                      'segmentAvailabilityDuration must be >= 0');\n  this.segmentAvailabilityDuration_ = segmentAvailabilityDuration;\n};\n\n\n/**\n * Gives PresentationTimeline a Stream's segments so it can size and position\n * the segment availability window, and account for missing segment\n * information. This function should be called once for each Stream (no more,\n * no less).\n *\n * @param {number} periodStartTime\n * @param {!Array.<!shaka.media.SegmentReference>} references\n * @export\n */\nshaka.media.PresentationTimeline.prototype.notifySegments = function(\n    periodStartTime, references) {\n  if (references.length == 0)\n    return;\n\n  this.maxSegmentDuration_ = references.reduce(\n      function(max, r) { return Math.max(max, r.endTime - r.startTime); },\n      this.maxSegmentDuration_);\n\n  if (periodStartTime == 0) {\n    this.maxFirstSegmentStartTime_ =\n        Math.max(this.maxFirstSegmentStartTime_, references[0].startTime);\n  }\n\n  shaka.log.v1('notifySegments:',\n               'maxSegmentDuration=' + this.maxSegmentDuration_,\n               'maxFirstSegmentStartTime=' + this.maxFirstSegmentStartTime_);\n};\n\n\n/**\n * Gives PresentationTimeline a Stream's maximum segment duration so it can\n * size and position the segment availability window. This function should be\n * called once for each Stream (no more, no less), but does not have to be\n * called if notifySegments() is called instead for a particular stream.\n *\n * @param {number} maxSegmentDuration The maximum segment duration for a\n *   particular stream.\n * @export\n */\nshaka.media.PresentationTimeline.prototype.notifyMaxSegmentDuration = function(\n    maxSegmentDuration) {\n  this.maxSegmentDuration_ = Math.max(\n      this.maxSegmentDuration_, maxSegmentDuration);\n\n  shaka.log.v1('notifyNewSegmentDuration:',\n               'maxSegmentDuration=' + this.maxSegmentDuration_);\n};\n\n\n/**\n * @return {boolean} True if the presentation is live; otherwise, return\n *   false.\n * @export\n */\nshaka.media.PresentationTimeline.prototype.isLive = function() {\n  return this.duration_ == Infinity &&\n         !this.static_;\n};\n\n\n/**\n * @return {boolean} True if the presentation is in progress (meaning not live,\n *   but also not completely available); otherwise, return false.\n * @export\n */\nshaka.media.PresentationTimeline.prototype.isInProgress = function() {\n  return this.duration_ != Infinity &&\n         !this.static_;\n};\n\n\n/**\n * Gets the presentation's current earliest, available timestamp. This value\n * may be greater than the presentation's current segment availability start\n * time if segment information is missing or does not exist at the beginning of\n * the segment availability window.\n *\n * @return {number} The presentation's current earliest, available timestamp,\n *   in seconds, relative to the start of the presentation.\n * @export\n */\nshaka.media.PresentationTimeline.prototype.getEarliestStart = function() {\n  var maxFirstSegmentStartTime = Math.min(\n      this.maxFirstSegmentStartTime_, this.getSegmentAvailabilityEnd());\n  return Math.max(maxFirstSegmentStartTime,\n                  this.getSegmentAvailabilityStart());\n};\n\n\n/**\n * Gets the presentation's current segment availability start time. Segments\n * ending at or before this time should be assumed to be unavailable.\n *\n * @return {number} The current segment availability start time, in seconds,\n *   relative to the start of the presentation.\n * @export\n */\nshaka.media.PresentationTimeline.prototype.getSegmentAvailabilityStart =\n    function() {\n  if (this.segmentAvailabilityDuration_ == Infinity)\n    return 0;\n\n  var start =\n      this.getSegmentAvailabilityEnd() - this.segmentAvailabilityDuration_;\n  return Math.max(0, start);\n};\n\n\n/**\n * Gets the presentation's current segment availability end time. Segments\n * starting after this time should be assumed to be unavailable.\n *\n * @return {number} The current segment availability end time, in seconds,\n *   relative to the start of the presentation. Always returns the\n *   presentation's duration for video-on-demand.\n * @export\n */\nshaka.media.PresentationTimeline.prototype.getSegmentAvailabilityEnd =\n    function() {\n  if (!this.isLive() && !this.isInProgress())\n    return this.duration_;\n\n  return Math.min(this.getLiveEdge_(), this.duration_);\n};\n\n\n/**\n * Gets the seek range end.\n *\n * @return {number}\n * @export\n */\nshaka.media.PresentationTimeline.prototype.getSeekRangeEnd = function() {\n  var useDelay = this.isLive() || this.isInProgress();\n  var delay = useDelay ? this.presentationDelay_ : 0;\n  return Math.max(0, this.getSegmentAvailabilityEnd() - delay);\n};\n\n\n/**\n * @return {number} The current presentation time in seconds.\n * @private\n */\nshaka.media.PresentationTimeline.prototype.getLiveEdge_ = function() {\n  goog.asserts.assert(this.presentationStartTime_ != null,\n                      'Cannot compute timeline live edge without start time');\n  var now = (Date.now() + this.clockOffset_) / 1000.0;\n  return Math.max(\n      0, now - this.maxSegmentDuration_ - this.presentationStartTime_);\n};\n\n\nif (!COMPILED) {\n  /**\n   * Debug only: assert that the timeline parameters make sense for the type of\n   *   presentation (VOD, IPR, live).\n   */\n  shaka.media.PresentationTimeline.prototype.assertIsValid = function() {\n    if (this.isLive()) {\n      // Implied by isLive(): infinite and dynamic.\n      // Live streams should have a start time.\n      goog.asserts.assert(this.presentationStartTime_ != null,\n          'Detected as live stream, but does not match our model of live!');\n    } else if (this.isInProgress()) {\n      // Implied by isInProgress(): finite and dynamic.\n      // IPR streams should have a start time, and segments should not expire.\n      goog.asserts.assert(this.presentationStartTime_ != null &&\n                          this.segmentAvailabilityDuration_ == Infinity,\n          'Detected as IPR stream, but does not match our model of IPR!');\n    } else {  // VOD\n      // VOD segments should not expire and the presentation should be finite\n      // and static.\n      goog.asserts.assert(this.segmentAvailabilityDuration_ == Infinity &&\n                          this.duration_ != Infinity &&\n                          this.static_,\n          'Detected as VOD stream, but does not match our model of VOD!');\n    }\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/media/segment_index.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.SegmentIndex');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.IDestroyable');\n\n\n\n/**\n * Creates a SegmentIndex.\n *\n * @param {!Array.<!shaka.media.SegmentReference>} references The list of\n *   SegmentReferences, which must be sorted first by their start times\n *   (ascending) and second by their end times (ascending), and have\n *   continuous, increasing positions.\n *\n * @constructor\n * @struct\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.media.SegmentIndex = function(references) {\n  if (!COMPILED) {\n    shaka.media.SegmentIndex.assertCorrectReferences_(references);\n  }\n\n  /** @private {Array.<!shaka.media.SegmentReference>} */\n  this.references_ = references;\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.media.SegmentIndex.prototype.destroy = function() {\n  this.references_ = null;\n  return Promise.resolve();\n};\n\n\n/**\n * Finds the position of the segment for the given time, in seconds, relative\n * to the start of a particular Period. Returns the position of the segment\n * with the largest end time if more than one segment is known for the given\n * time.\n *\n * @param {number} time\n * @return {?number} The position of the segment, or null\n *   if the position of the segment could not be determined.\n * @export\n */\nshaka.media.SegmentIndex.prototype.find = function(time) {\n  // For live streams, searching from the end is faster. For VOD, it balances\n  // out either way. In both cases, references_.length is small enough that the\n  // difference isn't huge.\n  for (var i = this.references_.length - 1; i >= 0; --i) {\n    var r = this.references_[i];\n    // Note that a segment ends immediately before the end time.\n    if ((time >= r.startTime) && (time < r.endTime)) {\n      return r.position;\n    }\n  }\n  return null;\n};\n\n\n/**\n * Gets the SegmentReference for the segment at the given position.\n *\n * @param {number} position The position of the segment.\n * @return {shaka.media.SegmentReference} The SegmentReference, or null if\n *   no such SegmentReference exists.\n * @export\n */\nshaka.media.SegmentIndex.prototype.get = function(position) {\n  if (this.references_.length == 0)\n    return null;\n\n  var index = position - this.references_[0].position;\n  if (index < 0 || index >= this.references_.length)\n    return null;\n\n  return this.references_[index];\n};\n\n\n/**\n * Merges the given SegmentReferences.  Supports extending the original\n * references only.  Will not replace old references or interleave new ones.\n *\n * @param {!Array.<!shaka.media.SegmentReference>} references The list of\n *   SegmentReferences, which must be sorted first by their start times\n *   (ascending) and second by their end times (ascending), and have\n *   continuous, increasing positions.\n * @export\n */\nshaka.media.SegmentIndex.prototype.merge = function(references) {\n  if (!COMPILED) {\n    shaka.media.SegmentIndex.assertCorrectReferences_(references);\n  }\n\n  var newReferences = [];\n  var i = 0;\n  var j = 0;\n\n  while ((i < this.references_.length) && (j < references.length)) {\n    var r1 = this.references_[i];\n    var r2 = references[j];\n\n    if (r1.startTime < r2.startTime) {\n      newReferences.push(r1);\n      i++;\n    } else if (r1.startTime > r2.startTime) {\n      // Drop the new reference if it would have to be interleaved with the\n      // old one.  Issue a warning, since this is not a supported update.\n      shaka.log.warning('Refusing to rewrite original references on update!');\n      j++;\n    } else {\n      // When period is changed, fitSegmentReference will expand the last\n      // segment to the start of the next period.  So, it is valid to have end\n      // time updated to the last segment reference in a period\n      if (Math.abs(r1.endTime - r2.endTime) > 0.1) {\n        goog.asserts.assert(r2.endTime > r1.endTime &&\n            i == this.references_.length - 1 &&\n            j == references.length - 1,\n            'This should be an update of the last segment in a period');\n        newReferences.push(r2);\n      } else {\n        // Drop the new reference if there's an old reference with the\n        // same time.\n        newReferences.push(r1);\n      }\n      i++;\n      j++;\n    }\n  }\n\n  while (i < this.references_.length) {\n    newReferences.push(this.references_[i++]);\n  }\n\n  if (newReferences.length) {\n    // The rest of these refs may need to be renumbered.\n    var nextPosition = newReferences[newReferences.length - 1].position + 1;\n    while (j < references.length) {\n      var r = references[j++];\n      var r2 = new shaka.media.SegmentReference(nextPosition++,\n          r.startTime, r.endTime, r.getUris, r.startByte, r.endByte);\n      newReferences.push(r2);\n    }\n  } else {\n    newReferences = references;\n  }\n\n  if (!COMPILED) {\n    shaka.media.SegmentIndex.assertCorrectReferences_(newReferences);\n  }\n\n  this.references_ = newReferences;\n};\n\n\n/**\n * Removes all SegmentReferences that end before the given time.\n *\n * @param {number} time The time in seconds.\n * @export\n */\nshaka.media.SegmentIndex.prototype.evict = function(time) {\n  for (var i = 0; i < this.references_.length; ++i) {\n    if (this.references_[i].endTime > time)\n      break;\n  }\n  this.references_.splice(0, i);\n};\n\n\nif (!COMPILED) {\n  /**\n   * Asserts that the given SegmentReferences are sorted and have continuous,\n   * increasing positions.\n   *\n   * @param {!Array.<shaka.media.SegmentReference>} references\n   * @private\n   */\n  shaka.media.SegmentIndex.assertCorrectReferences_ = function(references) {\n    goog.asserts.assert(references.every(function(r2, i) {\n      if (i == 0) return true;\n      var r1 = references[i - 1];\n      if (r2.position != r1.position + 1) return false;\n      if (r1.startTime < r2.startTime) {\n        return true;\n      } else if (r1.startTime > r2.startTime) {\n        return false;\n      } else {\n        if (r1.endTime <= r2.endTime) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    }), 'SegmentReferences are incorrect');\n  };\n}\n\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/media/segment_reference.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.InitSegmentReference');\ngoog.provide('shaka.media.SegmentReference');\n\ngoog.require('goog.asserts');\n\n\n\n/**\n * Creates an InitSegmentReference, which provides the location to an\n * initialization segment.\n *\n * @param {function():!Array.<string>} uris\n *   A function that creates the URIs of the resource containing the segment.\n * @param {number} startByte The offset from the start of the resource to the\n *   start of the segment.\n * @param {?number} endByte The offset from the start of the resource to the\n *   end of the segment, inclusive. null indicates that the segment extends\n *   to the end of the resource.\n *\n * @constructor\n * @struct\n * @export\n */\nshaka.media.InitSegmentReference = function(uris, startByte, endByte) {\n  /** @type {function():!Array.<string>} */\n  this.getUris = uris;\n\n  /** @const {number} */\n  this.startByte = startByte;\n\n  /** @const {?number} */\n  this.endByte = endByte;\n};\n\n\n\n/**\n * Creates a SegmentReference, which provides the start time, end time, and\n * location to a media segment.\n *\n * @param {number} position The segment's position within a particular Period.\n *   The following should hold true between any two SegmentReferences from the\n *   same Period, r1 and r2:\n *   IF r2.position > r1.position THEN\n *     [ (r2.startTime > r1.startTime) OR\n *       (r2.startTime == r1.startTime AND r2.endTime >= r1.endTime) ]\n * @param {number} startTime The segment's start time in seconds, relative to\n *   the start of a particular Period.\n * @param {number} endTime The segment's end time in seconds, relative to\n *   the start of a particular Period. The segment ends the instant before\n *   this time, so |endTime| must be strictly greater than |startTime|.\n * @param {function():!Array.<string>} uris\n *   A function that creates the URIs of the resource containing the segment.\n * @param {number} startByte The offset from the start of the resource to the\n *   start of the segment.\n * @param {?number} endByte The offset from the start of the resource to the\n *   end of the segment, inclusive. null indicates that the segment extends\n *   to the end of the resource.\n *\n * @constructor\n * @struct\n * @export\n */\nshaka.media.SegmentReference = function(\n    position, startTime, endTime, uris, startByte, endByte) {\n  goog.asserts.assert(startTime < endTime,\n                      'startTime must be less than endTime');\n  goog.asserts.assert((startByte < endByte) || (endByte == null),\n                      'startByte must be < endByte');\n  /** @const {number} */\n  this.position = position;\n\n  /** @const {number} */\n  this.startTime = startTime;\n\n  /** @const {number} */\n  this.endTime = endTime;\n\n  /** @type {function():!Array.<string>} */\n  this.getUris = uris;\n\n  /** @const {number} */\n  this.startByte = startByte;\n\n  /** @const {?number} */\n  this.endByte = endByte;\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/media/streaming_engine.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.StreamingEngine');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.MediaSourceEngine');\ngoog.require('shaka.media.Playhead');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.MapUtils');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.StreamUtils');\n\n\n\n/**\n * Creates a StreamingEngine.\n *\n * The StreamingEngine is responsible for setting up the Manifest's Streams\n * (i.e., for calling each Stream's createSegmentIndex() function), for\n * downloading segments, for co-ordinating audio, video, and text buffering,\n * and for handling Period transitions. The StreamingEngine provides an\n * interface to switch between Streams, but it does not choose which Streams to\n * switch to.\n *\n * The StreamingEngine notifies its owner when it needs to buffer a new Period,\n * so its owner can choose which Streams within that Period to initially\n * buffer. Moreover, the StreamingEngine also notifies its owner when any\n * Stream within the current Period may be switched to, so its owner can switch\n * bitrates, resolutions, or languages.\n *\n * The StreamingEngine does not need to be notified about changes to the\n * Manifest's SegmentIndexes; however, it does need to be notified when new\n * Periods are added to the Manifest, so it can set up that Period's Streams.\n *\n * To start the StreamingEngine the owner must first call configure() followed\n * by init(). The StreamingEngine will then call onChooseStreams(p) when it\n * needs to buffer Period p; it will then switch to the Streams returned from\n * that function. The StreamingEngine will call onCanSwitch() when any\n * Stream within the current Period may be switched to.\n *\n * The owner must call seeked() each time the playhead moves to a new location\n * within the presentation timeline; however, the owner may forego calling\n * seeked() when the playhead moves outside the presentation timeline.\n *\n * @param {!shaka.media.Playhead} playhead The Playhead. The caller retains\n *   ownership.\n * @param {!shaka.media.MediaSourceEngine} mediaSourceEngine The\n *   MediaSourceEngine. The caller retains ownership.\n * @param {shaka.net.NetworkingEngine} netEngine\n * @param {shakaExtern.Manifest} manifest\n * @param {function(!shakaExtern.Period): !Object.<string, shakaExtern.Stream>}\n *   onChooseStreams Called when the given Period needs to be buffered. The\n *   StreamingEngine will switch to the Streams returned from this function.\n *   The caller cannot call switch() directly until the StreamingEngine calls\n *   onCanSwitch()\n * @param {function()} onCanSwitch Called when any Stream within the current\n *   Period may be switched to.\n * @param {function(!shaka.util.Error)} onError Called when an error occurs.\n *   If the error is recoverable (see @link{shaka.util.Error}) then the\n *   caller may invoke either StreamingEngine.switch() or\n *   StreamingEngine.seeked() to attempt recovery.\n * @param {function()=} opt_onInitialStreamsSetup Optional callback which\n *   is called when the initial set of Streams have been setup. Intended\n *   to be used by tests.\n * @param {function()=} opt_onStartupComplete Optional callback which\n *   is called when startup has completed. Intended to be used by tests.\n *\n * @constructor\n * @struct\n * @implements {shaka.util.IDestroyable}\n */\nshaka.media.StreamingEngine = function(\n    playhead, mediaSourceEngine, netEngine, manifest,\n    onChooseStreams, onCanSwitch, onError,\n    opt_onInitialStreamsSetup, opt_onStartupComplete) {\n  /** @private {shaka.media.Playhead} */\n  this.playhead_ = playhead;\n\n  /** @private {shaka.media.MediaSourceEngine} */\n  this.mediaSourceEngine_ = mediaSourceEngine;\n\n  /** @private {shaka.net.NetworkingEngine} */\n  this.netEngine_ = netEngine;\n\n  /** @private {?shakaExtern.Manifest} */\n  this.manifest_ = manifest;\n\n  /**\n   * @private\n   *     {?function(!shakaExtern.Period): !Object.<string, shakaExtern.Stream>}\n   */\n  this.onChooseStreams_ = onChooseStreams;\n\n  /** @private {?function()} */\n  this.onCanSwitch_ = onCanSwitch;\n\n  /** @private {?function(!shaka.util.Error)} */\n  this.onError_ = onError;\n\n  /** @private {?function()} */\n  this.onInitialStreamsSetup_ = opt_onInitialStreamsSetup || null;\n\n  /** @private {?function()} */\n  this.onStartupComplete_ = opt_onStartupComplete || null;\n\n  /** @private {?shakaExtern.StreamingConfiguration} */\n  this.config_ = null;\n\n  /** @private {number} */\n  this.bufferingGoalScale_ = 1;\n\n  /** @private {Promise} */\n  this.setupPeriodPromise_ = Promise.resolve();\n\n  /**\n   * Maps a Period's index to an object that indicates that either\n   *   1. the Period has not been set up (undefined)\n   *   2. the Period is being set up ([a PublicPromise, false]),\n   *   3. the Period is set up (i.e., all Streams within the Period are set up)\n   *      and can be switched to ([a PublicPromise, true]).\n   *\n   * @private {Array.<?{promise: shaka.util.PublicPromise, resolved: boolean}>}\n   */\n  this.canSwitchPeriod_ = [];\n\n  /**\n   * Maps a Stream's ID to an object that indicates that either\n   *   1. the Stream has not been set up (undefined)\n   *   2. the Stream is being set up ([a Promise instance, false]),\n   *   3. the Stream is set up and can be switched to\n   *      ([a Promise instance, true]).\n   *\n   * @private {Object.<number,\n   *                   ?{promise: shaka.util.PublicPromise, resolved: boolean}>}\n   */\n  this.canSwitchStream_ = {};\n\n  /**\n   * Maps a content type, e.g., 'audio', 'video', or 'text', to a MediaState.\n   *\n   * @private {Object.<string, !shaka.media.StreamingEngine.MediaState_>}\n   */\n  this.mediaStates_ = {};\n\n  /**\n   * Set to true once one segment of each content type has been buffered.\n   *\n   * @private {boolean}\n   */\n  this.startupComplete_ = false;\n\n  /**\n   * Set to true on fatal error.  Interrupts fetchAndAppend_().\n   *\n   * @private {boolean}\n   */\n  this.fatalError_ = false;\n\n  /** @private {boolean} */\n  this.destroyed_ = false;\n};\n\n\n/**\n * @typedef {{\n *   type: string,\n *   stream: shakaExtern.Stream,\n *   lastStream: ?shakaExtern.Stream,\n *   lastSegmentReference: shaka.media.SegmentReference,\n *   needInitSegment: boolean,\n *   needPeriodIndex: number,\n *   endOfStream: boolean,\n *   performingUpdate: boolean,\n *   updateTimer: ?number,\n *   waitingToClearBuffer: boolean,\n *   waitingToFlushBuffer: boolean,\n *   clearingBuffer: boolean,\n *   recovering: boolean,\n *   hasError: boolean,\n *   resumeAt: number\n * }}\n *\n * @description\n * Contains the state of a logical stream, i.e., a sequence of segmented data\n * for a particular content type. At any given time there is a Stream object\n * associated with the state of the logical stream.\n *\n * @property {string} type\n *   The stream's content type, e.g., 'audio', 'video', or 'text'.\n * @property {shakaExtern.Stream} stream\n *   The current Stream.\n * @property {?shakaExtern.Stream} lastStream\n *   The Stream of the last segment that was appended.\n * @property {shaka.media.SegmentReference} lastSegmentReference\n *   The SegmentReference of the last segment that was appended.\n * @property {boolean} needInitSegment\n *   True indicates that |stream|'s init segment must be inserted before the\n *   next media segment is appended.\n * @property {boolean} endOfStream\n *   True indicates that the end of the buffer has hit the end of the\n *   presentation.\n * @property {number} needPeriodIndex\n *   The index of the Period which needs to be buffered.\n * @property {boolean} performingUpdate\n *   True indicates that an update is in progress.\n * @property {?number} updateTimer\n *   A non-null value indicates that an update is scheduled.\n * @property {boolean} waitingToClearBuffer\n *   True indicates that the buffer must be cleared after the current update\n *   finishes.\n * @property {boolean} waitingToFlushBuffer\n *   True indicates that the buffer must be flushed after it is cleared.\n * @property {boolean} clearingBuffer\n *   True indicates that the buffer is being cleared.\n * @property {boolean} recovering\n *   True indicates that the last segment was not appended because it could not\n *   fit in the buffer.\n * @property {boolean} hasError\n *   True indicates that the stream has encountered an error and has stopped\n *   updates.\n * @property {number} resumeAt\n *   An override for the time to start performing updates at.  If the playhead\n *   is behind this time, update_() will still start fetching segments from\n *   this time.  If the playhead is ahead of the time, this field is ignored.\n */\nshaka.media.StreamingEngine.MediaState_;\n\n\n/**\n * The minimum number seconds that will remain buffered after evicting media.\n *\n * @const {number}\n */\nshaka.media.StreamingEngine.prototype.MIN_BUFFER_LENGTH = 2;\n\n\n/**\n * Gets the StreamingEngine's rebuffering goal.\n *\n * @param {shakaExtern.Manifest} manifest\n * @param {shakaExtern.StreamingConfiguration} config\n * @param {number} scaleFactor\n *\n * @return {number}\n */\nshaka.media.StreamingEngine.getRebufferingGoal = function(\n    manifest, config, scaleFactor) {\n  return scaleFactor *\n         Math.max(manifest.minBufferTime || 0, config.rebufferingGoal);\n};\n\n\n/** @override */\nshaka.media.StreamingEngine.prototype.destroy = function() {\n  for (var type in this.mediaStates_) {\n    this.cancelUpdate_(this.mediaStates_[type]);\n  }\n\n  this.playhead_ = null;\n  this.mediaSourceEngine_ = null;\n  this.netEngine_ = null;\n  this.manifest_ = null;\n  this.setupPeriodPromise_ = null;\n  this.onChooseStreams_ = null;\n  this.onCanSwitch_ = null;\n  this.onError_ = null;\n  this.onInitialStreamsSetup_ = null;\n  this.onStartupComplete_ = null;\n  this.canSwitchPeriod_ = null;\n  this.canSwitchStream_ = null;\n  this.mediaStates_ = null;\n  this.config_ = null;\n\n  this.destroyed_ = true;\n\n  return Promise.resolve();\n};\n\n\n/**\n * Called by the Player to provide an updated configuration any time it changes.\n * Will be called at least once before init().\n *\n * @param {shakaExtern.StreamingConfiguration} config\n */\nshaka.media.StreamingEngine.prototype.configure = function(config) {\n  this.config_ = config;\n\n  goog.asserts.assert(this.manifest_, 'manifest_ should not be null');\n  var rebufferingGoal = shaka.media.StreamingEngine.getRebufferingGoal(\n      this.manifest_, this.config_, this.bufferingGoalScale_);\n  this.playhead_.setRebufferingGoal(rebufferingGoal);\n};\n\n\n/**\n * Initializes the StreamingEngine.\n *\n * After this function is called the StreamingEngine will call\n * onChooseStreams(p) when it needs to buffer Period p and onCanSwitch() when\n * any Stream within that Period may be switched to.\n *\n * After the StreamingEngine calls onChooseStreams(p) for the first time, it\n * will begin setting up the Streams returned from that function and\n * subsequently switch to them. However, the StreamingEngine will not begin\n * setting up any other Streams until at least one segment from each of the\n * initial set of Streams has been buffered (this reduces startup latency).\n * After the StreamingEngine completes this startup phase it will begin setting\n * up each Period's Streams (while buffering in parrallel).\n *\n * When the StreamingEngine needs to buffer the next Period it will have\n * already set up that Period's Streams. So, when the StreamingEngine calls\n * onChooseStreams(p) after the first time, the StreamingEngine will\n * immediately switch to the Streams returned from that function.\n *\n * @return {!Promise}\n */\nshaka.media.StreamingEngine.prototype.init = function() {\n  var MapUtils = shaka.util.MapUtils;\n  goog.asserts.assert(this.config_,\n      'StreamingEngine configure() must be called before init()!');\n\n  // Determine which Period we must buffer.\n  var playheadTime = this.playhead_.getTime();\n  var needPeriodIndex = this.findPeriodContainingTime_(playheadTime);\n\n  // Get the initial set of Streams.\n  var streamsByType =\n      this.onChooseStreams_(this.manifest_.periods[needPeriodIndex]);\n  if (MapUtils.empty(streamsByType)) {\n    shaka.log.error('init: no Streams chosen');\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Category.STREAMING,\n        shaka.util.Error.Code.INVALID_STREAMS_CHOSEN));\n  }\n\n  // Setup the initial set of Streams and then begin each update cycle. After\n  // startup completes onUpdate_() will set up the remaining Periods.\n  return this.initStreams_(streamsByType).then(function() {\n    shaka.log.debug('init: completed initial Stream setup');\n\n    // Subtlety: onInitialStreamsSetup_() may call switch() or seeked(), so we\n    // must schedule an update beforehand so |updateTimer| is set.\n    if (this.onInitialStreamsSetup_) {\n      shaka.log.v1('init: calling onInitialStreamsSetup_()...');\n      this.onInitialStreamsSetup_();\n    }\n  }.bind(this));\n};\n\n\n/**\n * Gets the current Period the stream is in.  This Period may not be initialized\n * yet if canSwitch(period) has not been called yet.\n * @return {shakaExtern.Period}\n */\nshaka.media.StreamingEngine.prototype.getCurrentPeriod = function() {\n  var playheadTime = this.playhead_.getTime();\n  var needPeriodIndex = this.findPeriodContainingTime_(playheadTime);\n  return this.manifest_.periods[needPeriodIndex];\n};\n\n\n/**\n * Gets a map of all the active streams.\n * @return {!Object.<string, shakaExtern.Stream>}\n */\nshaka.media.StreamingEngine.prototype.getActiveStreams = function() {\n  goog.asserts.assert(this.mediaStates_, 'Must be initialized');\n  var MapUtils = shaka.util.MapUtils;\n  return MapUtils.map(\n      this.mediaStates_, function(state) { return state.stream; });\n};\n\n\n/**\n * Notifies StreamingEngine that a new stream was added to the manifest.  This\n * initializes the given stream.  This returns a Promise that resolves when\n * the stream has been set up.\n *\n * @param {string} type\n * @param {shakaExtern.Stream} stream\n * @return {!Promise}\n */\nshaka.media.StreamingEngine.prototype.notifyNewStream = function(type, stream) {\n  /** @type {!Object.<string, shakaExtern.Stream>} */\n  var streamsByType = {};\n  streamsByType[type] = stream;\n  return this.initStreams_(streamsByType);\n};\n\n\n/**\n * Switches to the given Stream. |stream| may be from any StreamSet or any\n * Period.\n *\n * @param {string} contentType |stream|'s content type.\n * @param {shakaExtern.Stream} stream\n * @param {boolean} clearBuffer\n */\nshaka.media.StreamingEngine.prototype.switch = function(\n    contentType, stream, clearBuffer) {\n  var mediaState = this.mediaStates_[contentType];\n  if (!mediaState && contentType == 'text' &&\n      this.config_.ignoreTextStreamFailures) {\n    this.notifyNewStream('text', stream);\n    return;\n  }\n  goog.asserts.assert(mediaState, 'switch: expected mediaState to exist');\n  if (!mediaState) return;\n\n  // Ensure the Period is ready.\n  var periodIndex = this.findPeriodContainingStream_(stream);\n  var canSwitchRecord = this.canSwitchPeriod_[periodIndex];\n  goog.asserts.assert(\n      canSwitchRecord && canSwitchRecord.resolved,\n      'switch: expected Period ' + periodIndex + ' to be ready');\n  if (!canSwitchRecord || !canSwitchRecord.resolved) return;\n\n  // Sanity check. If the Period is ready then the Stream should be ready too.\n  canSwitchRecord = this.canSwitchStream_[stream.id];\n  goog.asserts.assert(canSwitchRecord && canSwitchRecord.resolved,\n                      'switch: expected Stream ' + stream.id + ' to be ready');\n  if (!canSwitchRecord || !canSwitchRecord.resolved) return;\n\n  if (mediaState.stream == stream) {\n    var streamTag = shaka.media.StreamingEngine.logPrefix_(mediaState);\n    shaka.log.debug('switch: Stream ' + streamTag + ' already active');\n    return;\n  }\n\n  mediaState.stream = stream;\n  mediaState.needInitSegment = true;\n\n  var streamTag = shaka.media.StreamingEngine.logPrefix_(mediaState);\n  shaka.log.debug('switch: switching to Stream ' + streamTag);\n\n  if (clearBuffer) {\n    if (mediaState.clearingBuffer) {\n      // We are already going to clear the buffer, but make sure it is also\n      // flushed.\n      mediaState.waitingToFlushBuffer = true;\n    } else if (mediaState.performingUpdate) {\n      // We are performing an update, so we have to wait until it's finished.\n      // onUpdate_() will call clearBuffer_() when the update has\n      // finished.\n      mediaState.waitingToClearBuffer = true;\n      mediaState.waitingToFlushBuffer = true;\n    } else {\n      // Cancel the update timer, if any.\n      this.cancelUpdate_(mediaState);\n      // Clear right away.\n      this.clearBuffer_(mediaState, /* flush */ true);\n    }\n  }\n};\n\n\n/**\n * Notifies the StreamingEngine that the playhead has moved to a valid time\n * within the presentation timeline.\n */\nshaka.media.StreamingEngine.prototype.seeked = function() {\n  goog.asserts.assert(this.mediaStates_, 'Must not be destroyed');\n\n  var playheadTime = this.playhead_.getTime();\n  var isAllBuffered = Object.keys(this.mediaStates_).every(function(type) {\n    // Don't use a fudge factor here since Chrome doesn't jump gaps after a seek\n    // https://github.com/google/shaka-player/issues/655\n    return this.mediaSourceEngine_.bufferedAheadOf(type, playheadTime) > 0;\n  }.bind(this));\n\n  // Only treat as a buffered seek if every media state has a buffer.  For\n  // example, if we have buffered text but not video, we should still clear\n  // every buffer so all media states need the same Period.\n  if (isAllBuffered) {\n    shaka.log.debug(\n        '(all): seeked: buffered seek: playheadTime=' + playheadTime);\n    return;\n  }\n\n  // This was an unbuffered seek (for at least one stream), clear all buffers.\n  // Don't clear only some of the buffers because we can become stalled since\n  // the media states are waiting for different Periods.\n  for (var type in this.mediaStates_) {\n    var mediaState = this.mediaStates_[type];\n    var logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n    if (mediaState.clearingBuffer) {\n      // We're already clearing the buffer, so we don't need to clear the\n      // buffer again.\n      shaka.log.debug(logPrefix, 'seeked: already clearing the buffer');\n      continue;\n    }\n\n    if (mediaState.waitingToClearBuffer) {\n      // May not be performing an update, but an update will still happen.\n      // See: https://github.com/google/shaka-player/issues/334\n      shaka.log.debug(logPrefix, 'seeked: unbuffered seek: already waiting');\n      continue;\n    }\n\n    if (mediaState.performingUpdate) {\n      // We are performing an update, so we have to wait until it's finished.\n      // onUpdate_() will call clearBuffer_() when the update has\n      // finished.\n      shaka.log.debug(logPrefix, 'seeked: unbuffered seek: currently updating');\n      mediaState.waitingToClearBuffer = true;\n      continue;\n    }\n\n    if (this.mediaSourceEngine_.bufferStart(type) == null) {\n      // Nothing buffered.\n      shaka.log.debug(logPrefix, 'seeked: unbuffered seek: nothing buffered');\n      if (mediaState.updateTimer == null) {\n        // Note: an update cycle stops when we buffer to the end of the\n        // presentation or Period, or when we raise an error.\n        this.scheduleUpdate_(mediaState, 0);\n      }\n      continue;\n    }\n\n    // An update may be scheduled, but we can just cancel it and clear the\n    // buffer right away. Note: clearBuffer_() will schedule the next update.\n    shaka.log.debug(logPrefix, 'seeked: unbuffered seek: handling right now');\n    this.cancelUpdate_(mediaState);\n    this.clearBuffer_(mediaState, /* flush */ false);\n  }\n};\n\n\n/**\n * Initializes the given streams and media states if required.  This will\n * schedule updates for the given types.\n *\n * @param {!Object.<string, shakaExtern.Stream>} streamsByType\n * @param {number=} opt_resumeAt\n * @return {!Promise}\n * @private\n */\nshaka.media.StreamingEngine.prototype.initStreams_ = function(\n    streamsByType, opt_resumeAt) {\n  var MapUtils = shaka.util.MapUtils;\n  goog.asserts.assert(this.config_,\n      'StreamingEngine configure() must be called before init()!');\n\n  // Determine which Period we must buffer.\n  var playheadTime = this.playhead_.getTime();\n  var needPeriodIndex = this.findPeriodContainingTime_(playheadTime);\n\n  // Init MediaSourceEngine.\n  var typeConfig = MapUtils.map(streamsByType, function(stream) {\n    return shaka.util.StreamUtils.getFullMimeType(\n        stream.mimeType, stream.codecs);\n  });\n\n  this.mediaSourceEngine_.init(typeConfig,\n                               this.config_.useRelativeCueTimestamps);\n  this.setDuration_();\n\n  // Setup the initial set of Streams and then begin each update cycle. After\n  // startup completes onUpdate_() will set up the remaining Periods.\n  var streams = MapUtils.values(streamsByType);\n  return this.setupStreams_(streams).then(function() {\n    if (this.destroyed_) return;\n\n    for (var type in streamsByType) {\n      var stream = streamsByType[type];\n      if (!this.mediaStates_[type]) {\n        this.mediaStates_[type] = {\n          stream: stream,\n          type: type,\n          lastStream: null,\n          lastSegmentReference: null,\n          needInitSegment: true,\n          needPeriodIndex: needPeriodIndex,\n          endOfStream: false,\n          performingUpdate: false,\n          updateTimer: null,\n          waitingToClearBuffer: false,\n          waitingToFlushBuffer: false,\n          clearingBuffer: false,\n          recovering: false,\n          hasError: false,\n          resumeAt: opt_resumeAt || 0\n        };\n        this.scheduleUpdate_(this.mediaStates_[type], 0);\n      }\n    }\n  }.bind(this));\n};\n\n\n/**\n * Sets up the given Period if necessary. Calls onError_() if an error\n * occurs.\n *\n * @param {number} periodIndex The Period's index.\n * @return {!Promise} A Promise which is resolved when the given Period is\n *   setup.\n * @private\n */\nshaka.media.StreamingEngine.prototype.setupPeriod_ = function(periodIndex) {\n  var Functional = shaka.util.Functional;\n  var canSwitchRecord = this.canSwitchPeriod_[periodIndex];\n  if (canSwitchRecord) {\n    shaka.log.debug(\n        '(all) Period ' + periodIndex + ' is being or has been set up');\n    goog.asserts.assert(canSwitchRecord.promise, 'promise must not be null');\n    return canSwitchRecord.promise;\n  }\n\n  shaka.log.debug('(all) setting up Period ' + periodIndex);\n  canSwitchRecord = {\n    promise: new shaka.util.PublicPromise(),\n    resolved: false\n  };\n  this.canSwitchPeriod_[periodIndex] = canSwitchRecord;\n\n  var streams = this.manifest_.periods[periodIndex].streamSets\n      .map(function(streamSet) { return streamSet.streams; })\n      .reduce(Functional.collapseArrays, []);\n\n  // Serialize Period set up.\n  this.setupPeriodPromise_ = this.setupPeriodPromise_.then(function() {\n    if (this.destroyed_) return;\n    return this.setupStreams_(streams);\n  }.bind(this)).then(function() {\n    if (this.destroyed_) return;\n    this.canSwitchPeriod_[periodIndex].promise.resolve();\n    this.canSwitchPeriod_[periodIndex].resolved = true;\n    shaka.log.v1('(all) setup Period ' + periodIndex);\n  }.bind(this)).catch(function(error) {\n    if (this.destroyed_) return;\n    this.canSwitchPeriod_[periodIndex].promise.reject();\n    delete this.canSwitchPeriod_[periodIndex];\n    shaka.log.warning('(all) failed to setup Period ' + periodIndex);\n    this.onError_(error);\n    // Don't stop other Periods from being set up.\n  }.bind(this));\n\n  return canSwitchRecord.promise;\n};\n\n\n/**\n * Sets up the given Streams if necessary. Does NOT call onError_() if an\n * error occurs.\n *\n * @param {!Array.<!shakaExtern.Stream>} streams\n * @return {!Promise}\n * @private\n */\nshaka.media.StreamingEngine.prototype.setupStreams_ = function(streams) {\n  // Parallelize Stream set up.\n  var async = [];\n\n  for (var i = 0; i < streams.length; ++i) {\n    var stream = streams[i];\n    var canSwitchRecord = this.canSwitchStream_[stream.id];\n\n    if (canSwitchRecord) {\n      shaka.log.debug(\n          '(all) Stream ' + stream.id + ' is being or has been set up');\n      async.push(canSwitchRecord.promise);\n    } else {\n      shaka.log.v1('(all) setting up Stream ' + stream.id);\n      this.canSwitchStream_[stream.id] = {\n        promise: new shaka.util.PublicPromise(),\n        resolved: false\n      };\n      async.push(stream.createSegmentIndex());\n    }\n  }\n\n  return Promise.all(async).then(function() {\n    if (this.destroyed_) return;\n    for (var i = 0; i < streams.length; ++i) {\n      var stream = streams[i];\n      var canSwitchRecord = this.canSwitchStream_[stream.id];\n      if (!canSwitchRecord.resolved) {\n        canSwitchRecord.promise.resolve();\n        canSwitchRecord.resolved = true;\n        shaka.log.v1('(all) setup Stream ' + stream.id);\n      }\n    }\n  }.bind(this)).catch(function(error) {\n    if (this.destroyed_) return;\n    this.canSwitchStream_[stream.id].promise.reject();\n    delete this.canSwitchStream_[stream.id];\n    return Promise.reject(error);\n  }.bind(this));\n};\n\n\n/**\n * Sets the MediaSource's duration.\n * @private\n */\nshaka.media.StreamingEngine.prototype.setDuration_ = function() {\n  var duration = this.manifest_.presentationTimeline.getDuration();\n  if (duration < Infinity) {\n    this.mediaSourceEngine_.setDuration(duration);\n  } else {\n    // Not all platforms support infinite durations, so set a finite duration\n    // so we can append segments and so the user agent can seek.\n    this.mediaSourceEngine_.setDuration(Math.pow(2, 32));\n  }\n};\n\n\n/**\n * Called when |mediaState|'s update timer has expired.\n *\n * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n * @private\n */\nshaka.media.StreamingEngine.prototype.onUpdate_ = function(mediaState) {\n  var MapUtils = shaka.util.MapUtils;\n  if (this.destroyed_) return;\n\n  var logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n  // Sanity check.\n  goog.asserts.assert(\n      !mediaState.performingUpdate && (mediaState.updateTimer != null),\n      logPrefix + ' unexpected call to onUpdate_()');\n  if (mediaState.performingUpdate || (mediaState.updateTimer == null)) return;\n\n  goog.asserts.assert(\n      !mediaState.clearingBuffer,\n      logPrefix + ' onUpdate_() should not be called when clearing the buffer');\n  if (mediaState.clearingBuffer) return;\n\n  mediaState.updateTimer = null;\n\n  // Handle pending buffer clears.\n  if (mediaState.waitingToClearBuffer) {\n    // Note: clearBuffer_() will schedule the next update.\n    shaka.log.debug(logPrefix, 'skipping update and clearing the buffer');\n    this.clearBuffer_(mediaState, mediaState.waitingToFlushBuffer);\n    return;\n  }\n\n  // Update the MediaState.\n  try {\n    var delay = this.update_(mediaState);\n    if (delay != null) {\n      this.scheduleUpdate_(mediaState, delay);\n      mediaState.hasError = false;\n    }\n  } catch (error) {\n    this.onError_(error);\n    return;\n  }\n\n  goog.asserts.assert(this.mediaStates_, 'must not be destroyed');\n\n  var mediaStates = MapUtils.values(this.mediaStates_);\n\n  // Check if we've buffered to the end of the Period.\n  this.handlePeriodTransition_(mediaState);\n\n  // Check if we've buffered to the end of the presentation.\n  if (mediaStates.every(function(ms) { return ms.endOfStream; })) {\n    shaka.log.v1(logPrefix, 'calling endOfStream()...');\n    this.mediaSourceEngine_.endOfStream();\n  }\n};\n\n\n/**\n * Updates the given MediaState.\n *\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n * @return {?number} The number of seconds to wait until updating again or\n *   null if another update does not need to be scheduled.\n * @throws {!shaka.util.Error} if an error occurs.\n * @private\n */\nshaka.media.StreamingEngine.prototype.update_ = function(mediaState) {\n  var logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n  // Compute how far we've buffered ahead of the playhead.\n  var playheadTime = this.playhead_.getTime();\n\n  // Get the next timestamp we need.\n  // TODO: see if we can refactor this logic to be less cumbersome\n  var bufferEnd = this.mediaSourceEngine_.bufferEnd(mediaState.type);\n  var timeNeeded = this.getTimeNeeded_(mediaState, playheadTime);\n  shaka.log.v2(logPrefix, 'timeNeeded=' + timeNeeded);\n  mediaState.resumeAt = 0;\n\n  var currentPeriodIndex = this.findPeriodContainingStream_(mediaState.stream);\n  var needPeriodIndex = this.findPeriodContainingTime_(timeNeeded);\n\n  // Get the amount of content we have buffered, accounting for drift.  This\n  // is only used to determine if we have meet the buffering goal.  This should\n  // be the same way that Playhead uses.\n  var bufferedAhead = this.mediaSourceEngine_.bufferedAheadOf(\n      mediaState.type, playheadTime, 0.1);\n\n  shaka.log.v2(logPrefix,\n               'update_:',\n               'playheadTime=' + playheadTime,\n               'bufferedAhead=' + bufferedAhead);\n\n  var bufferingGoal = this.getBufferingGoal_();\n\n  // Check if we've buffered to the end of the presentation.\n  if (timeNeeded >= this.manifest_.presentationTimeline.getDuration()) {\n    // We shouldn't rebuffer if the playhead is close to the end of the\n    // presentation.\n    shaka.log.debug(logPrefix, 'buffered to end of presentation');\n    mediaState.endOfStream = true;\n    return null;\n  }\n  mediaState.endOfStream = false;\n\n  // Check if we've buffered to the end of the Period. This should be done\n  // before checking segment availability because the new Period may become\n  // available once it's switched to. Note that we don't use the non-existence\n  // of SegmentReferences as an indicator to determine Period boundaries\n  // because SegmentIndexes can provide SegmentReferences outside its Period.\n  mediaState.needPeriodIndex = needPeriodIndex;\n  if (needPeriodIndex != currentPeriodIndex) {\n    shaka.log.debug(logPrefix,\n                    'need Period ' + needPeriodIndex,\n                    'playheadTime=' + playheadTime,\n                    'timeNeeded=' + timeNeeded,\n                    'currentPeriodIndex=' + currentPeriodIndex);\n    return null;\n  }\n\n  // If we've buffered to the buffering goal then schedule an update.\n  if (bufferedAhead >= bufferingGoal) {\n    shaka.log.v2(logPrefix, 'buffering goal met');\n\n    // Do not try to predict the next update.  Just poll twice every second.\n    // The playback rate can change at any time, so any prediction we make now\n    // could be terribly invalid soon.\n    return 0.5;\n  }\n\n  var reference = this.getSegmentReferenceNeeded_(\n      mediaState, playheadTime, bufferEnd, currentPeriodIndex);\n  if (!reference) {\n    // The segment could not be found, does not exist, or is not available.  In\n    // any case just try again... if the manifest is incomplete or is not being\n    // updated then we'll idle forever; otherwise, we'll end up getting a\n    // SegmentReference eventually.\n    return 1;\n  }\n\n  this.fetchAndAppend_(mediaState, playheadTime, currentPeriodIndex, reference);\n  return null;\n};\n\n\n/**\n * Computes buffering goal.\n *\n * @return {number}\n * @private\n */\nshaka.media.StreamingEngine.prototype.getBufferingGoal_ = function() {\n  goog.asserts.assert(this.manifest_, 'manifest_ should not be null');\n  goog.asserts.assert(this.config_, 'config_ should not be null');\n\n  var rebufferingGoal = shaka.media.StreamingEngine.getRebufferingGoal(\n      this.manifest_, this.config_, this.bufferingGoalScale_);\n\n  return Math.max(\n      rebufferingGoal,\n      this.bufferingGoalScale_ * this.config_.bufferingGoal);\n};\n\n\n/**\n * Gets the next timestamp needed. Returns the playhead's position if the\n * buffer is empty; otherwise, returns the time at which the last segment\n * appended ends.\n *\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n * @param {number} playheadTime\n * @return {number} The next timestamp needed.\n * @throws {!shaka.util.Error} if the buffer is inconsistent with our\n *   expectations.\n * @private\n */\nshaka.media.StreamingEngine.prototype.getTimeNeeded_ = function(\n    mediaState, playheadTime) {\n  // Get the next timestamp we need. We must use |lastSegmentReference|\n  // to determine this and not the actual buffer for two reasons:\n  //   1. actual segments end slightly before their advertised end times, so\n  //      the next timestamp we need is actually larger than |bufferEnd|; and\n  //   2. there may be drift (the timestamps in the segments are ahead/behind\n  //      of the timestamps in the manifest), but we need drift free times when\n  //      comparing times against presentation and Period boundaries.\n  if (!mediaState.lastStream || !mediaState.lastSegmentReference) {\n    return Math.max(playheadTime, mediaState.resumeAt);\n  }\n\n  var lastPeriodIndex =\n      this.findPeriodContainingStream_(mediaState.lastStream);\n  var lastPeriod = this.manifest_.periods[lastPeriodIndex];\n  return lastPeriod.startTime + mediaState.lastSegmentReference.endTime;\n};\n\n\n/**\n * Gets the SegmentReference of the next segment needed.\n *\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n * @param {number} playheadTime\n * @param {?number} bufferEnd\n * @param {number} currentPeriodIndex\n * @return {shaka.media.SegmentReference} The SegmentReference of the\n *   next segment needed, or null if a segment could not be found, does not\n *   exist, or is not available.\n * @private\n */\nshaka.media.StreamingEngine.prototype.getSegmentReferenceNeeded_ = function(\n    mediaState, playheadTime, bufferEnd, currentPeriodIndex) {\n  var logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n  if (mediaState.lastSegmentReference &&\n      mediaState.stream == mediaState.lastStream) {\n    // Something is buffered from the same Stream.\n    var position = mediaState.lastSegmentReference.position + 1;\n    shaka.log.v2(logPrefix, 'next position known:', 'position=' + position);\n\n    return this.getSegmentReferenceIfAvailable_(\n        mediaState, currentPeriodIndex, position);\n  }\n\n  var position;\n\n  if (mediaState.lastSegmentReference) {\n    // Something is buffered from another Stream.\n    goog.asserts.assert(mediaState.lastStream, 'lastStream should not be null');\n    shaka.log.v1(logPrefix, 'next position unknown: another Stream buffered');\n    var lastPeriodIndex =\n        this.findPeriodContainingStream_(mediaState.lastStream);\n    var lastPeriod = this.manifest_.periods[lastPeriodIndex];\n    position = this.lookupSegmentPosition_(\n        mediaState,\n        lastPeriod.startTime + mediaState.lastSegmentReference.endTime,\n        currentPeriodIndex);\n  } else {\n    // Either nothing is buffered, or we have cleared part of the buffer.  If\n    // we still have some buffered, use that time to find the segment, otherwise\n    // start at the playhead time.\n    goog.asserts.assert(!mediaState.lastStream, 'lastStream should be null');\n    shaka.log.v1(logPrefix, 'next position unknown: nothing buffered');\n    position = this.lookupSegmentPosition_(\n        mediaState, bufferEnd || playheadTime, currentPeriodIndex);\n  }\n\n  if (position == null)\n    return null;\n\n  var reference = null;\n  if (bufferEnd == null) {\n    // If there's positive drift then we need to get the previous segment;\n    // however, we don't actually know how much drift there is, so we must\n    // unconditionally get the previous segment. If it turns out that there's\n    // non-positive drift then we'll just end up buffering beind the playhead a\n    // little more than we needed.\n    var optimalPosition = Math.max(0, position - 1);\n    reference = this.getSegmentReferenceIfAvailable_(\n        mediaState, currentPeriodIndex, optimalPosition);\n  }\n  return reference ||\n      this.getSegmentReferenceIfAvailable_(\n          mediaState, currentPeriodIndex, position);\n};\n\n\n/**\n * Looks up the position of the segment containing the given timestamp.\n *\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n * @param {number} presentationTime The timestamp needed, relative to the\n *   start of the presentation.\n * @param {number} currentPeriodIndex\n * @return {?number} A segment position, or null if a segment was not be found.\n * @private\n */\nshaka.media.StreamingEngine.prototype.lookupSegmentPosition_ = function(\n    mediaState, presentationTime, currentPeriodIndex) {\n  var logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n  var currentPeriod = this.manifest_.periods[currentPeriodIndex];\n\n  shaka.log.debug(logPrefix,\n                  'looking up segment:',\n                  'presentationTime=' + presentationTime,\n                  'currentPeriod.startTime=' + currentPeriod.startTime);\n\n  var lookupTime = Math.max(0, presentationTime - currentPeriod.startTime);\n  var position = mediaState.stream.findSegmentPosition(lookupTime);\n\n  if (position == null) {\n    shaka.log.warning(logPrefix,\n                      'cannot find segment:',\n                      'currentPeriod.startTime=' + currentPeriod.startTime,\n                      'lookupTime=' + lookupTime);\n  }\n\n  return position;\n};\n\n\n/**\n * Gets the SegmentReference at the given position if it's available.\n *\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n * @param {number} currentPeriodIndex\n * @param {number} position\n * @return {shaka.media.SegmentReference}\n *\n * @private\n */\nshaka.media.StreamingEngine.prototype.getSegmentReferenceIfAvailable_ =\n    function(mediaState, currentPeriodIndex, position) {\n  var logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n  var currentPeriod = this.manifest_.periods[currentPeriodIndex];\n\n  var reference = mediaState.stream.getSegmentReference(position);\n  if (!reference) {\n    shaka.log.v1(logPrefix,\n                 'segment does not exist:',\n                 'currentPeriod.startTime=' + currentPeriod.startTime,\n                 'position=' + position);\n    return null;\n  }\n\n  var timeline = this.manifest_.presentationTimeline;\n  var availabilityStart = timeline.getSegmentAvailabilityStart();\n  var availabilityEnd = timeline.getSegmentAvailabilityEnd();\n\n  if ((currentPeriod.startTime + reference.endTime < availabilityStart) ||\n      (currentPeriod.startTime + reference.startTime > availabilityEnd)) {\n    shaka.log.v2(logPrefix,\n                 'segment is not available:',\n                 'currentPeriod.startTime=' + currentPeriod.startTime,\n                 'reference.startTime=' + reference.startTime,\n                 'reference.endTime=' + reference.endTime,\n                 'availabilityStart=' + availabilityStart,\n                 'availabilityEnd=' + availabilityEnd);\n    return null;\n  }\n\n  return reference;\n};\n\n\n/**\n * Fetches and appends the given segment; sets up the given MediaState's\n * associated SourceBuffer and evicts segments if either are required\n * beforehand. Schedules another update after completing successfully.\n *\n * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n * @param {number} playheadTime\n * @param {number} currentPeriodIndex The index of the current Period.\n * @param {!shaka.media.SegmentReference} reference\n * @private\n */\nshaka.media.StreamingEngine.prototype.fetchAndAppend_ = function(\n    mediaState, playheadTime, currentPeriodIndex, reference) {\n  var logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n  var currentPeriod = this.manifest_.periods[currentPeriodIndex];\n\n  shaka.log.v1(logPrefix,\n               'fetchAndAppend_:',\n               'playheadTime=' + playheadTime,\n               'currentPeriod.startTime=' + currentPeriod.startTime,\n               'reference.position=' + reference.position,\n               'reference.startTime=' + reference.startTime,\n               'reference.endTime=' + reference.endTime);\n\n  // Subtlety: The playhead may move while asynchronous update operations are\n  // in progress, so we should avoid calling playhead_.getTime() in any\n  // callbacks. Furthermore, switch() may be called at any time, so we should\n  // also avoid using mediaState.stream or mediaState.needInitSegment in any\n  // callbacks too.\n  var stream = mediaState.stream;\n\n  // Compute the append window end.\n  var followingPeriod = this.manifest_.periods[currentPeriodIndex + 1];\n  var appendWindowEnd = null;\n  if (followingPeriod) {\n    appendWindowEnd = followingPeriod.startTime;\n  } else {\n    appendWindowEnd = this.manifest_.presentationTimeline.getDuration();\n  }\n  goog.asserts.assert(\n      (appendWindowEnd == null) || (reference.startTime <= appendWindowEnd),\n      logPrefix + ' segment should start before append window end');\n\n  var initSourceBuffer =\n      this.initSourceBuffer_(mediaState, currentPeriodIndex, appendWindowEnd);\n\n  mediaState.performingUpdate = true;\n\n  // We may set |needInitSegment| to true in switch(), so set it to false here,\n  // since we want it to remain true if switch() is called.\n  mediaState.needInitSegment = false;\n\n  shaka.log.v2(logPrefix, 'fetching segment');\n  var fetchSegment = this.fetch_(reference);\n\n  Promise.all([initSourceBuffer, fetchSegment]).then(function(results) {\n    if (this.destroyed_ || this.fatalError_) return;\n    return this.append_(mediaState,\n                        playheadTime,\n                        currentPeriod,\n                        stream,\n                        reference,\n                        results[1]);\n  }.bind(this)).then(function() {\n    if (this.destroyed_ || this.fatalError_) return;\n\n    mediaState.performingUpdate = false;\n    mediaState.recovering = false;\n\n    // Update right away.\n    this.scheduleUpdate_(mediaState, 0);\n\n    // Subtlety: handleStartup_() calls onStartupComplete_() which may call\n    // switch() or seeked(), so we must schedule an update beforehand so\n    // |updateTimer| is set.\n    this.handleStartup_(mediaState, stream);\n\n    shaka.log.v1(logPrefix, 'finished fetch and append');\n  }.bind(this)).catch(function(error) {\n    if (this.destroyed_ || this.fatalError_) return;\n\n    mediaState.performingUpdate = false;\n\n    if (error.code == shaka.util.Error.Code.BAD_HTTP_STATUS ||\n        error.code == shaka.util.Error.Code.HTTP_ERROR ||\n        error.code == shaka.util.Error.Code.TIMEOUT) {\n      this.handleNetworkError_(mediaState, error);\n    } else if (error.code == shaka.util.Error.Code.QUOTA_EXCEEDED_ERROR) {\n      this.handleQuotaExceeded_(mediaState, error);\n    } else {\n      shaka.log.error(logPrefix, 'failed fetch and append: code=' + error.code);\n      if (mediaState.type == 'text' && this.config_.ignoreTextStreamFailures) {\n        shaka.log.warning(logPrefix,\n            'Text stream failed to parse. Proceeding without it.');\n        delete this.mediaStates_['text'];\n      } else {\n        mediaState.hasError = true;\n        this.onError_(error);\n      }\n    }\n  }.bind(this));\n};\n\n\n/**\n * Handles a network error.\n *\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n * @param {!shaka.util.Error} error\n * @private\n */\nshaka.media.StreamingEngine.prototype.handleNetworkError_ = function(\n    mediaState, error) {\n  var logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n  if (mediaState.type == 'text' && this.config_.ignoreTextStreamFailures &&\n      error.code == shaka.util.Error.Code.BAD_HTTP_STATUS) {\n    shaka.log.warning(logPrefix,\n        'Text stream failed to download. Proceeding without it.');\n    delete this.mediaStates_['text'];\n  } else {\n    this.onError_(error);\n\n    shaka.log.warning(logPrefix, 'Network error. Retrying...');\n    this.scheduleUpdate_(mediaState, 4);\n  }\n};\n\n\n/**\n * Handles a QUOTA_EXCEEDED_ERROR.\n *\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n * @param {!shaka.util.Error} error\n * @private\n */\nshaka.media.StreamingEngine.prototype.handleQuotaExceeded_ = function(\n    mediaState, error) {\n  var logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n  // The segment cannot fit into the SourceBuffer. Ideally, MediaSource would\n  // have evicted old data to accommodate the segment; however, it may have\n  // failed to do this if the segment is very large, or if it could not find\n  // a suitable time range to remove.\n  //\n  // We can overcome the latter by trying to append the segment again;\n  // however, to avoid continuous QuotaExceededErrors we must reduce the size\n  // of the buffer going forward.\n  //\n  // If we've recently reduced the buffering goals, wait until the stream\n  // which caused the first QuotaExceededError recovers. Doing this ensures\n  // we don't reduce the buffering goals too quickly.\n\n  goog.asserts.assert(this.mediaStates_, 'must not be destroyed');\n  var mediaStates = shaka.util.MapUtils.values(this.mediaStates_);\n  var waitingForAnotherStreamToRecover = mediaStates.some(function(ms) {\n    return ms != mediaState && ms.recovering;\n  });\n\n  if (!waitingForAnotherStreamToRecover) {\n    // Reduction schedule: 80%, 60%, 40%, 20%, 16%, 12%, 8%, 4%, fail.\n    // Note: percentages are used for comparisons to avoid rounding errors.\n    var percentBefore = Math.round(100 * this.bufferingGoalScale_);\n    if (percentBefore > 20) {\n      this.bufferingGoalScale_ -= 0.2;\n    } else if (percentBefore > 4) {\n      this.bufferingGoalScale_ -= 0.04;\n    } else {\n      shaka.log.error(\n          logPrefix, 'MediaSource threw QuotaExceededError too many times');\n      mediaState.hasError = true;\n      this.fatalError_ = true;\n      this.onError_(error);\n      return;\n    }\n    var percentAfter = Math.round(100 * this.bufferingGoalScale_);\n    shaka.log.warning(\n        logPrefix,\n        'MediaSource threw QuotaExceededError:',\n        'reducing buffering goals by ' + (100 - percentAfter) + '%');\n    mediaState.recovering = true;\n  } else {\n    shaka.log.debug(\n        logPrefix,\n        'MediaSource threw QuotaExceededError:',\n        'waiting for another stream to recover...');\n  }\n\n  // QuotaExceededError gets thrown if evication didn't help to make room\n  // for a segment. We want to wait for a while (4 seconds is just an\n  // arbitrary number) before updating to give the playhead a chance to\n  // advance, so we don't immidiately throw again.\n  this.scheduleUpdate_(mediaState, 4);\n};\n\n\n/**\n * Sets the given MediaState's associated SourceBuffer's timestamp offset and\n * init segment if either are required. If an error occurs then neither the\n * timestamp offset or init segment are unset, since another call to switch()\n * will end up superseding them.\n *\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n * @param {number} currentPeriodIndex\n * @param {?number} appendWindowEnd\n * @return {!Promise}\n * @private\n */\nshaka.media.StreamingEngine.prototype.initSourceBuffer_ = function(\n    mediaState, currentPeriodIndex, appendWindowEnd) {\n  if (!mediaState.needInitSegment)\n    return Promise.resolve();\n\n  var logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n  var currentPeriod = this.manifest_.periods[currentPeriodIndex];\n\n  // If we need an init segment then the Stream switched, so we've either\n  // changed bitrates, Periods, or both. If we've changed Periods then we must\n  // set a new timestamp offset and append window end. Note that by setting\n  // these values here, we avoid having to co-ordinate ongoing updates, which\n  // we would have to do if we instead set them in switch().\n  var timestampOffset =\n      currentPeriod.startTime - mediaState.stream.presentationTimeOffset;\n  shaka.log.v1(logPrefix, 'setting timestamp offset to ' + timestampOffset);\n  var setTimestampOffset = this.mediaSourceEngine_.setTimestampOffset(\n      mediaState.type, timestampOffset);\n\n  if (appendWindowEnd != null) {\n    shaka.log.v1(logPrefix, 'setting append window end to ' + appendWindowEnd);\n    var setAppendWindowEnd = this.mediaSourceEngine_.setAppendWindowEnd(\n        mediaState.type, appendWindowEnd);\n  } else {\n    setAppendWindowEnd = Promise.resolve();\n  }\n\n  if (!mediaState.stream.initSegmentReference) {\n    // The Stream is self initializing.\n    return Promise.all([setTimestampOffset, setAppendWindowEnd]);\n  }\n\n  shaka.log.v1(logPrefix, 'fetching init segment');\n  var fetchInit = this.fetch_(mediaState.stream.initSegmentReference);\n  var appendInit = fetchInit.then(function(initSegment) {\n    if (this.destroyed_) return;\n    shaka.log.v1(logPrefix, 'appending init segment');\n\n    return this.mediaSourceEngine_.appendBuffer(\n        mediaState.type, initSegment, null /* startTime */, null /* endTime */);\n  }.bind(this)).catch(function(error) {\n    mediaState.needInitSegment = true;\n    return Promise.reject(error);\n  });\n\n  return Promise.all([setTimestampOffset, setAppendWindowEnd, appendInit]);\n};\n\n\n/**\n * Appends the given segment and evicts content if required to append.\n *\n * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n * @param {number} playheadTime\n * @param {shakaExtern.Period} period\n * @param {shakaExtern.Stream} stream\n * @param {!shaka.media.SegmentReference} reference\n * @param {!ArrayBuffer} segment\n * @return {!Promise}\n * @private\n */\nshaka.media.StreamingEngine.prototype.append_ = function(\n    mediaState, playheadTime, period, stream, reference, segment) {\n  var logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n  return this.evict_(mediaState, playheadTime).then(function() {\n    if (this.destroyed_) return;\n    shaka.log.v1(logPrefix, 'appending media segment');\n\n    return this.mediaSourceEngine_.appendBuffer(\n        mediaState.type, segment, reference.startTime + period.startTime,\n        reference.endTime + period.startTime);\n  }.bind(this)).then(function() {\n    if (this.destroyed_) return;\n    shaka.log.v2(logPrefix, 'appended media segment');\n\n    // We must use |stream| because switch() may have been called.\n    mediaState.lastStream = stream;\n    mediaState.lastSegmentReference = reference;\n\n    return Promise.resolve();\n  }.bind(this));\n};\n\n\n/**\n * Evicts media to meet the max buffer behind limit.\n *\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n * @param {number} playheadTime\n * @return {!Promise}\n * @private\n */\nshaka.media.StreamingEngine.prototype.evict_ = function(\n    mediaState, playheadTime) {\n  var logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n  shaka.log.v2(logPrefix, 'checking buffer length');\n\n  var startTime = this.mediaSourceEngine_.bufferStart(mediaState.type);\n  if (startTime == null) {\n    shaka.log.v2(logPrefix,\n                 'buffer behind okay because nothing buffered:',\n                 'playheadTime=' + playheadTime,\n                 'bufferBehind=' + this.config_.bufferBehind);\n    return Promise.resolve();\n  }\n  var bufferedBehind = playheadTime - startTime;\n\n  var overflow = bufferedBehind - this.config_.bufferBehind;\n  if (overflow <= 0) {\n    shaka.log.v2(logPrefix,\n                 'buffer behind okay:',\n                 'playheadTime=' + playheadTime,\n                 'bufferedBehind=' + bufferedBehind,\n                 'bufferBehind=' + this.config_.bufferBehind,\n                 'underflow=' + (-overflow));\n    return Promise.resolve();\n  }\n\n  shaka.log.v1(logPrefix,\n               'buffer behind too large:',\n               'playheadTime=' + playheadTime,\n               'bufferedBehind=' + bufferedBehind,\n               'bufferBehind=' + this.config_.bufferBehind,\n               'overflow=' + overflow);\n\n  return this.mediaSourceEngine_.remove(\n      mediaState.type, startTime, startTime + overflow).then(function() {\n    if (this.destroyed_) return;\n    shaka.log.v1(logPrefix, 'evicted ' + overflow + ' seconds');\n  }.bind(this));\n};\n\n\n/**\n * Sets up all known Periods when startup completes; otherwise, does nothing.\n *\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState The last\n *   MediaState updated.\n * @param {shakaExtern.Stream} stream\n * @private\n */\nshaka.media.StreamingEngine.prototype.handleStartup_ = function(\n    mediaState, stream) {\n  var Functional = shaka.util.Functional;\n  var MapUtils = shaka.util.MapUtils;\n  if (this.startupComplete_)\n    return;\n\n  var logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n  goog.asserts.assert(this.mediaStates_, 'must not be destroyed');\n  var mediaStates = MapUtils.values(this.mediaStates_);\n  this.startupComplete_ = mediaStates.every(function(ms) {\n    // Startup completes once we have buffered at least one segment from each\n    // MediaState, not counting text.\n    if (ms.type == 'text') return true;\n    return !ms.waitingToClearBuffer &&\n           !ms.clearingBuffer &&\n           ms.lastSegmentReference;\n  });\n\n  if (!this.startupComplete_)\n    return;\n\n  shaka.log.debug(logPrefix, 'startup complete');\n\n  // We must use |stream| because switch() may have been called.\n  var currentPeriodIndex = this.findPeriodContainingStream_(stream);\n\n  goog.asserts.assert(\n      mediaStates.every(function(ms) {\n        // It is possible for one stream (usually text) to buffer the whole\n        // Period and need the next one.\n        return ms.needPeriodIndex == currentPeriodIndex ||\n            ms.needPeriodIndex == currentPeriodIndex + 1;\n      }),\n      logPrefix + ' expected all MediaStates to need same Period');\n\n  // Setup the current Period if necessary, which is likely since the current\n  // Period is probably the initial one.\n  if (!this.canSwitchPeriod_[currentPeriodIndex]) {\n    this.setupPeriod_(currentPeriodIndex).then(function() {\n      shaka.log.v1(logPrefix, 'calling onCanSwitch_()...');\n      this.onCanSwitch_();\n    }.bind(this)).catch(Functional.noop);\n  }\n\n  // Now setup all known Periods.\n  for (var i = 0; i < this.manifest_.periods.length; ++i) {\n    this.setupPeriod_(i).catch(Functional.noop);\n  }\n\n  if (this.onStartupComplete_) {\n    shaka.log.v1(logPrefix, 'calling onStartupComplete_()...');\n    this.onStartupComplete_();\n  }\n};\n\n\n/**\n * Calls onChooseStreams_() when necessary.\n *\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState The last\n *   MediaState updated.\n * @private\n */\nshaka.media.StreamingEngine.prototype.handlePeriodTransition_ = function(\n    mediaState) {\n  var Functional = shaka.util.Functional;\n  var MapUtils = shaka.util.MapUtils;\n  var logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n  var currentPeriodIndex = this.findPeriodContainingStream_(mediaState.stream);\n  if (mediaState.needPeriodIndex == currentPeriodIndex)\n    return;\n\n  var needPeriodIndex = mediaState.needPeriodIndex;\n\n  goog.asserts.assert(this.mediaStates_, 'must not be destroyed');\n  var mediaStates = MapUtils.values(this.mediaStates_);\n\n  // For a Period transition to work, all media states must need the same\n  // Period.  If a stream needs a different Period than the one it currently\n  // has, it will try to transition or stop updates assuming that another stream\n  // will handle it.  This only works when all streams either need the same\n  // Period or are still performing updates.\n  goog.asserts.assert(\n      mediaStates.every(function(ms) {\n        return ms.needPeriodIndex == needPeriodIndex || ms.hasError ||\n            !shaka.media.StreamingEngine.isIdle_(ms);\n      }),\n      'All MediaStates should need the same Period be performing updates.');\n\n  // Only call onChooseStreams_() when all MediaStates need the same Period.\n  var needSamePeriod = mediaStates.every(function(ms) {\n    return ms.needPeriodIndex == needPeriodIndex;\n  });\n  if (!needSamePeriod) {\n    shaka.log.debug(\n        logPrefix, 'not all MediaStates need Period ' + needPeriodIndex);\n    return;\n  }\n\n  // Only call onChooseStreams_() once per Period transition.\n  var allAreIdle = mediaStates.every(shaka.media.StreamingEngine.isIdle_);\n  if (!allAreIdle) {\n    shaka.log.debug(\n        logPrefix,\n        'all MediaStates need Period ' + needPeriodIndex + ', ' +\n        'but not all MediaStates are idle');\n    return;\n  }\n\n  shaka.log.debug(logPrefix, 'all need Period ' + needPeriodIndex);\n\n  // Ensure the Period which we need to buffer is setup and then call\n  // onChooseStreams_().\n  this.setupPeriod_(needPeriodIndex).then(function() {\n    if (this.destroyed_) return;\n\n    // If we seek during a Period transition, we can start another transition.\n    // So we need to verify that:\n    // - We are still in need of the same Period.\n    // - All streams are still idle.\n    // - The current stream is not in the needed Period (another transition\n    //   handled it).\n    var allReady = mediaStates.every(function(ms) {\n      var isIdle = shaka.media.StreamingEngine.isIdle_(ms);\n      var currentPeriodIndex = this.findPeriodContainingStream_(ms.stream);\n      return isIdle && ms.needPeriodIndex == needPeriodIndex &&\n          currentPeriodIndex != needPeriodIndex;\n    }.bind(this));\n    if (!allReady) {\n      // TODO: Write unit tests for this case.\n      shaka.log.debug(logPrefix, 'ignoring transition to Period',\n                      needPeriodIndex, 'since another is happening');\n      return;\n    }\n\n    var needPeriod = this.manifest_.periods[needPeriodIndex];\n\n    shaka.log.v1(logPrefix, 'calling onChooseStreams_()...');\n    var streamsByType = this.onChooseStreams_(needPeriod);\n\n    // Vet |streamsByType| before switching.\n    for (var type in this.mediaStates_) {\n      if (streamsByType[type] || type == 'text') continue;\n\n      shaka.log.error(logPrefix,\n                      'invalid Streams chosen: missing ' + type + ' Stream');\n      this.onError_(new shaka.util.Error(\n          shaka.util.Error.Category.STREAMING,\n          shaka.util.Error.Code.INVALID_STREAMS_CHOSEN));\n      return;\n    }\n\n    for (var type in streamsByType) {\n      if (this.mediaStates_[type]) continue;\n      if (type == 'text') {\n        // initStreams_ will switch streams and schedule an update.\n        this.initStreams_(\n            {text: streamsByType['text']}, needPeriod.startTime);\n        delete streamsByType[type];\n        continue;\n      }\n\n      shaka.log.error(logPrefix,\n                      'invalid Streams chosen: unusable ' + type + ' Stream');\n      this.onError_(new shaka.util.Error(\n          shaka.util.Error.Category.STREAMING,\n          shaka.util.Error.Code.INVALID_STREAMS_CHOSEN));\n      return;\n    }\n\n    for (var type in this.mediaStates_) {\n      var stream = streamsByType[type];\n      if (stream) {\n        this.switch(type, stream, /* clearBuffer */ false);\n        this.scheduleUpdate_(this.mediaStates_[type], 0);\n      } else {\n        goog.asserts.assert(type == 'text', 'Invalid streams chosen');\n        delete this.mediaStates_[type];\n      }\n    }\n\n    // We've already set up the Period so call onCanSwitch_() right now.\n    shaka.log.v1(logPrefix, 'calling onCanSwitch_()...');\n    this.onCanSwitch_();\n  }.bind(this)).catch(Functional.noop);\n};\n\n\n/**\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n * @return {boolean} True if the given MediaState is idle; otherwise, return\n *   false.\n * @private\n */\nshaka.media.StreamingEngine.isIdle_ = function(mediaState) {\n  return !mediaState.performingUpdate &&\n         (mediaState.updateTimer == null) &&\n         !mediaState.waitingToClearBuffer &&\n         !mediaState.clearingBuffer;\n};\n\n\n/**\n * @param {number} time The time, in seconds, relative to the start of the\n *   presentation.\n * @return {number} The index of the Period which starts after |time|\n * @private\n */\nshaka.media.StreamingEngine.prototype.findPeriodContainingTime_ = function(\n    time) {\n  for (var i = this.manifest_.periods.length - 1; i > 0; --i) {\n    var period = this.manifest_.periods[i];\n    if (time >= period.startTime)\n      return i;\n  }\n  return 0;\n};\n\n\n/**\n * @param {!shakaExtern.Stream} stream\n * @return {number} The index of the Period which contains |stream|, or -1 if\n *   no Period contains |stream|.\n * @private\n */\nshaka.media.StreamingEngine.prototype.findPeriodContainingStream_ = function(\n    stream) {\n  for (var i = 0; i < this.manifest_.periods.length; ++i) {\n    var period = this.manifest_.periods[i];\n    for (var j = 0; j < period.streamSets.length; ++j) {\n      var streamSet = period.streamSets[j];\n      var index = streamSet.streams.indexOf(stream);\n      if (index >= 0)\n        return i;\n    }\n  }\n  return -1;\n};\n\n\n/**\n * Fetches the given segment.\n *\n * @param {(!shaka.media.InitSegmentReference|!shaka.media.SegmentReference)}\n *   reference\n *\n * @return {!Promise.<!ArrayBuffer>}\n * @private\n */\nshaka.media.StreamingEngine.prototype.fetch_ = function(reference) {\n  var requestType = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n  var request = shaka.net.NetworkingEngine.makeRequest(\n      reference.getUris(), this.config_.retryParameters);\n\n  // Set Range header. Note that some web servers don't accept Range headers,\n  // so don't set one if it's not strictly required.\n  if ((reference.startByte != 0) || (reference.endByte != null)) {\n    var range = 'bytes=' + reference.startByte + '-';\n    if (reference.endByte != null) range += reference.endByte;\n    request.headers['Range'] = range;\n  }\n\n  shaka.log.v2('fetching: reference=' + reference);\n  var p = this.netEngine_.request(requestType, request);\n  return p.then(function(response) {\n    return response.data;\n  });\n};\n\n\n/**\n * Clears the buffer and schedules another update.\n *\n * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n * @param {boolean} flush\n * @private\n */\nshaka.media.StreamingEngine.prototype.clearBuffer_ =\n    function(mediaState, flush) {\n  var logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n  goog.asserts.assert(\n      !mediaState.performingUpdate && (mediaState.updateTimer == null),\n      logPrefix + ' unexpected call to clearBuffer_()');\n\n  mediaState.waitingToClearBuffer = false;\n  mediaState.waitingToFlushBuffer = false;\n  mediaState.clearingBuffer = true;\n\n  shaka.log.debug(logPrefix, 'clearing buffer');\n  var p = this.mediaSourceEngine_.clear(mediaState.type);\n  p.then(function() {\n    if (!this.destroyed_ && flush) {\n      return this.mediaSourceEngine_.flush(mediaState.type);\n    }\n  }.bind(this)).then(function() {\n    if (this.destroyed_) return;\n    shaka.log.debug(logPrefix, 'cleared buffer');\n    mediaState.lastStream = null;\n    mediaState.lastSegmentReference = null;\n    mediaState.clearingBuffer = false;\n    this.scheduleUpdate_(mediaState, 0);\n  }.bind(this));\n};\n\n\n/**\n * Schedules |mediaState|'s next update.\n *\n * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n * @param {number} delay The delay in seconds.\n * @private\n */\nshaka.media.StreamingEngine.prototype.scheduleUpdate_ = function(\n    mediaState, delay) {\n  var logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n  shaka.log.v2(logPrefix, 'updating in ' + delay + ' seconds');\n  goog.asserts.assert(mediaState.updateTimer == null,\n                      logPrefix + ' did not expect update to be scheduled');\n  mediaState.updateTimer = window.setTimeout(\n      this.onUpdate_.bind(this, mediaState), delay * 1000);\n};\n\n\n/**\n * Cancels |mediaState|'s next update if one exists.\n *\n * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n * @private\n */\nshaka.media.StreamingEngine.prototype.cancelUpdate_ = function(mediaState) {\n  if (mediaState.updateTimer != null) {\n    window.clearTimeout(mediaState.updateTimer);\n    mediaState.updateTimer = null;\n  }\n};\n\n\n/**\n * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n * @return {string} A log prefix of the form ($CONTENT_TYPE:$STREAM_ID), e.g.,\n *   \"(audio:5)\" or \"(video:hd)\".\n * @private\n */\nshaka.media.StreamingEngine.logPrefix_ = function(mediaState) {\n  return '(' + mediaState.type + ':' + mediaState.stream.id + ')';\n};\n\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/media/text_engine.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.TextEngine');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.IDestroyable');\n\n\n\n/**\n * Manages text parsers and cues.\n *\n * @struct\n * @constructor\n * @param {TextTrack} track\n * @param {string} mimeType\n * @param {boolean} useRelativeCueTimestamps\n * @implements {shaka.util.IDestroyable}\n */\nshaka.media.TextEngine = function(track, mimeType, useRelativeCueTimestamps) {\n  /** @private {?shakaExtern.TextParserPlugin} */\n  this.parser_ = shaka.media.TextEngine.parserMap_[mimeType];\n\n  // This should not happen if type negotiation is working as it should.\n  goog.asserts.assert(this.parser_,\n                      'Text type negotiation should have happened already');\n\n  /** @private {TextTrack} */\n  this.track_ = track;\n\n  /** @private {number} */\n  this.timestampOffset_ = 0;\n\n  /** @private {number} */\n  this.appendWindowEnd_ = Infinity;\n\n  /** @private {?number} */\n  this.bufferStart_ = null;\n\n  /** @private {?number} */\n  this.bufferEnd_ = null;\n\n  /** @private {boolean} */\n  this.useRelativeCueTimestamps_ = useRelativeCueTimestamps;\n};\n\n\n/** @private {!Object.<string, shakaExtern.TextParserPlugin>} */\nshaka.media.TextEngine.parserMap_ = {};\n\n\n/**\n * @param {string} mimeType\n * @param {shakaExtern.TextParserPlugin} parser\n * @export\n */\nshaka.media.TextEngine.registerParser = function(mimeType, parser) {\n  shaka.media.TextEngine.parserMap_[mimeType] = parser;\n};\n\n\n/**\n * @param {string} mimeType\n * @export\n */\nshaka.media.TextEngine.unregisterParser = function(mimeType) {\n  delete shaka.media.TextEngine.parserMap_[mimeType];\n};\n\n\n/**\n * @param {string} mimeType\n * @return {boolean}\n */\nshaka.media.TextEngine.isTypeSupported = function(mimeType) {\n  return !!shaka.media.TextEngine.parserMap_[mimeType];\n};\n\n\n/**\n * Creates a cue using the best platform-specific interface available.\n *\n * @param {number} startTime\n * @param {number} endTime\n * @param {string} payload\n * @return {TextTrackCue} or null if the parameters were invalid.\n * @export\n */\nshaka.media.TextEngine.makeCue = function(startTime, endTime, payload) {\n  if (startTime >= endTime) {\n    // IE/Edge will throw in this case.\n    // See issue #501\n    shaka.log.warning('Invalid cue times: ' + startTime + ' - ' + endTime);\n    return null;\n  }\n\n  return new VTTCue(startTime, endTime, payload);\n};\n\n\n/** @override */\nshaka.media.TextEngine.prototype.destroy = function() {\n  if (this.track_) {\n    this.removeWhere_(function(cue) { return true; });\n  }\n\n  this.parser_ = null;\n  this.track_ = null;\n\n  return Promise.resolve();\n};\n\n\n/**\n * @param {ArrayBuffer} buffer\n * @param {?number} startTime\n * @param {?number} endTime\n * @return {!Promise}\n */\nshaka.media.TextEngine.prototype.appendBuffer =\n    function(buffer, startTime, endTime) {\n  var offset = this.timestampOffset_;\n\n  // Start the operation asynchronously to avoid blocking the caller.\n  return Promise.resolve().then(function() {\n    // Check that TextEngine hasn't been destroyed.\n    if (!this.track_) return;\n\n    // Parse the buffer and add the new cues.\n    var cues = this.parser_(buffer,\n                            offset,\n                            startTime,\n                            endTime,\n                            this.useRelativeCueTimestamps_);\n\n    if (startTime == null || endTime == null) {\n      // Init segments will not have start/end times passed\n      return;\n    }\n\n    for (var i = 0; i < cues.length; ++i) {\n      if (cues[i].startTime >= this.appendWindowEnd_) break;\n      this.track_.addCue(cues[i]);\n    }\n\n    // NOTE: We update the buffered range from the start and end times passed\n    // down from the segment reference, not with the start and end times of the\n    // parsed cues.  This is important because some segments may contain no\n    // cues, but we must still consider those ranges buffered.\n    if (this.bufferStart_ == null) {\n      this.bufferStart_ = startTime;\n    } else {\n      // We already had something in buffer, and we assume we are extending the\n      // range from the end.\n      goog.asserts.assert((startTime - this.bufferEnd_) <= 1,\n                          'There should not be a gap in text references >1s');\n    }\n    this.bufferEnd_ = Math.min(endTime, this.appendWindowEnd_);\n  }.bind(this));\n};\n\n\n/**\n * @param {number} start\n * @param {number} end\n * @return {!Promise}\n */\nshaka.media.TextEngine.prototype.remove = function(start, end) {\n  // Start the operation asynchronously to avoid blocking the caller.\n  return Promise.resolve().then(function() {\n    // Check that TextEngine hasn't been destroyed.\n    if (!this.track_) return;\n\n    this.removeWhere_(function(cue) {\n      if (cue.startTime >= end || cue.endTime <= start) {\n        // Outside the remove range.  Hang on to it.\n        return false;\n      }\n      return true;\n    });\n\n    if (this.bufferStart_ == null) {\n      goog.asserts.assert(this.bufferEnd_ == null,\n                          'end must be null if start is null');\n    } else {\n      goog.asserts.assert(this.bufferEnd_ != null,\n                          'end must be non-null if start is non-null');\n\n      // Update buffered range.\n      if (end <= this.bufferStart_ || start >= this.bufferEnd_) {\n        // No intersection.  Nothing was removed.\n      } else if (start <= this.bufferStart_ && end >= this.bufferEnd_) {\n        // We wiped out everything.\n        goog.asserts.assert(\n            this.track_.cues.length == 0, 'should be no cues left');\n        this.bufferStart_ = this.bufferEnd_ = null;\n      } else if (start <= this.bufferStart_ && end < this.bufferEnd_) {\n        // We removed from the beginning of the range.\n        this.bufferStart_ = end;\n      } else if (start > this.bufferStart_ && end >= this.bufferEnd_) {\n        // We removed from the end of the range.\n        this.bufferEnd_ = start;\n      } else {\n        // We removed from the middle?  StreamingEngine isn't supposed to.\n        goog.asserts.assert(\n            false, 'removal from the middle is not supported by TextEngine');\n      }\n    }\n  }.bind(this));\n};\n\n\n/** @param {number} timestampOffset */\nshaka.media.TextEngine.prototype.setTimestampOffset =\n    function(timestampOffset) {\n  this.timestampOffset_ = timestampOffset;\n};\n\n\n/** @param {number} windowEnd */\nshaka.media.TextEngine.prototype.setAppendWindowEnd =\n    function(windowEnd) {\n  this.appendWindowEnd_ = windowEnd;\n};\n\n\n/**\n * @return {?number} Time in seconds of the beginning of the buffered range,\n *   or null if nothing is buffered.\n */\nshaka.media.TextEngine.prototype.bufferStart = function() {\n  return this.bufferStart_;\n};\n\n\n/**\n * @return {?number} Time in seconds of the end of the buffered range,\n *   or null if nothing is buffered.\n */\nshaka.media.TextEngine.prototype.bufferEnd = function() {\n  return this.bufferEnd_;\n};\n\n\n/**\n * @param {number} t A timestamp\n * @return {number} Number of seconds ahead of 't' we have buffered\n */\nshaka.media.TextEngine.prototype.bufferedAheadOf = function(t) {\n  if (this.bufferEnd_ == null || this.bufferEnd_ < t) return 0;\n\n  goog.asserts.assert(\n      this.bufferStart_ != null, 'start should not be null if end is not null');\n\n  if (t < this.bufferStart_) return 0;\n\n  return this.bufferEnd_ - t;\n};\n\n\n/**\n * Remove all cues for which the matching function returns true.\n *\n * @param {function(!TextTrackCue):boolean} predicate\n * @private\n */\nshaka.media.TextEngine.prototype.removeWhere_ = function(predicate) {\n  var cues = this.track_.cues;\n  var removeMe = [];\n\n  // Remove these in another loop to avoid mutating the TextTrackCueList\n  // while iterating over it.  This allows us to avoid making assumptions\n  // about whether or not this.track_.remove() will alter that list.\n  for (var i = 0; i < cues.length; ++i) {\n    if (predicate(cues[i])) {\n      removeMe.push(cues[i]);\n    }\n  }\n\n  for (var i = 0; i < removeMe.length; ++i) {\n    this.track_.removeCue(removeMe[i]);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/media/time_ranges_utils.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.TimeRangesUtils');\n\n\n/**\n * @namespace shaka.media.TimeRangesUtils\n * @summary A set of utility functions for dealing with TimeRanges objects.\n */\n\n\n/**\n * Gets the first timestamp in buffer.\n *\n * @param {TimeRanges} b\n * @return {?number} The first buffered timestamp, in seconds, if |buffered|\n *   is non-empty; otherwise, return null.\n */\nshaka.media.TimeRangesUtils.bufferStart = function(b) {\n  if (!b) return null;\n  // Workaround Safari bug: https://goo.gl/EDRCoZ\n  if (b.length == 1 && b.end(0) - b.start(0) < 1e-6) return null;\n  // Workaround Edge bug: https://goo.gl/BtxKgb\n  if (b.length == 1 && b.start(0) < 0) return 0;\n  return b.length ? b.start(0) : null;\n};\n\n\n/**\n * Gets the last timestamp in buffer.\n *\n * @param {TimeRanges} b\n * @return {?number} The last buffered timestamp, in seconds, if |buffered|\n *   is non-empty; otherwise, return null.\n */\nshaka.media.TimeRangesUtils.bufferEnd = function(b) {\n  if (!b) return null;\n  // Workaround Safari bug: https://goo.gl/EDRCoZ\n  if (b.length == 1 && b.end(0) - b.start(0) < 1e-6) return null;\n  return b.length ? b.end(b.length - 1) : null;\n};\n\n\n/**\n * Computes how far ahead of the given timestamp is buffered.\n *\n * @param {TimeRanges} b\n * @param {number} time\n * @return {number} The number of seconds buffered, in seconds, ahead of the\n *   given time.\n */\nshaka.media.TimeRangesUtils.bufferedAheadOf = function(b, time) {\n  var result = 0;\n  if (!b) return result;\n  // Workaround Safari bug: https://goo.gl/EDRCoZ\n  if (b.length == 1 && b.end(0) - b.start(0) < 1e-6) return result;\n\n  var gapTolerance = shaka.media.TimeRangesUtils.GAP_TOLERANCE;\n  var isInRange = false;\n\n  // NOTE: On IE11, buffered ranges may show appended data before the associated\n  // append operation is complete.\n  var fudge = 0.0001;  // 0.1ms\n  // NOTE: The 0.1ms fudge is needed on Safari, where removal up to X may leave\n  // a range which starts at X + 1us + some small epsilon.\n\n  if (time == 0) {\n    // Browsers seem willing to tolerate larger gaps at the start of the media.\n    // If we're asking what's buffered from 0, tolerate a large gap and expect\n    // browsers to do the same.  This way, we will not artificially block media\n    // that the browser could otherwise play.\n    fudge = 0.25;  // 250ms\n  }\n\n  for (var i = 0; i < b.length; ++i) {\n    if (time + fudge >= b.start(i) && time < b.end(i)) {\n      result += b.end(i) - time;\n      isInRange = true;\n    } else if (isInRange &&\n               (b.start(i) - b.end(i - 1)) <= gapTolerance) {\n      // Jump small gaps in media and treat two intervals with a small gap as\n      // one consecutive interval.\n      result += b.end(i) - b.start(i);\n      result += b.start(i) - b.end(i - 1);\n    } else if (i > 0 && time + fudge < b.start(i) &&\n               time + fudge >= b.end(i - 1)) {\n      // We're seeking to a point inside the gap.\n      if (b.start(i) - time <= gapTolerance) {\n        // If the gap is small enough, jump it\n        result += b.end(i) - time;\n        isInRange = true;\n      } else {\n        return result;\n      }\n    } else {\n      isInRange = false;\n    }\n  }\n  return result;\n};\n\n\n/**\n * Computes the amount buffered ahead, allowing a gap of the given size at the\n * beginning.\n *\n * @param {TimeRanges} b\n * @param {number} time\n * @param {number} tolerance The size of the allowed gap, in seconds.\n * @return {number} The amount of content buffered, in seconds.\n */\nshaka.media.TimeRangesUtils.bufferedAheadOfThreshold = function(\n    b, time, tolerance) {\n  var TimeRangesUtils = shaka.media.TimeRangesUtils;\n\n  var bufferedAhead = TimeRangesUtils.bufferedAheadOf(b, time);\n  if (!bufferedAhead) {\n    bufferedAhead = TimeRangesUtils.bufferedAheadOf(b, time + tolerance);\n    if (bufferedAhead) bufferedAhead += tolerance;\n  }\n\n  return bufferedAhead;\n};\n\n\n/** @const {number} */\nshaka.media.TimeRangesUtils.GAP_TOLERANCE = 0.04; // 40 ms\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/media/ttml_text_parser.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.TtmlTextParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.media.TextEngine');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\n\n\n/**\n * @namespace\n * @summary A TextEngine plugin that parses TTML files.\n * @param {ArrayBuffer} data\n * @param {number} offset\n * @param {?number} segmentStartTime\n * @param {?number} segmentEndTime\n * @param {boolean} useRelativeCueTimestamps Only used by the VTT parser\n * @return {!Array.<!TextTrackCue>}\n * @throws {shaka.util.Error}\n * @export\n */\nshaka.media.TtmlTextParser =\n    function(data, offset, segmentStartTime,\n             segmentEndTime, useRelativeCueTimestamps) {\n\n  var str = shaka.util.StringUtils.fromUTF8(data);\n  var ret = [];\n  var parser = new DOMParser();\n  var xml = null;\n\n  try {\n    xml = parser.parseFromString(str, 'text/xml');\n  } catch (exception) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.INVALID_XML);\n  }\n\n  if (xml) {\n    // Try to get the framerate, subFrameRate and frameRateMultiplier\n    // if applicable\n    var frameRate = null;\n    var subFrameRate = null;\n    var frameRateMultiplier = null;\n    var tickRate = null;\n    var spaceStyle = null;\n    var tts = xml.getElementsByTagName('tt');\n    var tt = tts[0];\n    // TTML should always have tt element\n    if (!tt) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_TTML);\n    } else {\n      frameRate = tt.getAttribute('ttp:frameRate');\n      subFrameRate = tt.getAttribute('ttp:subFrameRate');\n      frameRateMultiplier = tt.getAttribute('ttp:frameRateMultiplier');\n      tickRate = tt.getAttribute('ttp:tickRate');\n      spaceStyle = tt.getAttribute('xml:space') || 'default';\n    }\n\n    if (spaceStyle != 'default' && spaceStyle != 'preserve') {\n      throw new shaka.util.Error(\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_XML);\n    }\n    var whitespaceTrim = spaceStyle == 'default';\n\n    var rateInfo = new shaka.media.TtmlTextParser.RateInfo_(\n        frameRate, subFrameRate, frameRateMultiplier, tickRate);\n\n    var styles = shaka.media.TtmlTextParser.getLeafNodes_(\n        tt.getElementsByTagName('styling')[0]);\n    var regions = shaka.media.TtmlTextParser.getLeafNodes_(\n        tt.getElementsByTagName('layout')[0]);\n    var textNodes = shaka.media.TtmlTextParser.getLeafNodes_(\n        tt.getElementsByTagName('body')[0]);\n\n    for (var i = 0; i < textNodes.length; i++) {\n      var cue = shaka.media.TtmlTextParser.parseCue_(\n          textNodes[i], offset, rateInfo, styles, regions, whitespaceTrim);\n      if (cue)\n        ret.push(cue);\n    }\n  }\n\n  return ret;\n};\n\n\n/**\n * @const\n * @private {!RegExp}\n * @example 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)\n */\nshaka.media.TtmlTextParser.timeColonFormatFrames_ =\n    /^(\\d{2,}):(\\d{2}):(\\d{2}):(\\d{2})\\.?(\\d+)?$/;\n\n\n/**\n * @const\n * @private {!RegExp}\n * @example 00:00:40 or 00:40\n */\nshaka.media.TtmlTextParser.timeColonFormat_ =\n    /^(?:(\\d{2,}):)?(\\d{2}):(\\d{2})$/;\n\n\n/**\n * @const\n * @private {!RegExp}\n * example 01:02:43.0345555 or 02:43.03\n */\nshaka.media.TtmlTextParser.timeColonFormatMilliseconds_ =\n    /^(?:(\\d{2,}):)?(\\d{2}):(\\d{2}\\.\\d{2,})$/;\n\n\n/**\n * @const\n * @private {!RegExp}\n * @example 75f or 75.5f\n */\nshaka.media.TtmlTextParser.timeFramesFormat_ = /^(\\d*\\.?\\d*)f$/;\n\n\n/**\n * @const\n * @private {!RegExp}\n * @example 50t or 50.5t\n */\nshaka.media.TtmlTextParser.timeTickFormat_ = /^(\\d*\\.?\\d*)t$/;\n\n\n/**\n * @const\n * @private {!RegExp}\n * @example 3.45h, 3m or 4.20s\n */\nshaka.media.TtmlTextParser.timeHMSFormat_ =\n    /^(?:(\\d*\\.?\\d*)h)?(?:(\\d*\\.?\\d*)m)?(?:(\\d*\\.?\\d*)s)?(?:(\\d*\\.?\\d*)ms)?$/;\n\n\n/**\n * @const\n * @private {!RegExp}\n * @example 50% 10%\n */\nshaka.media.TtmlTextParser.percentValues_ = /^(\\d{1,2}|100)% (\\d{1,2}|100)%$/;\n\n\n/**\n * @const\n * @private {!Object}\n */\nshaka.media.TtmlTextParser.textAlignToLineAlign_ = {\n  'left': 'start',\n  'center': 'center',\n  'right': 'end',\n  'start': 'start',\n  'end': 'end'\n};\n\n\n/**\n * @const\n * @private {!Object}\n */\nshaka.media.TtmlTextParser.textAlignToPositionAlign_ = {\n  'left': 'line-left',\n  'center': 'center',\n  'right': 'line-right'\n};\n\n\n/**\n * Gets leaf nodes of the xml node tree. Ignores the text, br elements\n * and the spans positioned inside paragraphs\n *\n * @param {Element} element\n * @return {!Array.<!Element>}\n * @private\n */\nshaka.media.TtmlTextParser.getLeafNodes_ = function(element) {\n  var result = [];\n  if (!element)\n    return result;\n\n  var childNodes = element.childNodes;\n  for (var i = 0; i < childNodes.length; i++) {\n    // Currently we don't support styles applicable to span\n    // elements, so they are ignored\n    var isSpanChildOfP = childNodes[i].nodeName == 'span' &&\n        element.nodeName == 'p';\n    if (childNodes[i].nodeType == Node.ELEMENT_NODE &&\n        childNodes[i].nodeName != 'br' && !isSpanChildOfP) {\n      // Get the leafs the child might contain\n      goog.asserts.assert(childNodes[i] instanceof Element,\n                          'Node should be Element!');\n      var leafChildren = shaka.media.TtmlTextParser.getLeafNodes_(\n          /** @type {Element} */(childNodes[i]));\n      goog.asserts.assert(leafChildren.length > 0,\n                          'Only a null Element should return no leaves!');\n      result = result.concat(leafChildren);\n    }\n  }\n\n  // if no result at this point, the element itself must be a leaf\n  if (!result.length) {\n    result.push(element);\n  }\n  return result;\n};\n\n\n/**\n * Insert \\n where <br> tags are found\n *\n * @param {!Node} element\n * @param {boolean} whitespaceTrim\n * @private\n */\nshaka.media.TtmlTextParser.addNewLines_ = function(element, whitespaceTrim) {\n  var childNodes = element.childNodes;\n\n  for (var i = 0; i < childNodes.length; i++) {\n    if (childNodes[i].nodeName == 'br' && i > 0) {\n      childNodes[i - 1].textContent += '\\n';\n    } else if (childNodes[i].childNodes.length > 0) {\n      shaka.media.TtmlTextParser.addNewLines_(childNodes[i], whitespaceTrim);\n    } else if (whitespaceTrim) {\n      // Trim leading and trailing whitespace.\n      var trimmed = childNodes[i].textContent.trim();\n      // Collapse multiple spaces into one.\n      trimmed = trimmed.replace(/\\s+/g, ' ');\n\n      childNodes[i].textContent = trimmed;\n    }\n  }\n};\n\n\n/**\n * Parses an Element into a TextTrackCue or VTTCue.\n *\n * @param {!Element} cueElement\n * @param {number} offset\n * @param {!shaka.media.TtmlTextParser.RateInfo_} rateInfo\n * @param {!Array.<!Element>} styles\n * @param {!Array.<!Element>} regions\n * @param {boolean} whitespaceTrim\n * @return {TextTrackCue}\n * @private\n */\nshaka.media.TtmlTextParser.parseCue_ = function(\n    cueElement, offset, rateInfo, styles, regions, whitespaceTrim) {\n\n  // Disregard empty elements:\n  // TTML allows for empty elements like <div></div>.\n  // If cueElement has neither time attributes, nor\n  // non-whitespace text, don't try to make a cue out of it.\n  if (!cueElement.hasAttribute('begin') &&\n      !cueElement.hasAttribute('end') &&\n      /^\\s*$/.test(cueElement.textContent))\n    return null;\n\n  shaka.media.TtmlTextParser.addNewLines_(cueElement, whitespaceTrim);\n\n  // Get time\n  var start = shaka.media.TtmlTextParser.parseTime_(\n      cueElement.getAttribute('begin'), rateInfo);\n  var end = shaka.media.TtmlTextParser.parseTime_(\n      cueElement.getAttribute('end'), rateInfo);\n  var duration = shaka.media.TtmlTextParser.parseTime_(\n      cueElement.getAttribute('dur'), rateInfo);\n  var payload = cueElement.textContent;\n\n  if (end == null && duration != null)\n    end = start + duration;\n\n  if (start == null || end == null) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.INVALID_TEXT_CUE);\n  }\n\n  start += offset;\n  end += offset;\n\n  var cue = shaka.media.TextEngine.makeCue(start, end, payload);\n  if (!cue)\n    return null;\n\n  // Get other properties if available\n  var region = shaka.media.TtmlTextParser.getElementFromCollection_(\n      cueElement, 'region', regions);\n  shaka.media.TtmlTextParser.addStyle_(cue, cueElement, region, styles);\n\n  return cue;\n};\n\n\n/**\n * Adds applicable style properties to a cue.\n *\n * @param {!TextTrackCue} cue\n * @param {!Element} cueElement\n * @param {Element} region\n * @param {!Array.<!Element>} styles\n * @private\n */\nshaka.media.TtmlTextParser.addStyle_ = function(\n    cue, cueElement, region, styles) {\n  var TtmlTextParser = shaka.media.TtmlTextParser;\n  var results = null;\n\n\n  var extent = TtmlTextParser.getStyleAttribute_(\n      cueElement, region, styles, 'tts:extent');\n  if (extent) {\n    results = TtmlTextParser.percentValues_.exec(extent);\n    if (results != null) {\n      // Use width value of the extent attribute for size.\n      // Height value is ignored.\n      cue.size = Number(results[1]);\n    }\n  }\n\n  var writingMode = TtmlTextParser.getStyleAttribute_(\n      cueElement, region, styles, 'tts:writingMode');\n  var isVerticalText = true;\n  if (writingMode == 'tb' || writingMode == 'tblr')\n    cue.vertical = 'lr';\n  else if (writingMode == 'tbrl')\n    cue.vertical = 'rl';\n  else\n    isVerticalText = false;\n\n  var origin = TtmlTextParser.getStyleAttribute_(\n      cueElement, region, styles, 'tts:origin');\n  if (origin) {\n    results = TtmlTextParser.percentValues_.exec(origin);\n    if (results != null) {\n      // for vertical text use first coordinate of tts:origin\n      // to represent line of the cue and second - for position.\n      // Otherwise (horizontal), use them the other way around.\n      if (isVerticalText) {\n        cue.position = Number(results[2]);\n        cue.line = Number(results[1]);\n      } else {\n        cue.position = Number(results[1]);\n        cue.line = Number(results[2]);\n      }\n      // A boolean indicating whether the line is an integer\n      // number of lines (using the line dimensions of the first\n      // line of the cue), or whether it is a percentage of the\n      // dimension of the video. The flag is set to true when lines\n      // are counted, and false otherwise.\n      cue.snapToLines = false;\n    }\n  }\n\n  var align = TtmlTextParser.getStyleAttribute_(\n      cueElement, region, styles, 'tts:textAlign');\n  if (align) {\n    cue.align = align;\n    if (align == 'center') {\n      if (cue.align != 'center') {\n        // Workaround for a Chrome bug http://crbug.com/663797\n        // Chrome does not support align = 'center'\n        cue.align = 'middle';\n      }\n      cue.position = 'auto';\n    }\n    cue.positionAlign = TtmlTextParser.textAlignToPositionAlign_[align];\n    cue.lineAlign = TtmlTextParser.textAlignToLineAlign_[align];\n  }\n};\n\n\n/**\n * Finds a specified attribute on either the original cue element or its\n * associated region and returns the value if the attribute was found.\n *\n * @param {!Element} cueElement\n * @param {Element} region\n * @param {!Array.<!Element>} styles\n * @param {string} attribute\n * @return {?string}\n * @private\n */\nshaka.media.TtmlTextParser.getStyleAttribute_ = function(\n    cueElement, region, styles, attribute) {\n\n  // An attribute can be specified on region level or in a styling block\n  // associated with the region or original element.\n  var regionChildren = shaka.media.TtmlTextParser.getLeafNodes_(region);\n  for (var i = 0; i < regionChildren.length; i++) {\n    var attr = regionChildren[i].getAttribute(attribute);\n    if (attr)\n      return attr;\n  }\n\n  var getElementFromCollection_ =\n      shaka.media.TtmlTextParser.getElementFromCollection_;\n  var style = getElementFromCollection_(region, 'style', styles) ||\n              getElementFromCollection_(cueElement, 'style', styles);\n  if (style)\n    return style.getAttribute(attribute);\n  return null;\n};\n\n\n/**\n * Selects an item from |collection| whose id matches |attributeName|\n * from |element|.\n *\n * @param {Element} element\n * @param {string} attributeName\n * @param {!Array.<Element>} collection\n * @return {Element}\n * @private\n */\nshaka.media.TtmlTextParser.getElementFromCollection_ = function(\n    element, attributeName, collection) {\n  if (!element || collection.length < 1) {\n    return null;\n  }\n  var item = null;\n  var itemName = shaka.media.TtmlTextParser.getInheritedAttribute_(\n      element, attributeName);\n  if (itemName) {\n    for (var i = 0; i < collection.length; i++) {\n      if (collection[i].getAttribute('xml:id') == itemName) {\n        item = collection[i];\n        break;\n      }\n    }\n  }\n\n  return item;\n};\n\n\n/**\n * Traverses upwards from a given node until a given attribute is found.\n *\n * @param {!Element} element\n * @param {string} attributeName\n * @return {?string}\n * @private\n */\nshaka.media.TtmlTextParser.getInheritedAttribute_ = function(\n    element, attributeName) {\n  var ret = null;\n  while (element) {\n    ret = element.getAttribute(attributeName);\n    if (ret) {\n      break;\n    }\n\n    // Element.parentNode can lead to XMLDocument, which is not an Element and\n    // has no getAttribute().\n    var parentNode = element.parentNode;\n    if (parentNode instanceof Element) {\n      element = parentNode;\n    } else {\n      break;\n    }\n  }\n  return ret;\n};\n\n\n/**\n * Parses a TTML time from the given word.\n *\n * @param {string} text\n * @param {!shaka.media.TtmlTextParser.RateInfo_} rateInfo\n * @return {?number}\n * @private\n */\nshaka.media.TtmlTextParser.parseTime_ = function(text, rateInfo) {\n  var ret = null;\n  var TtmlTextParser = shaka.media.TtmlTextParser;\n\n  if (TtmlTextParser.timeColonFormatFrames_.test(text)) {\n    ret = TtmlTextParser.parseColonTimeWithFrames_(rateInfo, text);\n  } else if (TtmlTextParser.timeColonFormat_.test(text)) {\n    ret = TtmlTextParser.parseTimeFromRegex_(\n        TtmlTextParser.timeColonFormat_, text);\n  } else if (TtmlTextParser.timeColonFormatMilliseconds_.test(text)) {\n    ret = TtmlTextParser.parseTimeFromRegex_(\n        TtmlTextParser.timeColonFormatMilliseconds_, text);\n  } else if (TtmlTextParser.timeFramesFormat_.test(text)) {\n    ret = TtmlTextParser.parseFramesTime_(rateInfo, text);\n  } else if (TtmlTextParser.timeTickFormat_.test(text)) {\n    ret = TtmlTextParser.parseTickTime_(rateInfo, text);\n  } else if (TtmlTextParser.timeHMSFormat_.test(text)) {\n    ret = TtmlTextParser.parseTimeFromRegex_(\n        TtmlTextParser.timeHMSFormat_, text);\n  }\n\n  return ret;\n};\n\n\n/**\n * Parses a TTML time in frame format\n *\n * @param {!shaka.media.TtmlTextParser.RateInfo_} rateInfo\n * @param {string} text\n * @return {?number}\n * @private\n */\nshaka.media.TtmlTextParser.parseFramesTime_ = function(rateInfo, text) {\n\n  // 75f or 75.5f\n  var results = shaka.media.TtmlTextParser.timeFramesFormat_.exec(text);\n  var frames = Number(results[1]);\n\n  return frames / rateInfo.frameRate;\n};\n\n\n/**\n * Parses a TTML time in tick format\n *\n * @param {!shaka.media.TtmlTextParser.RateInfo_} rateInfo\n * @param {string} text\n * @return {?number}\n * @private\n */\nshaka.media.TtmlTextParser.parseTickTime_ = function(rateInfo, text) {\n\n  // 50t or 50.5t\n  var results = shaka.media.TtmlTextParser.timeTickFormat_.exec(text);\n  var ticks = Number(results[1]);\n\n  return ticks / rateInfo.tickRate;\n};\n\n\n/**\n * Parses a TTML colon formatted time containing frames\n *\n * @param {!shaka.media.TtmlTextParser.RateInfo_} rateInfo\n * @param {string} text\n * @return {?number}\n * @private\n */\nshaka.media.TtmlTextParser.parseColonTimeWithFrames_ = function(\n    rateInfo, text) {\n\n  // 01:02:43:07 ('07' is frames) or 01:02:43:07.1 (subframes)\n  var results = shaka.media.TtmlTextParser.timeColonFormatFrames_.exec(text);\n\n  var hours = Number(results[1]);\n  var minutes = Number(results[2]);\n  var seconds = Number(results[3]);\n  var frames = Number(results[4]);\n  var subframes = Number(results[5]) || 0;\n\n  frames += subframes / rateInfo.subFrameRate;\n  seconds += frames / rateInfo.frameRate;\n\n  return seconds + (minutes * 60) + (hours * 3600);\n};\n\n\n/**\n * Parses a TTML time with a given regex. Expects regex to be some\n * sort of a time-matcher to match hours, minutes, seconds and milliseconds\n *\n * @param {!RegExp} regex\n * @param {string} text\n * @return {?number}\n * @private\n */\nshaka.media.TtmlTextParser.parseTimeFromRegex_ = function(regex, text) {\n  var results = regex.exec(text);\n  if (results == null || results[0] == '')\n    return null;\n  // This capture is optional, but will still be in the array as undefined,\n  // default to 0.\n  var hours = Number(results[1]) || 0;\n  var minutes = Number(results[2]) || 0;\n  var seconds = Number(results[3]) || 0;\n  var miliseconds = Number(results[4]) || 0;\n\n  return (miliseconds / 1000) + seconds + (minutes * 60) + (hours * 3600);\n};\n\n\n\n/**\n * Contains information about frame/subframe rate\n * and frame rate multiplier for time in frame format.\n * ex. 01:02:03:04(4 frames) or 01:02:03:04.1(4 frames, 1 subframe)\n *\n * @param {?string} frameRate\n * @param {?string} subFrameRate\n * @param {?string} frameRateMultiplier\n * @param {?string} tickRate\n * @constructor\n * @struct\n * @private\n */\nshaka.media.TtmlTextParser.RateInfo_ = function(\n    frameRate, subFrameRate, frameRateMultiplier, tickRate) {\n\n  /**\n   * @type {number}\n   */\n  this.frameRate = Number(frameRate) || 30;\n\n  /**\n   * @type {number}\n   */\n  this.subFrameRate = Number(subFrameRate) || 1;\n\n  /**\n   * @type {number}\n   */\n  this.tickRate = Number(tickRate);\n  if (this.tickRate == 0) {\n    if (frameRate)\n      this.tickRate = this.frameRate * this.subFrameRate;\n    else\n      this.tickRate = 1;\n  }\n\n  if (frameRateMultiplier) {\n    var multiplierResults = /^(\\d+) (\\d+)$/g.exec(frameRateMultiplier);\n    if (multiplierResults) {\n      var numerator = multiplierResults[1];\n      var denominator = multiplierResults[2];\n      var multiplierNum = numerator / denominator;\n      this.frameRate *= multiplierNum;\n    }\n  }\n};\n\n\nshaka.media.TextEngine.registerParser(\n    'application/ttml+xml', shaka.media.TtmlTextParser);\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/media/vtt_text_parser.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.VttTextParser');\n\ngoog.require('shaka.log');\ngoog.require('shaka.media.TextEngine');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.TextParser');\n\n\n/**\n * @namespace\n * @summary A TextEngine plugin that parses WebVTT files.\n * @param {ArrayBuffer} data\n * @param {number} offset\n * @param {?number} segmentStartTime\n * @param {?number} segmentEndTime\n * @param {boolean} useRelativeCueTimestamps\n * @return {!Array.<!TextTrackCue>}\n * @throws {shaka.util.Error}\n * @export\n */\nshaka.media.VttTextParser =\n    function(data, offset, segmentStartTime,\n             segmentEndTime, useRelativeCueTimestamps) {\n\n  if (segmentStartTime > 0 && !useRelativeCueTimestamps) {\n    shaka.log.warning('Period-relative text cue timestamps have been ' +\n                      'deprecated. Segment-relative timestamps will be used ' +\n                      'in V2.1.0 and on.');\n  }\n\n  // Get the input as a string.  Normalize newlines to \\n.\n  var str = shaka.util.StringUtils.fromUTF8(data);\n  str = str.replace(/\\r\\n|\\r(?=[^\\n]|$)/gm, '\\n');\n  var blocks = str.split(/\\n{2,}/m);\n\n  if (!/^WEBVTT($|[ \\t\\n])/m.test(blocks[0])) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.INVALID_TEXT_HEADER);\n  }\n\n  var ret = [];\n  for (var i = 1; i < blocks.length; i++) {\n    var lines = blocks[i].split('\\n');\n    var cue = shaka.media.VttTextParser.parseCue_(lines,\n                                                  offset,\n                                                  segmentStartTime,\n                                                  useRelativeCueTimestamps);\n    if (cue)\n      ret.push(cue);\n  }\n\n  return ret;\n};\n\n\n/**\n * Parses a text block into a Cue object.\n *\n * @param {!Array.<string>} text\n * @param {number} offset\n * @param {?number} segmentStartTime\n * @param {boolean} useRelativeCueTimestamps\n * @return {?TextTrackCue}\n * @private\n */\nshaka.media.VttTextParser.parseCue_ =\n    function(text, offset, segmentStartTime, useRelativeCueTimestamps) {\n\n  // Skip empty blocks.\n  if (text.length == 1 && !text[0])\n    return null;\n\n  // Skip comment blocks.\n  if (/^NOTE($|[ \\t])/.test(text[0]))\n    return null;\n\n  var id = null;\n  var index = text[0].indexOf('-->');\n  if (index < 0) {\n    id = text[0];\n    text.splice(0, 1);\n  }\n\n  // Parse the times.\n  var parser = new shaka.util.TextParser(text[0]);\n  var start = shaka.media.VttTextParser.parseTime_(parser);\n  var expect = parser.readRegex(/[ \\t]+-->[ \\t]+/g);\n  var end = shaka.media.VttTextParser.parseTime_(parser);\n\n  if (start == null || expect == null || end == null) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.INVALID_TEXT_CUE);\n  }\n\n  // See issue #480 for discussion on deprecation\n  if (useRelativeCueTimestamps) {\n    start += segmentStartTime;\n    end += segmentStartTime;\n  } else {\n    start += offset;\n    end += offset;\n  }\n\n  // Get the payload.\n  var payload = text.slice(1).join('\\n').trim();\n\n  var cue = shaka.media.TextEngine.makeCue(start, end, payload);\n  if (!cue)\n    return null;\n\n  // Parse optional settings.\n  parser.skipWhitespace();\n  var word = parser.readWord();\n  while (word) {\n    if (!shaka.media.VttTextParser.parseSetting(cue, word)) {\n      shaka.log.warning('VTT parser encountered an invalid VTT setting: ',\n                        word,\n                        ' The setting will be ignored.');\n    }\n    parser.skipWhitespace();\n    word = parser.readWord();\n  }\n\n  if (id != null)\n    cue.id = id;\n  return cue;\n};\n\n\n/**\n * Parses a WebVTT setting from the given word.\n *\n * @param {!TextTrackCue} cue\n * @param {string} word\n * @return {boolean} True on success.\n */\nshaka.media.VttTextParser.parseSetting = function(cue, word) {\n  // NOTE: positionAlign and lineAlign settings are not supported by Chrome\n  // at the moment, so setting them will have no effect.\n  // The bug on chromium to implement them:\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=633690\n\n  var results = null;\n  if ((results = /^align:(start|middle|center|end|left|right)$/.exec(word))) {\n    cue.align = results[1];\n    if (results[1] == 'center' && cue.align != 'center') {\n      // Workaround for a Chrome bug http://crbug.com/663797\n      // Chrome does not support align = 'center'\n      cue.position = 'auto';\n      cue.align = 'middle';\n    }\n  } else if ((results = /^vertical:(lr|rl)$/.exec(word))) {\n    cue.vertical = results[1];\n  } else if ((results = /^size:(\\d{1,2}|100)%$/.exec(word))) {\n    cue.size = Number(results[1]);\n  }\n  // There was a disagreement between a working draft and an editor draft of\n  // the WebVTT spec. According to the former, optional position alignment\n  // options are 'start', 'end' and 'center'. According to the latter -\n  // 'line-left', 'center' and 'line-right'.\n  // We are going to support both options for now.\n  else if ((results =\n      /^position:(\\d{1,2}|100)%(?:,(line-left|line-right|center|start|end))?$/\n      .exec(word))) {\n    cue.position = Number(results[1]);\n    if (results[2])\n      cue.positionAlign = results[2];\n  } else if ((results =\n      /^line:(\\d{1,2}|100)%(?:,(start|end|center))?$/.exec(word))) {\n    cue.snapToLines = false;\n    cue.line = Number(results[1]);\n    if (results[2])\n      cue.lineAlign = results[2];\n  } else if ((results = /^line:(-?\\d+)(?:,(start|end|center))?$/.exec(word))) {\n    cue.snapToLines = true;\n    cue.line = Number(results[1]);\n    if (results[2])\n      cue.lineAlign = results[2];\n  } else {\n    return false;\n  }\n\n  return true;\n};\n\n\n/**\n * Parses a WebVTT time from the given parser.\n *\n * @param {!shaka.util.TextParser} parser\n * @return {?number}\n * @private\n */\nshaka.media.VttTextParser.parseTime_ = function(parser) {\n  // 00:00.000 or 00:00:00.000 or 0:00:00.000\n  var results = parser.readRegex(/(?:(\\d{1,}):)?(\\d{2}):(\\d{2})\\.(\\d{3})/g);\n  if (results == null)\n    return null;\n  // This capture is optional, but will still be in the array as undefined,\n  // default to 0.\n  var hours = Number(results[1]) || 0;\n  var minutes = Number(results[2]);\n  var seconds = Number(results[3]);\n  var miliseconds = Number(results[4]);\n  if (minutes > 59 || seconds > 59)\n    return null;\n\n  return (miliseconds / 1000) + seconds + (minutes * 60) + (hours * 3600);\n};\n\nshaka.media.TextEngine.registerParser('text/vtt', shaka.media.VttTextParser);\nshaka.media.TextEngine.registerParser('text/vtt; codecs=\"vtt\"',\n    shaka.media.VttTextParser);\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/media/webm_segment_index_parser.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.media.WebmSegmentIndexParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.EbmlElement');\ngoog.require('shaka.util.EbmlParser');\ngoog.require('shaka.util.Error');\n\n\n\n/**\n * Creates a WebM Cues element parser.\n *\n * @constructor\n * @struct\n */\nshaka.media.WebmSegmentIndexParser = function() {};\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.EBML_ID = 0x1a45dfa3;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.SEGMENT_ID = 0x18538067;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.INFO_ID = 0x1549a966;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.TIMECODE_SCALE_ID = 0x2ad7b1;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.DURATION_ID = 0x4489;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.CUES_ID = 0x1c53bb6b;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.CUE_POINT_ID = 0xbb;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.CUE_TIME_ID = 0xb3;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.CUE_TRACK_POSITIONS_ID = 0xb7;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.CUE_CLUSTER_POSITION = 0xf1;\n\n\n/**\n * Parses SegmentReferences from a WebM container.\n * @param {!ArrayBuffer} cuesData The WebM container's \"Cueing Data\" section.\n * @param {!ArrayBuffer} initData The WebM container's headers.\n * @param {!Array.<string>} uris The possible locations of the WebM file that\n *   contains the segments.\n * @param {number} presentationTimeOffset\n\n * @return {!Array.<!shaka.media.SegmentReference>}\n * @throws {shaka.util.Error}\n * @see http://www.matroska.org/technical/specs/index.html\n * @see http://www.webmproject.org/docs/container/\n */\nshaka.media.WebmSegmentIndexParser.prototype.parse = function(\n    cuesData, initData, uris, presentationTimeOffset) {\n  var tuple = this.parseWebmContainer_(initData);\n  var parser = new shaka.util.EbmlParser(new DataView(cuesData));\n  var cuesElement = parser.parseElement();\n  if (cuesElement.id != shaka.media.WebmSegmentIndexParser.CUES_ID) {\n    shaka.log.error('Not a Cues element.');\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.WEBM_CUES_ELEMENT_MISSING);\n  }\n\n  return this.parseCues_(\n      cuesElement, tuple.segmentOffset, tuple.timecodeScale, tuple.duration,\n      uris, presentationTimeOffset);\n};\n\n\n/**\n * Parses a WebM container to get the segment's offset, timecode scale, and\n * duration.\n *\n * @param {!ArrayBuffer} initData\n * @return {{segmentOffset: number, timecodeScale: number, duration: number}}\n *   The segment's offset in bytes, the segment's timecode scale in seconds,\n *   and the duration in seconds.\n * @throws {shaka.util.Error}\n * @private\n */\nshaka.media.WebmSegmentIndexParser.prototype.parseWebmContainer_ = function(\n    initData) {\n  var parser = new shaka.util.EbmlParser(new DataView(initData));\n\n  // Check that the WebM container data starts with the EBML header, but\n  // skip its contents.\n  var ebmlElement = parser.parseElement();\n  if (ebmlElement.id != shaka.media.WebmSegmentIndexParser.EBML_ID) {\n    shaka.log.error('Not an EBML element.');\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.WEBM_EBML_HEADER_ELEMENT_MISSING);\n  }\n\n  var segmentElement = parser.parseElement();\n  if (segmentElement.id != shaka.media.WebmSegmentIndexParser.SEGMENT_ID) {\n    shaka.log.error('Not a Segment element.');\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.WEBM_SEGMENT_ELEMENT_MISSING);\n  }\n\n  // This value is used as the initial offset to the first referenced segment.\n  var segmentOffset = segmentElement.getOffset();\n\n  // Parse the Segment element to get the segment info.\n  var segmentInfo = this.parseSegment_(segmentElement);\n  return {\n    segmentOffset: segmentOffset,\n    timecodeScale: segmentInfo.timecodeScale,\n    duration: segmentInfo.duration\n  };\n};\n\n\n/**\n * Parses a WebM Info element to get the segment's timecode scale and duration.\n * @param {!shaka.util.EbmlElement} segmentElement\n * @return {{timecodeScale: number, duration: number}} The segment's timecode\n *   scale in seconds and duration in seconds.\n * @throws {shaka.util.Error}\n * @private\n */\nshaka.media.WebmSegmentIndexParser.prototype.parseSegment_ = function(\n    segmentElement) {\n  var parser = segmentElement.createParser();\n\n  // Find the Info element.\n  var infoElement = null;\n  while (parser.hasMoreData()) {\n    var elem = parser.parseElement();\n    if (elem.id != shaka.media.WebmSegmentIndexParser.INFO_ID) {\n      continue;\n    }\n\n    infoElement = elem;\n\n    break;\n  }\n\n  if (!infoElement) {\n    shaka.log.error('Not an Info element.');\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.WEBM_INFO_ELEMENT_MISSING);\n  }\n\n  return this.parseInfo_(infoElement);\n};\n\n\n/**\n * Parses a WebM Info element to get the segment's timecode scale and duration.\n * @param {!shaka.util.EbmlElement} infoElement\n * @return {{timecodeScale: number, duration: number}} The segment's timecode\n *   scale in seconds and duration in seconds.\n * @throws {shaka.util.Error}\n * @private\n */\nshaka.media.WebmSegmentIndexParser.prototype.parseInfo_ = function(\n    infoElement) {\n  var parser = infoElement.createParser();\n\n  // The timecode scale factor in units of [nanoseconds / T], where [T] are the\n  // units used to express all other time values in the WebM container. By\n  // default it's assumed that [T] == [milliseconds].\n  var timecodeScaleNanoseconds = 1000000;\n  /** @type {?number} */\n  var durationScale = null;\n\n  while (parser.hasMoreData()) {\n    var elem = parser.parseElement();\n    if (elem.id == shaka.media.WebmSegmentIndexParser.TIMECODE_SCALE_ID) {\n      timecodeScaleNanoseconds = elem.getUint();\n    } else if (elem.id == shaka.media.WebmSegmentIndexParser.DURATION_ID) {\n      durationScale = elem.getFloat();\n    }\n  }\n  if (durationScale == null) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.WEBM_DURATION_ELEMENT_MISSING);\n  }\n\n  // The timecode scale factor in units of [seconds / T].\n  var timecodeScale = timecodeScaleNanoseconds / 1000000000;\n  // The duration is stored in units of [T]\n  var durationSeconds = durationScale * timecodeScale;\n\n  return {timecodeScale: timecodeScale, duration: durationSeconds};\n};\n\n\n/**\n * Parses a WebM CuesElement.\n * @param {!shaka.util.EbmlElement} cuesElement\n * @param {number} segmentOffset\n * @param {number} timecodeScale\n * @param {number} duration\n * @param {!Array.<string>} uris\n * @param {number} presentationTimeOffset\n * @return {!Array.<!shaka.media.SegmentReference>}\n * @throws {shaka.util.Error}\n * @private\n */\nshaka.media.WebmSegmentIndexParser.prototype.parseCues_ = function(\n    cuesElement, segmentOffset, timecodeScale, duration, uris,\n    presentationTimeOffset) {\n  var references = [];\n  var getUris = function() { return uris; };\n\n  var parser = cuesElement.createParser();\n\n  var lastTime = -1;\n  var lastOffset = -1;\n\n  while (parser.hasMoreData()) {\n    var elem = parser.parseElement();\n    if (elem.id != shaka.media.WebmSegmentIndexParser.CUE_POINT_ID) {\n      continue;\n    }\n\n    var tuple = this.parseCuePoint_(elem);\n    if (!tuple) {\n      continue;\n    }\n\n    // Substract presentationTimeOffset from unscalled time\n    var currentTime = timecodeScale *\n        (tuple.unscaledTime - presentationTimeOffset);\n    var currentOffset = segmentOffset + tuple.relativeOffset;\n\n    if (lastTime >= 0) {\n      goog.asserts.assert(lastOffset >= 0, 'last offset cannot be 0');\n\n      references.push(\n          new shaka.media.SegmentReference(\n              references.length,\n              lastTime, currentTime,\n              getUris,\n              lastOffset, currentOffset - 1));\n    }\n\n    lastTime = currentTime;\n    lastOffset = currentOffset;\n  }\n\n  if (lastTime >= 0) {\n    goog.asserts.assert(lastOffset >= 0, 'last offset cannot be 0');\n\n    references.push(\n        new shaka.media.SegmentReference(\n            references.length, lastTime, duration, getUris, lastOffset, null));\n  }\n\n  return references;\n};\n\n\n/**\n * Parses a WebM CuePointElement to get an \"unadjusted\" segment reference.\n * @param {shaka.util.EbmlElement} cuePointElement\n * @return {{unscaledTime: number, relativeOffset: number}} The referenced\n *   segment's start time in units of [T] (see parseInfo_()), and the\n *   referenced segment's offset in bytes, relative to a WebM Segment\n *   element.\n * @throws {shaka.util.Error}\n * @private\n */\nshaka.media.WebmSegmentIndexParser.prototype.parseCuePoint_ = function(\n    cuePointElement) {\n  var parser = cuePointElement.createParser();\n\n  // Parse CueTime element.\n  var cueTimeElement = parser.parseElement();\n  if (cueTimeElement.id != shaka.media.WebmSegmentIndexParser.CUE_TIME_ID) {\n    shaka.log.warning('Not a CueTime element.');\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.WEBM_CUE_TIME_ELEMENT_MISSING);\n  }\n  var unscaledTime = cueTimeElement.getUint();\n\n  // Parse CueTrackPositions element.\n  var cueTrackPositionsElement = parser.parseElement();\n  if (cueTrackPositionsElement.id !=\n      shaka.media.WebmSegmentIndexParser.CUE_TRACK_POSITIONS_ID) {\n    shaka.log.warning('Not a CueTrackPositions element.');\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.WEBM_CUE_TRACK_POSITIONS_ELEMENT_MISSING);\n  }\n\n  var cueTrackParser = cueTrackPositionsElement.createParser();\n  var relativeOffset = 0;\n\n  while (cueTrackParser.hasMoreData()) {\n    var elem = cueTrackParser.parseElement();\n    if (elem.id != shaka.media.WebmSegmentIndexParser.CUE_CLUSTER_POSITION) {\n      continue;\n    }\n\n    relativeOffset = elem.getUint();\n    break;\n  }\n\n  return { unscaledTime: unscaledTime, relativeOffset: relativeOffset };\n};\n\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/net/data_uri_plugin.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.net.DataUriPlugin');\n\ngoog.require('shaka.log');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * @namespace\n * @summary A networking plugin to handle data URIs.\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/data_URIs\n * @param {string} uri\n * @param {shakaExtern.Request} request\n * @return {!Promise.<shakaExtern.Response>}\n * @export\n */\nshaka.net.DataUriPlugin = function(uri, request) {\n  return new Promise(function(resolve, reject) {\n    // Extract the scheme.\n    var parts = uri.split(':');\n    if (parts.length < 2 || parts[0] != 'data') {\n      shaka.log.error('Bad data URI, failed to parse scheme');\n      throw new shaka.util.Error(\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.MALFORMED_DATA_URI,\n          uri);\n    }\n    var path = parts.slice(1).join(':');\n\n    // Extract the encoding and MIME type (required but can be empty).\n    var infoAndData = path.split(',');\n    if (infoAndData.length < 2) {\n      shaka.log.error('Bad data URI, failed to extract encoding and MIME type');\n      throw new shaka.util.Error(\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.MALFORMED_DATA_URI,\n          uri);\n    }\n    var info = infoAndData[0];\n    var dataStr = window.decodeURIComponent(infoAndData.slice(1).join(','));\n\n    // Extract the encoding (optional).\n    var typeAndEncoding = info.split(';');\n    var encoding = null;\n    if (typeAndEncoding.length > 1)\n      encoding = typeAndEncoding[1];\n\n    // Convert the data.\n    /** @type {ArrayBuffer} */\n    var data;\n    if (encoding == 'base64') {\n      data = shaka.util.Uint8ArrayUtils.fromBase64(dataStr).buffer;\n    } else if (encoding) {\n      shaka.log.error('Bad data URI, unknown encoding');\n      throw new shaka.util.Error(\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.UNKNOWN_DATA_URI_ENCODING,\n          uri);\n    } else {\n      data = shaka.util.StringUtils.toUTF8(dataStr);\n    }\n\n    /** @type {shakaExtern.Response} */\n    var response = {\n      uri: uri,\n      data: data,\n      headers: {\n        'content-type': typeAndEncoding[0]\n      }\n    };\n\n    resolve(response);\n  });\n};\n\n\nshaka.net.NetworkingEngine.registerScheme('data', shaka.net.DataUriPlugin);\n\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/net/http_plugin.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.net.HttpPlugin');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\n\n\n/**\n * @namespace\n * @summary A networking plugin to handle http and https URIs via XHR.\n * @param {string} uri\n * @param {shakaExtern.Request} request\n * @return {!Promise.<shakaExtern.Response>}\n * @export\n */\nshaka.net.HttpPlugin = function(uri, request) {\n  return new Promise(function(resolve, reject) {\n    var xhr = new XMLHttpRequest();\n\n    xhr.open(request.method, uri, true);\n    xhr.responseType = 'arraybuffer';\n    xhr.timeout = request.retryParameters.timeout;\n    xhr.withCredentials = request.allowCrossSiteCredentials;\n\n    xhr.onload = function(event) {\n      var target = event.target;\n      goog.asserts.assert(target, 'XHR onload has no target!');\n\n      var headers = target.getAllResponseHeaders().split('\\r\\n').reduce(\n          function(all, part) {\n            var header = part.split(': ');\n            all[header[0].toLowerCase()] = header.slice(1).join(': ');\n            return all;\n          },\n          {});\n      if (target.status >= 200 && target.status <= 299 &&\n          target.status != 202) {\n        // Most 2xx HTTP codes are success cases.\n        if (target.responseURL) {\n          uri = target.responseURL;\n        }\n        /** @type {shakaExtern.Response} */\n        var response = {\n          uri: uri,\n          data: target.response,\n          headers: headers,\n          fromCache: !!headers['x-shaka-from-cache']\n        };\n        resolve(response);\n      } else {\n        var responseText = null;\n        try {\n          responseText = shaka.util.StringUtils.fromBytesAutoDetect(\n              target.response);\n        } catch (exception) {}\n        shaka.log.debug('HTTP error text:', responseText);\n        reject(new shaka.util.Error(\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.BAD_HTTP_STATUS,\n            uri,\n            target.status,\n            responseText,\n            headers));\n      }\n    };\n    xhr.onerror = function(event) {\n      reject(new shaka.util.Error(\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.HTTP_ERROR,\n          uri));\n    };\n    xhr.ontimeout = function(event) {\n      reject(new shaka.util.Error(\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.TIMEOUT,\n          uri));\n    };\n\n    for (var k in request.headers) {\n      xhr.setRequestHeader(k, request.headers[k]);\n    }\n    xhr.send(request.body);\n  });\n};\n\n\nshaka.net.NetworkingEngine.registerScheme('http', shaka.net.HttpPlugin);\nshaka.net.NetworkingEngine.registerScheme('https', shaka.net.HttpPlugin);\n\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/net/networking_engine.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.net.NetworkingEngine');\n\ngoog.require('goog.Uri');\ngoog.require('goog.asserts');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.PublicPromise');\n\n\n\n/**\n * NetworkingEngine wraps all networking operations.  This accepts plugins that\n * handle the actual request.  A plugin is registered using registerScheme.\n * Each scheme has at most one plugin to handle the request.\n *\n * @param {function(number, number, number)=} opt_onSegmentDownloaded Called\n *   when a segment is downloaded. Passed the wall-clock time, in\n *   milliseconds, when the request began (before any outbound request\n *   filters); the wall-clock time, in milliseconds, when the response ended\n *   (after all retries and inbound response filters); and the total number\n *   of bytes transferred.\n *\n * @struct\n * @constructor\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.net.NetworkingEngine = function(opt_onSegmentDownloaded) {\n  /** @private {boolean} */\n  this.destroyed_ = false;\n\n  /** @private {!Array.<!Promise>} */\n  this.requests_ = [];\n\n  /** @private {!Array.<shakaExtern.RequestFilter>} */\n  this.requestFilters_ = [];\n\n  /** @private {!Array.<shakaExtern.ResponseFilter>} */\n  this.responseFilters_ = [];\n\n  /** @private {?function(number, number, number)} */\n  this.onSegmentDownloaded_ = opt_onSegmentDownloaded || null;\n};\n\n\n/**\n * Request types.  Allows a filter to decide which requests to read/alter.\n *\n * @enum {number}\n * @export\n */\nshaka.net.NetworkingEngine.RequestType = {\n  'MANIFEST': 0,\n  'SEGMENT': 1,\n  'LICENSE': 2\n};\n\n\n/**\n * Contains the scheme plugins.\n *\n * @private {!Object.<string, ?shakaExtern.SchemePlugin>}\n */\nshaka.net.NetworkingEngine.schemes_ = {};\n\n\n/**\n * Registers a scheme plugin.  This plugin will handle all requests with the\n * given scheme.  If a plugin with the same scheme already exists, it is\n * replaced.\n *\n * @param {string} scheme\n * @param {shakaExtern.SchemePlugin} plugin\n * @export\n */\nshaka.net.NetworkingEngine.registerScheme = function(scheme, plugin) {\n  shaka.net.NetworkingEngine.schemes_[scheme] = plugin;\n};\n\n\n/**\n * Removes a scheme plugin.\n *\n * @param {string} scheme\n * @export\n */\nshaka.net.NetworkingEngine.unregisterScheme = function(scheme) {\n  delete shaka.net.NetworkingEngine.schemes_[scheme];\n};\n\n\n/**\n * Registers a new request filter.  All filters are applied in the order they\n * are registered.\n *\n * @param {shakaExtern.RequestFilter} filter\n * @export\n */\nshaka.net.NetworkingEngine.prototype.registerRequestFilter = function(filter) {\n  this.requestFilters_.push(filter);\n};\n\n\n/**\n * Removes a request filter.\n *\n * @param {shakaExtern.RequestFilter} filter\n * @export\n */\nshaka.net.NetworkingEngine.prototype.unregisterRequestFilter =\n    function(filter) {\n  var filters = this.requestFilters_;\n  var i = filters.indexOf(filter);\n  if (i >= 0) {\n    filters.splice(i, 1);\n  }\n};\n\n\n/**\n * Clear all request filters.\n *\n * @export\n */\nshaka.net.NetworkingEngine.prototype.clearAllRequestFilters = function() {\n  this.requestFilters_ = [];\n};\n\n\n/**\n * Registers a new response filter.  All filters are applied in the order they\n * are registered.\n *\n * @param {shakaExtern.ResponseFilter} filter\n * @export\n */\nshaka.net.NetworkingEngine.prototype.registerResponseFilter = function(filter) {\n  this.responseFilters_.push(filter);\n};\n\n\n/**\n * Removes a response filter.\n *\n * @param {shakaExtern.ResponseFilter} filter\n * @export\n */\nshaka.net.NetworkingEngine.prototype.unregisterResponseFilter =\n    function(filter) {\n  var filters = this.responseFilters_;\n  var i = filters.indexOf(filter);\n  if (i >= 0) {\n    filters.splice(i, 1);\n  }\n};\n\n\n/**\n * Clear all response filters.\n *\n * @export\n */\nshaka.net.NetworkingEngine.prototype.clearAllResponseFilters = function() {\n  this.responseFilters_ = [];\n};\n\n\n/**\n * Gets a copy of the default retry parameters.\n *\n * @return {shakaExtern.RetryParameters}\n */\nshaka.net.NetworkingEngine.defaultRetryParameters = function() {\n  // Use a function rather than a constant member so the calling code can\n  // modify the values without affecting other call results.\n  return {\n    maxAttempts: 2,\n    baseDelay: 1000,\n    backoffFactor: 2,\n    fuzzFactor: 0.5,\n    timeout: 0\n  };\n};\n\n\n/**\n * Makes a simple network request for the given URIs.\n *\n * @param {!Array.<string>} uris\n * @param {shakaExtern.RetryParameters} retryParams\n * @return {shakaExtern.Request}\n */\nshaka.net.NetworkingEngine.makeRequest = function(\n    uris, retryParams) {\n  return {\n    uris: uris,\n    method: 'GET',\n    body: null,\n    headers: {},\n    allowCrossSiteCredentials: false,\n    retryParameters: retryParams\n  };\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.net.NetworkingEngine.prototype.destroy = function() {\n  var Functional = shaka.util.Functional;\n  this.destroyed_ = true;\n  this.requestFilters_ = [];\n  this.responseFilters_ = [];\n\n  var cleanup = [];\n  for (var i = 0; i < this.requests_.length; ++i) {\n    cleanup.push(this.requests_[i].catch(Functional.noop));\n  }\n  return Promise.all(cleanup);\n};\n\n\n/**\n * Makes a network request and returns the resulting data.\n *\n * @param {shaka.net.NetworkingEngine.RequestType} type\n * @param {shakaExtern.Request} request\n * @return {!Promise.<shakaExtern.Response>}\n * @export\n */\nshaka.net.NetworkingEngine.prototype.request = function(type, request) {\n  if (this.destroyed_)\n    return Promise.reject();\n\n  goog.asserts.assert(request.uris && request.uris.length,\n                      'Request without URIs!');\n\n  var startTimeMs = Date.now();\n\n  // Send to the filter first, in-case they change the URI.\n  var requestFilters = this.requestFilters_;\n  for (var i = 0; i < requestFilters.length; i++) {\n    try {\n      requestFilters[i](type, request);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  }\n\n  var retry = request.retryParameters || {};\n  var maxAttempts = retry.maxAttempts || 1;\n  var backoffFactor = retry.backoffFactor || 2.0;\n  var delay = (retry.baseDelay == null ? 1000 : retry.baseDelay);\n\n  var p = this.send_(type, request, 0);\n  for (var i = 1; i < maxAttempts; i++) {\n    var index = i % request.uris.length;\n    p = p.catch(this.resend_.bind(this, type, request, delay, index));\n    delay *= backoffFactor;\n  }\n\n  // Add the request to the array.\n  this.requests_.push(p);\n  return p.then(function(response) {\n    if (this.requests_.indexOf(p) >= 0) {\n      this.requests_.splice(this.requests_.indexOf(p), 1);\n    }\n    var endTimeMs = Date.now();\n    if (this.onSegmentDownloaded_ &&\n        type == shaka.net.NetworkingEngine.RequestType.SEGMENT) {\n      this.onSegmentDownloaded_(\n          startTimeMs, endTimeMs, response.data.byteLength);\n    }\n    return response;\n  }.bind(this)).catch(function(e) {\n    if (this.requests_.indexOf(p) >= 0) {\n      this.requests_.splice(this.requests_.indexOf(p), 1);\n    }\n    return Promise.reject(e);\n  }.bind(this));\n};\n\n\n/**\n * Sends the given request to the correct plugin.  This does not handle retry.\n *\n * @param {shaka.net.NetworkingEngine.RequestType} type\n * @param {shakaExtern.Request} request\n * @param {number} index\n * @return {!Promise.<shakaExtern.Response>}\n * @private\n */\nshaka.net.NetworkingEngine.prototype.send_ = function(type, request, index) {\n  if (this.destroyed_)\n    return Promise.reject();\n\n  var uri = new goog.Uri(request.uris[index]);\n  var scheme = uri.getScheme();\n\n  if (!scheme) {\n    // If there is no scheme, infer one from the location.\n    scheme = shaka.net.NetworkingEngine.getLocationProtocol_();\n    goog.asserts.assert(scheme[scheme.length - 1] == ':',\n                        'location.protocol expected to end with a colon!');\n    // Drop the colon.\n    scheme = scheme.slice(0, -1);\n\n    // Override the original URI to make the scheme explicit.\n    uri.setScheme(scheme);\n    request.uris[index] = uri.toString();\n  }\n\n  var plugin = shaka.net.NetworkingEngine.schemes_[scheme];\n  if (!plugin) {\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Category.NETWORK,\n        shaka.util.Error.Code.UNSUPPORTED_SCHEME,\n        uri));\n  }\n\n  return plugin(request.uris[index], request).then(function(response) {\n    // Since we are inside a promise, no need to catch errors; they will result\n    // in a failed promise.\n    var responseFilters = this.responseFilters_;\n    for (var i = 0; i < responseFilters.length; i++) {\n      responseFilters[i](type, response);\n    }\n\n    return response;\n  }.bind(this));\n};\n\n\n/**\n * Resends the request after applying a delay.  This does not handle retry.\n *\n * @param {shaka.net.NetworkingEngine.RequestType} type\n * @param {shakaExtern.Request} request\n * @param {number} delayMs The current base delay.\n * @param {number} index\n * @return {!Promise.<shakaExtern.Response>}\n * @private\n */\nshaka.net.NetworkingEngine.prototype.resend_ =\n    function(type, request, delayMs, index) {\n  var p = new shaka.util.PublicPromise();\n\n  // Fuzz the delay to avoid tons of clients hitting the server at once\n  // after it recovers from whatever is causing it to fail.\n  var retry = request.retryParameters || {};\n  var fuzzFactor = (retry.fuzzFactor == null ? 0.5 : retry.fuzzFactor);\n  var negToPosOne = (Math.random() * 2.0) - 1.0;\n  var negToPosFuzzFactor = negToPosOne * fuzzFactor;\n  var fuzzedDelay = delayMs * (1.0 + negToPosFuzzFactor);\n  shaka.net.NetworkingEngine.setTimeout_(p.resolve, fuzzedDelay);\n\n  return p.then(this.send_.bind(this, type, request, index));\n};\n\n\n/**\n * This is here only for testability.  We can't mock location in our tests on\n * all browsers, so instead we mock this.\n *\n * @return {string} The value of location.protocol.\n * @private\n */\nshaka.net.NetworkingEngine.getLocationProtocol_ = function() {\n  return location.protocol;\n};\n\n\n/**\n * This is here only for testability.  Mocking global setTimeout can lead to\n * unintended interactions with other tests.  So instead, we mock this.\n *\n * @param {Function} fn The callback to invoke when the timeout expires.\n * @param {number} timeoutMs The timeout in milliseconds.\n * @return {number} The timeout ID.\n * @private\n */\nshaka.net.NetworkingEngine.setTimeout_ = function(fn, timeoutMs) {\n  return window.setTimeout(fn, timeoutMs);\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/offline/db_engine.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.offline.DBEngine');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.PublicPromise');\n\n\n\n/**\n * This manages all operations on an IndexedDB.  This wraps all operations\n * in Promises.  All Promises will resolve once the transaction has completed.\n * Depending on the browser, this may or may not be after the data is flushed\n * to disk.  https://goo.gl/zMOeJc\n *\n * @struct\n * @constructor\n * @implements {shaka.util.IDestroyable}\n */\nshaka.offline.DBEngine = function() {\n  /** @private {IDBDatabase} */\n  this.db_ = null;\n\n  /** @private {!Array.<shaka.offline.DBEngine.Operation>} */\n  this.operations_ = [];\n\n  /** @private {!Object.<string, number>} */\n  this.currentIdMap_ = {};\n};\n\n\n/**\n * @typedef {{\n *   transaction: !IDBTransaction,\n *   promise: !shaka.util.PublicPromise\n * }}\n *\n * @property {!IDBTransaction} transaction\n *   The transaction that this operation is using.\n * @property {!shaka.util.PublicPromise} promise\n *   The promise associated with the operation.\n */\nshaka.offline.DBEngine.Operation;\n\n\n/** @private {string} */\nshaka.offline.DBEngine.DB_NAME_ = 'shaka_offline_db';\n\n\n/** @private @const {number} */\nshaka.offline.DBEngine.DB_VERSION_ = 1;\n\n\n/**\n * Determines if the browsers supports IndexedDB.\n * @return {boolean}\n */\nshaka.offline.DBEngine.isSupported = function() {\n  return window.indexedDB != null;\n};\n\n\n/**\n * Delete the database.  There must be no open connections to the database.\n * @return {!Promise}\n */\nshaka.offline.DBEngine.deleteDatabase = function() {\n  if (!window.indexedDB)\n    return Promise.resolve();\n  var request =\n      window.indexedDB.deleteDatabase(shaka.offline.DBEngine.DB_NAME_);\n\n  var p = new shaka.util.PublicPromise();\n  request.onsuccess = function(event) {\n    goog.asserts.assert(event.newVersion == null, 'Unexpected database update');\n    p.resolve();\n  };\n  request.onerror = shaka.offline.DBEngine.onError_.bind(null, request, p);\n  return p;\n};\n\n\n/**\n * Gets whether the DBEngine is initialized.\n *\n * @return {boolean}\n */\nshaka.offline.DBEngine.prototype.initialized = function() {\n  return this.db_ != null;\n};\n\n\n/**\n * Initializes the database and creates and required tables.\n *\n * @param {!Object.<string, string>} storeMap\n *   A map of store name to the key path.\n * @return {!Promise}\n */\nshaka.offline.DBEngine.prototype.init = function(storeMap) {\n  goog.asserts.assert(!this.db_, 'Already initialized');\n  var DBEngine = shaka.offline.DBEngine;\n  if (!DBEngine.isSupported()) {\n    return Promise.reject(\n        new shaka.util.Error(\n            shaka.util.Error.Category.STORAGE,\n            shaka.util.Error.Code.INDEXED_DB_NOT_SUPPORTED));\n  }\n\n  var indexedDB = window.indexedDB;\n  var request = indexedDB.open(DBEngine.DB_NAME_, DBEngine.DB_VERSION_);\n\n  var promise = new shaka.util.PublicPromise();\n  request.onupgradeneeded = function(event) {\n    var db = event.target.result;\n    goog.asserts.assert(event.oldVersion == 0,\n                        'Must be upgrading from version 0');\n    goog.asserts.assert(db.objectStoreNames.length == 0,\n                        'Version 0 database should be empty');\n    for (var name in storeMap) {\n      db.createObjectStore(name, {keyPath: storeMap[name]});\n    }\n  };\n  request.onsuccess = (function(event) {\n    this.db_ = event.target.result;\n    promise.resolve();\n  }.bind(this));\n  request.onerror = DBEngine.onError_.bind(null, request, promise);\n\n  return promise.then(function() {\n    // For each store, get the next ID and store in the map.\n    var stores = Object.keys(storeMap);\n    return Promise.all(stores.map(function(store) {\n      return this.getNextId_(store).then(function(id) {\n        this.currentIdMap_[store] = id;\n      }.bind(this));\n    }.bind(this)));\n  }.bind(this));\n};\n\n\n/** @override */\nshaka.offline.DBEngine.prototype.destroy = function() {\n  return Promise.all(this.operations_.map(function(op) {\n    try {\n      // If the transaction is considered finished but has not called the\n      // callbacks yet, it will still be in the list and this call will fail.\n      // Simply ignore errors.\n      op.transaction.abort();\n    } catch (e) {}\n\n    var Functional = shaka.util.Functional;\n    return op.promise.catch(Functional.noop);\n  })).then(function() {\n    if (this.db_) {\n      this.db_.close();\n      this.db_ = null;\n    }\n  }.bind(this));\n};\n\n\n/**\n * Gets the item with the given ID in the store.\n *\n * @param {string} storeName\n * @param {number} key\n * @return {!Promise.<T>}\n * @template T\n */\nshaka.offline.DBEngine.prototype.get = function(storeName, key) {\n  return this.createOperation_(storeName, 'readonly', function(store) {\n    return store.get(key);\n  });\n};\n\n\n/**\n * Calls the given callback for each value in the store.  The promise will\n * resolve after all items have been traversed.\n *\n * @param {string} storeName\n * @param {function(T)} callback\n * @return {!Promise}\n * @template T\n */\nshaka.offline.DBEngine.prototype.forEach = function(storeName, callback) {\n  return this.createOperation_(storeName, 'readonly', function(store) {\n    return store.openCursor();\n  }, function(/** IDBCursor */ cursor) {\n    if (!cursor) return;\n\n    callback(cursor.value);\n    cursor.continue();\n  });\n};\n\n\n/**\n * Adds or updates the given value in the store.\n *\n * @param {string} storeName\n * @param {!Object} value\n * @return {!Promise}\n */\nshaka.offline.DBEngine.prototype.insert = function(storeName, value) {\n  return this.createOperation_(storeName, 'readwrite', function(store) {\n    return store.put(value);\n  });\n};\n\n\n/**\n * Removes the item with the given key.\n *\n * @param {string} storeName\n * @param {number} key\n * @return {!Promise}\n */\nshaka.offline.DBEngine.prototype.remove = function(storeName, key) {\n  return this.createOperation_(storeName, 'readwrite', function(store) {\n    return store.delete(key);\n  });\n};\n\n\n/**\n * Removes all items for which the given predicate returns true.\n *\n * @param {string} storeName\n * @param {function(T):boolean} callback\n * @return {!Promise.<number>}\n * @template T\n */\nshaka.offline.DBEngine.prototype.removeWhere = function(storeName, callback) {\n  var async = [];\n  return this.createOperation_(storeName, 'readwrite', function(store) {\n    return store.openCursor();\n  }, function(/** IDBCursor */ cursor) {\n    if (!cursor) return;\n\n    if (callback(cursor.value)) {\n      var request = cursor.delete();\n      var p = new shaka.util.PublicPromise();\n      request.onsuccess = p.resolve;\n      request.onerror = shaka.offline.DBEngine.onError_.bind(null, request, p);\n      async.push(p);\n    }\n    cursor.continue();\n  }).then(function() {\n    return Promise.all(async);\n  }).then(function() {\n    return async.length;\n  });\n};\n\n\n/**\n * Reserves the next ID and returns it.\n *\n * @param {string} storeName\n * @return {number}\n */\nshaka.offline.DBEngine.prototype.reserveId = function(storeName) {\n  goog.asserts.assert(storeName in this.currentIdMap_,\n                      'Store name must be passed to init()');\n  return this.currentIdMap_[storeName]++;\n};\n\n\n/**\n * Gets the ID to start at.\n *\n * @param {string} storeName\n * @return {!Promise.<number>}\n * @private\n */\nshaka.offline.DBEngine.prototype.getNextId_ = function(storeName) {\n  var ret = 0;\n  return this.createOperation_(storeName, 'readonly', function(store) {\n    return store.openCursor(null, 'prev');\n  }, function(/** IDBCursor */ cursor) {\n    if (cursor)\n      ret = cursor.key + 1;\n  }).then(function() { return ret; });\n};\n\n\n/**\n * Creates a new transaction for the given store name and calls the given\n * callback to create a request.  It then wraps the given request in an\n * operation and returns the resulting promise.  The Promise resolves when\n * the transaction is complete, which will be after opt_success is called.\n *\n * @param {string} storeName\n * @param {string} type\n * @param {function(!IDBObjectStore):!IDBRequest} createRequest\n * @param {(function(*))=} opt_success The value of onsuccess for the request.\n * @return {!Promise}\n * @private\n */\nshaka.offline.DBEngine.prototype.createOperation_ = function(\n    storeName, type, createRequest, opt_success) {\n  goog.asserts.assert(this.db_, 'Must not be destroyed');\n  goog.asserts.assert(type == 'readonly' || type == 'readwrite',\n                      'Type must be \"readonly\" or \"readwrite\"');\n\n  var trans = this.db_.transaction([storeName], type);\n  var request = createRequest(trans.objectStore(storeName));\n\n  var p = new shaka.util.PublicPromise();\n  if (opt_success)\n    request.onsuccess = function(event) { opt_success(event.target.result); };\n  request.onerror = shaka.offline.DBEngine.onError_.bind(null, request, p);\n\n  var op = {transaction: trans, promise: p};\n  this.operations_.push(op);\n\n  // Only remove the transaction once it has completed, which may be after the\n  // request is complete (e.g. it may need to write to disk).\n  var removeOp = (function() {\n    var i = this.operations_.indexOf(op);\n    goog.asserts.assert(i >= 0, 'Operation must be in the list.');\n    this.operations_.splice(i, 1);\n  }.bind(this));\n  trans.oncomplete = function(event) {\n    removeOp();\n    p.resolve(request.result);\n  };\n  trans.onerror = function(event) {\n    removeOp();\n    shaka.offline.DBEngine.onError_(request, p, event);\n  };\n  return p;\n};\n\n\n/**\n * Rejects the given Promise with an unknown error.\n *\n * @param {!IDBRequest} request\n * @param {!shaka.util.PublicPromise} promise\n * @param {Event} event\n * @private\n */\nshaka.offline.DBEngine.onError_ = function(request, promise, event) {\n  if (request.error.name == 'AbortError') {\n    promise.reject(new shaka.util.Error(\n        shaka.util.Error.Category.STORAGE,\n        shaka.util.Error.Code.OPERATION_ABORTED));\n  } else {\n    promise.reject(new shaka.util.Error(\n        shaka.util.Error.Category.STORAGE,\n        shaka.util.Error.Code.INDEXED_DB_ERROR, request.error));\n  }\n\n  // Firefox will raise an error which will cause a karma failure.\n  event.preventDefault();\n};\n\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/offline/download_manager.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.offline.DownloadManager');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.offline.OfflineUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.MapUtils');\n\n\n\n/**\n * This manages downloading segments and notifying the app of progress.\n *\n * @param {!shaka.net.NetworkingEngine} netEngine\n * @param {shakaExtern.RetryParameters} retryParams\n * @param {shakaExtern.OfflineConfiguration} config\n *\n * @struct\n * @constructor\n * @implements {shaka.util.IDestroyable}\n */\nshaka.offline.DownloadManager = function(netEngine, retryParams, config) {\n  /**\n   * @private {!Object.<\n   *     string, !Array.<shaka.offline.DownloadManager.Segment>>}\n   */\n  this.segments_ = {};\n\n  /** @private {?shakaExtern.OfflineConfiguration} */\n  this.config_ = config;\n\n  /** @private {shaka.net.NetworkingEngine} */\n  this.netEngine_ = netEngine;\n\n  /** @private {?shakaExtern.RetryParameters} */\n  this.retryParams_ = retryParams;\n\n  /** @private {?shakaExtern.ManifestDB} */\n  this.manifest_ = null;\n\n  /** @private {Promise} */\n  this.promise_ = null;\n\n  /**\n   * The total number of bytes for segments that include a byte range.\n   * @private {number}\n   */\n  this.givenBytesTotal_ = 0;\n\n  /**\n   * The number of bytes downloaded for segments that include a byte range.\n   * @private {number}\n   */\n  this.givenBytesDownloaded_ = 0;\n\n  /**\n   * The total number of bytes estimated based on bandwidth for segments that\n   * do not include a byte range.\n   * @private {number}\n   */\n  this.bandwidthBytesTotal_ = 0;\n\n  /**\n   * The estimated number of bytes downloaded for segments that do not have\n   * a byte range.\n   * @private {number}\n   */\n  this.bandwidthBytesDownloaded_ = 0;\n};\n\n\n/**\n * @typedef {{\n *   uris: !Array.<string>,\n *   startByte: number,\n *   endByte: ?number,\n *   bandwidthSize: number,\n *   callback: function(!ArrayBuffer):!Promise\n * }}\n *\n * @property {!Array.<string>} uris\n *   The URIs to download the segment.\n * @property {number} startByte\n *   The byte index the segment starts at.\n * @property {?number} endByte\n *   The byte index the segment ends at, if present.\n * @property {number} bandwidthSize\n *   The size of the segment as estimated by the bandwidth and segment duration.\n * @property {function(!ArrayBuffer):!Promise} callback\n *   The callback to call once the segment is downloaded.\n */\nshaka.offline.DownloadManager.Segment;\n\n\n/** @override */\nshaka.offline.DownloadManager.prototype.destroy = function() {\n  var ret = this.promise_ || Promise.resolve();\n  this.segments_ = {};\n  this.config_ = null;\n  this.netEngine_ = null;\n  this.retryParams_ = null;\n  this.manifest_ = null;\n  this.promise_ = null;\n  return ret;\n};\n\n\n/**\n * Adds a segment to the list to be downloaded.\n *\n * @param {string} type\n * @param {!shaka.media.SegmentReference|!shaka.media.InitSegmentReference} ref\n * @param {number} bandwidthSize\n * @param {function(!ArrayBuffer):!Promise} callback\n */\nshaka.offline.DownloadManager.prototype.addSegment = function(\n    type, ref, bandwidthSize, callback) {\n  this.segments_[type] = this.segments_[type] || [];\n  this.segments_[type].push({\n    uris: ref.getUris(),\n    startByte: ref.startByte,\n    endByte: ref.endByte,\n    bandwidthSize: bandwidthSize,\n    callback: callback\n  });\n};\n\n\n/**\n * Downloads all the segments.\n *\n * @param {shakaExtern.ManifestDB} manifest\n * @return {!Promise}\n */\nshaka.offline.DownloadManager.prototype.download = function(manifest) {\n  var MapUtils = shaka.util.MapUtils;\n  // Calculate progress estimates.\n  this.givenBytesTotal_ = 0;\n  this.givenBytesDownloaded_ = 0;\n  this.bandwidthBytesTotal_ = 0;\n  this.bandwidthBytesDownloaded_ = 0;\n  MapUtils.values(this.segments_).forEach(function(segments) {\n    segments.forEach(function(segment) {\n      if (segment.endByte != null)\n        this.givenBytesTotal_ += (segment.endByte - segment.startByte + 1);\n      else\n        this.bandwidthBytesTotal_ += segment.bandwidthSize;\n    }.bind(this));\n  }.bind(this));\n\n  this.manifest_ = manifest;\n  // Will be updated as we download for segments without a byte-range.\n  this.manifest_.size = this.givenBytesTotal_;\n\n  // Create separate download chains for different content types.  This will\n  // allow audio and video to be downloaded in parallel.\n  var async = MapUtils.values(this.segments_).map(function(segments) {\n    var i = 0;\n    var downloadNext = (function() {\n      if (!this.config_) {\n        return Promise.reject(new shaka.util.Error(\n            shaka.util.Error.Category.STORAGE,\n            shaka.util.Error.Code.OPERATION_ABORTED));\n      }\n      if (i >= segments.length) return Promise.resolve();\n      var segment = segments[i++];\n      return this.downloadSegment_(segment).then(downloadNext);\n    }.bind(this));\n    return downloadNext();\n  }.bind(this));\n  this.segments_ = {};\n\n  return (this.promise_ = Promise.all(async));\n};\n\n\n/**\n * Downloads the given segment and calls the callback.\n *\n * @param {shaka.offline.DownloadManager.Segment} segment\n * @return {!Promise}\n * @private\n */\nshaka.offline.DownloadManager.prototype.downloadSegment_ = function(segment) {\n  goog.asserts.assert(this.retryParams_, 'Must not be destroyed');\n  var type = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n  var request =\n      shaka.net.NetworkingEngine.makeRequest(segment.uris, this.retryParams_);\n  if (segment.startByte != 0 || segment.endByte != null) {\n    var end = segment.endByte == null ? '' : segment.endByte;\n    request.headers['Range'] = 'bytes=' + segment.startByte + '-' + end;\n  }\n\n  var byteCount;\n  return this.netEngine_.request(type, request)\n      .then(function(response) {\n        if (!this.manifest_) {\n          return Promise.reject(new shaka.util.Error(\n              shaka.util.Error.Category.STORAGE,\n              shaka.util.Error.Code.OPERATION_ABORTED));\n        }\n        byteCount = response.data.byteLength;\n        return segment.callback(response.data);\n      }.bind(this))\n      .then(function() {\n        if (!this.manifest_) {\n          return Promise.reject(new shaka.util.Error(\n              shaka.util.Error.Category.STORAGE,\n              shaka.util.Error.Code.OPERATION_ABORTED));\n        }\n        if (segment.endByte == null) {\n          // We didn't know the size, so it was an estimate.\n          this.manifest_.size += byteCount;\n          this.bandwidthBytesDownloaded_ += segment.bandwidthSize;\n        } else {\n          goog.asserts.assert(\n              byteCount == (segment.endByte - segment.startByte + 1),\n              'Incorrect download size');\n          this.givenBytesDownloaded_ += byteCount;\n        }\n        this.updateProgress_();\n      }.bind(this));\n};\n\n\n/**\n * Calls the progress callback.\n * @private\n */\nshaka.offline.DownloadManager.prototype.updateProgress_ = function() {\n  var progress = (this.givenBytesDownloaded_ + this.bandwidthBytesDownloaded_) /\n      (this.givenBytesTotal_ + this.bandwidthBytesTotal_);\n\n  goog.asserts.assert(this.manifest_, 'Must not be destroyed');\n  var manifest = shaka.offline.OfflineUtils.getStoredContent(this.manifest_);\n  this.config_.progressCallback(manifest, progress);\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/offline/offline_manifest_parser.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.offline.OfflineManifestParser');\n\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.ManifestParser');\ngoog.require('shaka.media.PresentationTimeline');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.offline.DBEngine');\ngoog.require('shaka.offline.OfflineUtils');\ngoog.require('shaka.util.Error');\n\n\n\n/**\n * Creates a new offline manifest parser.\n * @struct\n * @constructor\n * @implements {shakaExtern.ManifestParser}\n */\nshaka.offline.OfflineManifestParser = function() {\n};\n\n\n/** @override */\nshaka.offline.OfflineManifestParser.prototype.configure = function(config) {\n  // No-op\n};\n\n\n/** @override */\nshaka.offline.OfflineManifestParser.prototype.start =\n    function(uri, networkingEngine, filterPeriod, onError) {\n  var parts = /^offline:([0-9]+)$/.exec(uri);\n  if (!parts) {\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Category.NETWORK,\n        shaka.util.Error.Code.MALFORMED_OFFLINE_URI, uri));\n  }\n  var manifestId = Number(parts[1]);\n  var dbEngine = new shaka.offline.DBEngine();\n\n  return dbEngine.init(shaka.offline.OfflineUtils.DB_SCHEME)\n      .then(function() { return dbEngine.get('manifest', manifestId); })\n      .then(function(manifest) {\n        if (!manifest) {\n          throw new shaka.util.Error(\n              shaka.util.Error.Category.STORAGE,\n              shaka.util.Error.Code.REQUESTED_ITEM_NOT_FOUND, manifestId);\n        }\n\n        var OfflineManifestParser = shaka.offline.OfflineManifestParser;\n        return OfflineManifestParser.reconstructManifest(manifest);\n      })\n      .then(\n          function(ret) {\n            return dbEngine.destroy().then(function() { return ret; });\n          },\n          function(err) {\n            return dbEngine.destroy().then(function() { throw err; });\n          });\n};\n\n\n/** @override */\nshaka.offline.OfflineManifestParser.prototype.stop = function() {\n  return Promise.resolve();\n};\n\n\n/**\n * Reconstructs a manifest object from the given database manifest.\n *\n * @param {shakaExtern.ManifestDB} manifest\n * @return {shakaExtern.Manifest}\n */\nshaka.offline.OfflineManifestParser.reconstructManifest = function(\n    manifest) {\n  var timeline = new shaka.media.PresentationTimeline(null, 0);\n  timeline.setDuration(manifest.duration);\n  var drmInfos = manifest.drmInfo ? [manifest.drmInfo] : [];\n  return {\n    presentationTimeline: timeline,\n    minBufferTime: 10,\n    offlineSessionIds: manifest.sessionIds,\n    periods: manifest.periods.map(function(period) {\n      return {\n        startTime: period.startTime,\n        streamSets: period.streams.map(function(streamDb) {\n          var refs = streamDb.segments.map(function(segment, i) {\n            var getUris = function() { return [segment.uri]; };\n            return new shaka.media.SegmentReference(\n                i, segment.startTime, segment.endTime, getUris, 0, null);\n          });\n          timeline.notifySegments(period.startTime, refs);\n          var segmentIndex = new shaka.media.SegmentIndex(refs);\n\n          var initRef = streamDb.initSegmentUri ?\n              new shaka.media.InitSegmentReference(\n                  function() { return [streamDb.initSegmentUri]; }, 0, null) :\n              null;\n          var stream = {\n            id: streamDb.id,\n            createSegmentIndex: Promise.resolve.bind(Promise),\n            findSegmentPosition: segmentIndex.find.bind(segmentIndex),\n            getSegmentReference: segmentIndex.get.bind(segmentIndex),\n            initSegmentReference: initRef,\n            presentationTimeOffset: streamDb.presentationTimeOffset,\n            mimeType: streamDb.mimeType,\n            codecs: streamDb.codecs,\n            bandwidth: 0,\n            width: streamDb.width || undefined,\n            height: streamDb.height || undefined,\n            kind: streamDb.kind,\n            encrypted: streamDb.encrypted,\n            keyId: streamDb.keyId,\n            allowedByApplication: true,\n            allowedByKeySystem: true\n          };\n          var streamSet = {\n            language: streamDb.language,\n            type: streamDb.contentType,\n            primary: streamDb.primary,\n            drmInfos: drmInfos,\n            streams: [stream]\n          };\n          return streamSet;\n        })\n      };\n    })\n  };\n};\n\n\nshaka.media.ManifestParser.registerParserByMime(\n    'application/x-offline-manifest', shaka.offline.OfflineManifestParser);\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/offline/offline_scheme.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.offline.OfflineScheme');\n\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.offline.DBEngine');\ngoog.require('shaka.offline.OfflineUtils');\ngoog.require('shaka.util.Error');\n\n\n/**\n * @namespace\n * @summary A plugin that handles requests for offline content.\n * @param {string} uri\n * @param {shakaExtern.Request} request\n * @return {!Promise.<shakaExtern.Response>}\n * @export\n */\nshaka.offline.OfflineScheme = function(uri, request) {\n  var manifestParts = /^offline:([0-9]+)$/.exec(uri);\n  if (manifestParts) {\n    /** @type {shakaExtern.Response} */\n    var response = {\n      uri: uri,\n      data: new ArrayBuffer(0),\n      headers: {'content-type': 'application/x-offline-manifest'}\n    };\n    return Promise.resolve(response);\n  }\n\n  var segmentParts = /^offline:[0-9]+\\/[0-9]+\\/([0-9]+)$/.exec(uri);\n  if (segmentParts) {\n    var segmentId = Number(segmentParts[1]);\n    var scheme = shaka.offline.OfflineUtils.DB_SCHEME;\n    var dbEngine = new shaka.offline.DBEngine();\n    return dbEngine.init(scheme)\n        .then(function() { return dbEngine.get('segment', segmentId); })\n        .then(function(segment) {\n          return dbEngine.destroy().then(function() {\n            if (!segment) {\n              throw new shaka.util.Error(\n                  shaka.util.Error.Category.STORAGE,\n                  shaka.util.Error.Code.REQUESTED_ITEM_NOT_FOUND, segmentId);\n            }\n            return {uri: uri, data: segment.data, headers: {}};\n          });\n        });\n  }\n\n  return Promise.reject(new shaka.util.Error(\n      shaka.util.Error.Category.NETWORK,\n      shaka.util.Error.Code.MALFORMED_OFFLINE_URI, uri));\n};\n\n\nshaka.net.NetworkingEngine.registerScheme(\n    'offline', shaka.offline.OfflineScheme);\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/offline/offline_utils.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.offline.OfflineUtils');\n\ngoog.require('goog.asserts');\n\n\n/** @const {!Object.<string, string>} */\nshaka.offline.OfflineUtils.DB_SCHEME = {'manifest': 'key', 'segment': 'key'};\n\n\n/**\n * Converts the given database manifest to a storedContent structure.\n *\n * @param {shakaExtern.ManifestDB} manifest\n * @return {shakaExtern.StoredContent}\n */\nshaka.offline.OfflineUtils.getStoredContent = function(manifest) {\n  goog.asserts.assert(manifest.periods.length > 0,\n                      'Must be at least one Period.');\n  return {\n    offlineUri: 'offline:' + manifest.key,\n    originalManifestUri: manifest.originalManifestUri,\n    duration: manifest.duration,\n    size: manifest.size,\n    tracks: manifest.periods[0].streams.map(function(stream) {\n      return {\n        id: stream.id,\n        active: false,\n        type: stream.contentType,\n        bandwidth: 0,\n        language: stream.language,\n        kind: stream.kind || null,\n        width: stream.width,\n        height: stream.height,\n        frameRate: stream.frameRate,\n        codecs: stream.codecs\n      };\n    }),\n    appMetadata: manifest.appMetadata\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/offline/storage.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.offline.Storage');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.Player');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.media.ManifestParser');\ngoog.require('shaka.offline.DBEngine');\ngoog.require('shaka.offline.DownloadManager');\ngoog.require('shaka.offline.OfflineManifestParser');\ngoog.require('shaka.offline.OfflineUtils');\ngoog.require('shaka.util.ConfigUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.StreamUtils');\n\n\n\n/**\n * This manages persistent offline data including storage, listing, and deleting\n * stored manifests.  Playback of offline manifests are done using Player\n * using the special URI (e.g. 'offline:12').\n *\n * First, check support() to see if offline is supported by the platform.\n * Second, configure() the storage object with callbacks to your application.\n * Third, call store(), remove(), or list() as needed.\n * When done, call destroy().\n *\n * @param {shaka.Player} player\n *   The player instance to pull configuration data from.\n *\n * @struct\n * @constructor\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.offline.Storage = function(player) {\n  /** @private {shaka.offline.DBEngine} */\n  this.dbEngine_ = new shaka.offline.DBEngine();\n\n  /** @private {shaka.Player} */\n  this.player_ = player;\n\n  /** @private {?shakaExtern.OfflineConfiguration} */\n  this.config_ = this.defaultConfig_();\n\n  /** @private {shaka.media.DrmEngine} */\n  this.drmEngine_ = null;\n\n  /** @private {boolean} */\n  this.storeInProgress_ = false;\n\n  /** @private {Array.<shakaExtern.Track>} */\n  this.firstPeriodTracks_ = null;\n\n  /**\n   * The IDs of the segments that have been stored for an in-progress store().\n   * This is used to cleanup in destroy().\n   * @private {!Array.<number>}\n   */\n  this.inProgressSegmentIds_ = [];\n\n  /** @private {number} */\n  this.manifestId_ = -1;\n\n  /** @private {number} */\n  this.duration_ = 0;\n\n  /** @private {?shakaExtern.Manifest} */\n  this.manifest_ = null;\n\n  var netEngine = player.getNetworkingEngine();\n  goog.asserts.assert(netEngine, 'Player must not be destroyed');\n\n  /** @private {shaka.offline.DownloadManager} */\n  this.downloadManager_ = new shaka.offline.DownloadManager(\n      netEngine, player.getConfiguration().streaming.retryParameters,\n      this.config_);\n};\n\n\n/**\n * Gets whether offline storage is supported.  Returns true if offline storage\n * is supported for clear content.  Support for offline storage of encrypted\n * content will not be determined until storage is attempted.\n *\n * @return {boolean}\n * @export\n */\nshaka.offline.Storage.support = function() {\n  return shaka.offline.DBEngine.isSupported();\n};\n\n\n/**\n * Sets the DBEngine instance to use.  This is used for testing.\n *\n * @param {!shaka.offline.DBEngine} engine\n */\nshaka.offline.Storage.prototype.setDbEngine = function(engine) {\n  goog.asserts.assert(!this.dbEngine_.initialized(),\n                      'Should not be initialized yet');\n  this.dbEngine_ = engine;\n};\n\n\n/**\n * @override\n * @export\n */\nshaka.offline.Storage.prototype.destroy = function() {\n  var segments = this.inProgressSegmentIds_;\n  var dbEngine = this.dbEngine_;\n  // Destroy the download manager first to ensure segments are not added while\n  // we delete old ones.\n  var ret = !this.downloadManager_ ?\n      Promise.resolve() :\n      this.downloadManager_.destroy()\n          .catch(function() {})\n          .then(function() {\n            return Promise.all(segments.map(function(id) {\n              return dbEngine.remove('segment', id);\n            }));\n          })\n          .then(function() { return dbEngine.destroy(); });\n\n  this.dbEngine_ = null;\n  this.downloadManager_ = null;\n  this.player_ = null;\n  this.config_ = null;\n  return ret;\n};\n\n\n/**\n * Sets configuration values for Storage.  This is not associated with\n * Player.configure and will not change Player.\n *\n * There are two important callbacks configured here: one for download progress,\n * and one to decide which tracks to store.\n *\n * The default track selection callback will store the largest SD video track.\n * Provide your own callback to choose the tracks you want to store.\n *\n * @param {shakaExtern.OfflineConfiguration} config\n * @export\n */\nshaka.offline.Storage.prototype.configure = function(config) {\n  goog.asserts.assert(this.config_, 'Must not be destroyed');\n  shaka.util.ConfigUtils.mergeConfigObjects(\n      this.config_, config, this.defaultConfig_(), {}, '');\n};\n\n\n/**\n * Stores the given manifest.  If the content is encrypted, and encrypted\n * content cannot be stored on this platform, the Promise will be rejected with\n * error code 6001, REQUESTED_KEY_SYSTEM_CONFIG_UNAVAILABLE.\n *\n * @param {string} manifestUri The URI of the manifest to store.\n * @param {!Object} appMetadata An arbitrary object from the application that\n *   will be stored along-side the offline content.  Use this for any\n *   application-specific metadata you need associated with the stored content.\n *   For details on the data types that can be stored here, please refer to\n *   https://goo.gl/h62coS\n * @param {!shakaExtern.ManifestParser.Factory=} opt_manifestParserFactory\n * @return {!Promise.<shakaExtern.StoredContent>}  A Promise to a structure\n *   representing what was stored.  The \"offlineUri\" member is the URI that\n *   should be given to Player.load() to play this piece of content offline.\n *   The \"appMetadata\" member is the appMetadata argument you passed to store().\n * @export\n */\nshaka.offline.Storage.prototype.store = function(\n    manifestUri, appMetadata, opt_manifestParserFactory) {\n  if (this.storeInProgress_) {\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Category.STORAGE,\n        shaka.util.Error.Code.STORE_ALREADY_IN_PROGRESS));\n  }\n  this.storeInProgress_ = true;\n\n  /** @type {shakaExtern.ManifestDB} */\n  var manifestDb;\n\n  var error = null;\n  var onError = function(e) { error = e; };\n  return this.initIfNeeded_()\n      .then(function() {\n        this.checkDestroyed_();\n        return this.loadInternal(\n            manifestUri, onError, opt_manifestParserFactory);\n      }.bind(this)).then((\n          /**\n           * @param {{manifest: shakaExtern.Manifest,\n           *          drmEngine: !shaka.media.DrmEngine}} data\n           * @return {!Promise}\n           */\n          function(data) {\n            this.checkDestroyed_();\n            this.manifest_ = data.manifest;\n            this.drmEngine_ = data.drmEngine;\n\n            if (this.manifest_.presentationTimeline.isLive() ||\n                this.manifest_.presentationTimeline.isInProgress()) {\n              throw new shaka.util.Error(\n                  shaka.util.Error.Category.STORAGE,\n                  shaka.util.Error.Code.CANNOT_STORE_LIVE_OFFLINE, manifestUri);\n            }\n\n            // Re-filter now that DrmEngine is initialized.\n            this.manifest_.periods.forEach(this.filterPeriod_.bind(this));\n\n            this.manifestId_ = this.dbEngine_.reserveId('manifest');\n            this.duration_ = 0;\n            manifestDb = this.createOfflineManifest_(manifestUri, appMetadata);\n            return this.downloadManager_.download(manifestDb);\n          })\n      .bind(this))\n      .then(function() {\n        this.checkDestroyed_();\n        // Throw any errors from the manifest parser or DrmEngine.\n        if (error)\n          throw error;\n\n        return this.dbEngine_.insert('manifest', manifestDb);\n      }.bind(this))\n      .then(function() {\n        return this.cleanup_();\n      }.bind(this))\n      .then(function() {\n        return shaka.offline.OfflineUtils.getStoredContent(manifestDb);\n      }.bind(this))\n      .catch(function(err) {\n        var Functional = shaka.util.Functional;\n        return this.cleanup_().catch(Functional.noop).then(function() {\n          throw err;\n        });\n      }.bind(this));\n};\n\n\n/**\n * Removes the given stored content.\n *\n * @param {shakaExtern.StoredContent} content\n * @return {!Promise}\n * @export\n */\nshaka.offline.Storage.prototype.remove = function(content) {\n  var uri = content.offlineUri;\n  var parts = /^offline:([0-9]+)$/.exec(uri);\n  if (!parts) {\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Category.STORAGE,\n        shaka.util.Error.Code.MALFORMED_OFFLINE_URI, uri));\n  }\n\n  var error = null;\n  var onError = function(e) {\n    // Ignore errors if the session was already removed.\n    if (e.code != shaka.util.Error.Code.OFFLINE_SESSION_REMOVED)\n      error = e;\n  };\n\n  /** @type {shakaExtern.ManifestDB} */\n  var manifestDb;\n  /** @type {!shaka.media.DrmEngine} */\n  var drmEngine;\n  var manifestId = Number(parts[1]);\n  return this.initIfNeeded_().then(function() {\n    this.checkDestroyed_();\n    return this.dbEngine_.get('manifest', manifestId);\n  }.bind(this)).then((\n      /**\n       * @param {?shakaExtern.ManifestDB} data\n       * @return {!Promise}\n       */\n      function(data) {\n        this.checkDestroyed_();\n        if (!data) {\n          throw new shaka.util.Error(\n              shaka.util.Error.Category.STORAGE,\n              shaka.util.Error.Code.REQUESTED_ITEM_NOT_FOUND, uri);\n        }\n        manifestDb = data;\n        var manifest =\n            shaka.offline.OfflineManifestParser.reconstructManifest(manifestDb);\n        var netEngine = this.player_.getNetworkingEngine();\n        goog.asserts.assert(netEngine, 'Player must not be destroyed');\n        drmEngine =\n            new shaka.media.DrmEngine(netEngine, onError, function() {});\n        drmEngine.configure(this.player_.getConfiguration().drm);\n        return drmEngine.init(manifest, true /* isOffline */);\n      })\n  .bind(this)).then(function() {\n    return drmEngine.removeSessions(manifestDb.sessionIds);\n  }.bind(this)).then(function() {\n    return drmEngine.destroy();\n  }.bind(this)).then(function() {\n    this.checkDestroyed_();\n    if (error) throw error;\n    var Functional = shaka.util.Functional;\n    // Get every segment for every stream in the manifest.\n    /** @type {!Array.<number>} */\n    var segments = manifestDb.periods.map(function(period) {\n      return period.streams.map(function(stream) {\n        var segments = stream.segments.map(function(segment) {\n          var parts = /^offline:[0-9]+\\/[0-9]+\\/([0-9]+)$/.exec(segment.uri);\n          goog.asserts.assert(parts, 'Invalid offline URI');\n          return Number(parts[1]);\n        });\n        if (stream.initSegmentUri) {\n          var parts = /^offline:[0-9]+\\/[0-9]+\\/([0-9]+)$/.exec(\n              stream.initSegmentUri);\n          goog.asserts.assert(parts, 'Invalid offline URI');\n          segments.push(Number(parts[1]));\n        }\n        return segments;\n      }).reduce(Functional.collapseArrays, []);\n    }).reduce(Functional.collapseArrays, []);\n\n    // Delete all the segments.\n    var deleteCount = 0;\n    var segmentCount = segments.length;\n    var callback = this.config_.progressCallback;\n    return this.dbEngine_.removeWhere('segment', function(segment) {\n      var i = segments.indexOf(segment.key);\n      if (i >= 0) {\n        callback(content, deleteCount / segmentCount);\n        deleteCount++;\n      }\n      return i >= 0;\n    }.bind(this));\n  }.bind(this)).then(function() {\n    this.checkDestroyed_();\n    this.config_.progressCallback(content, 1);\n    return this.dbEngine_.remove('manifest', manifestId);\n  }.bind(this));\n};\n\n\n/**\n * Lists all the stored content available.\n *\n * @return {!Promise.<!Array.<shakaExtern.StoredContent>>}  A Promise to an\n *   array of structures representing all stored content.  The \"offlineUri\"\n *   member of the structure is the URI that should be given to Player.load()\n *   to play this piece of content offline.  The \"appMetadata\" member is the\n *   appMetadata argument you passed to store().\n * @export\n */\nshaka.offline.Storage.prototype.list = function() {\n  /** @type {!Array.<shakaExtern.StoredContent>} */\n  var storedContents = [];\n  return this.initIfNeeded_()\n      .then(function() {\n        this.checkDestroyed_();\n        return this.dbEngine_.forEach(\n            'manifest', function(/** shakaExtern.ManifestDB */ manifest) {\n              storedContents.push(\n                  shaka.offline.OfflineUtils.getStoredContent(manifest));\n            });\n      }.bind(this))\n      .then(function() { return storedContents; });\n};\n\n\n/**\n * Loads the given manifest, parses it, and constructs the DrmEngine.  This\n * stops the manifest parser.  This may be replaced by tests.\n *\n * @param {string} manifestUri\n * @param {function(*)} onError\n * @param {!shakaExtern.ManifestParser.Factory=} opt_manifestParserFactory\n * @return {!Promise.<{\n *   manifest: shakaExtern.Manifest,\n *   drmEngine: !shaka.media.DrmEngine\n * }>}\n */\nshaka.offline.Storage.prototype.loadInternal = function(\n    manifestUri, onError, opt_manifestParserFactory) {\n\n  var netEngine = /** @type {!shaka.net.NetworkingEngine} */ (\n      this.player_.getNetworkingEngine());\n  var config = this.player_.getConfiguration();\n\n  /** @type {shakaExtern.Manifest} */\n  var manifest;\n  /** @type {!shaka.media.DrmEngine} */\n  var drmEngine;\n  /** @type {!shakaExtern.ManifestParser} */\n  var manifestParser;\n\n  var onKeyStatusChange = function() {};\n  return shaka.media.ManifestParser\n      .getFactory(\n          manifestUri, netEngine, config.manifest.retryParameters,\n          opt_manifestParserFactory)\n      .then(function(factory) {\n        this.checkDestroyed_();\n        manifestParser = new factory();\n        manifestParser.configure(config.manifest);\n        return manifestParser.start(\n            manifestUri, netEngine, this.filterPeriod_.bind(this), onError);\n      }.bind(this))\n      .then(function(data) {\n        this.checkDestroyed_();\n        manifest = data;\n        drmEngine =\n            new shaka.media.DrmEngine(netEngine, onError, onKeyStatusChange);\n        drmEngine.configure(config.drm);\n        return drmEngine.init(manifest, true /* isOffline */);\n      }.bind(this))\n      .then(function() {\n        this.checkDestroyed_();\n        return this.createSegmentIndex_(manifest);\n      }.bind(this))\n      .then(function() {\n        this.checkDestroyed_();\n        return drmEngine.createOrLoad();\n      }.bind(this))\n      .then(function() {\n        this.checkDestroyed_();\n        return manifestParser.stop();\n      }.bind(this))\n      .then(function() {\n        this.checkDestroyed_();\n        return {manifest: manifest, drmEngine: drmEngine};\n      }.bind(this))\n      .catch(function(error) {\n        if (manifestParser)\n          return manifestParser.stop().then(function() { throw error; });\n        else\n          throw error;\n      });\n};\n\n\n/**\n * The default track selection function.\n *\n * @param {!Array.<shakaExtern.Track>} tracks\n * @return {!Array.<shakaExtern.Track>}\n * @private\n */\nshaka.offline.Storage.prototype.defaultTrackSelect_ = function(tracks) {\n  var LanguageUtils = shaka.util.LanguageUtils;\n\n  var selectedTracks = [];\n\n  // Select the highest bandwidth video track with height <= 480.\n  var videoTracks = tracks.filter(function(t) {\n    return t.type == 'video' && t.height <= 480;\n  });\n  videoTracks.sort(function(a, b) { return b.bandwidth - a.bandwidth; });\n  if (videoTracks.length)\n    selectedTracks.push(videoTracks[0]);\n\n  // Select middle bandwidth audio track with best audio pref language match.\n  var audioLangPref = LanguageUtils.normalize(\n      this.player_.getConfiguration().preferredAudioLanguage);\n  var matchTypes = [\n    LanguageUtils.MatchType.EXACT,\n    LanguageUtils.MatchType.BASE_LANGUAGE_OKAY,\n    LanguageUtils.MatchType.OTHER_SUB_LANGUAGE_OKAY\n  ];\n  var allAudioTracks =\n      tracks.filter(function(t) { return t.type == 'audio'; });\n  // For each match type, get the tracks that match the audio preference for\n  // that match type.\n  var tracksByMatchType = matchTypes.map(function(match) {\n    return allAudioTracks.filter(function(track) {\n      var lang = LanguageUtils.normalize(track.language);\n      return LanguageUtils.match(match, audioLangPref, lang);\n    });\n  });\n  // Find the best match type that has any matches, defaulting to all tracks.\n  var audioTracks = allAudioTracks;\n  for (var i = 0; i < tracksByMatchType.length; i++) {\n    if (tracksByMatchType[i].length) {\n      audioTracks = tracksByMatchType[i];\n    }\n  }\n  audioTracks.sort(function(a, b) { return a.bandwidth - b.bandwidth; });\n  if (audioTracks.length)\n    selectedTracks.push(audioTracks[Math.floor(audioTracks.length / 2)]);\n\n  // Select all text tracks with any text pref language match.\n  var textLangPref = LanguageUtils.normalize(\n      this.player_.getConfiguration().preferredTextLanguage);\n  var matchesTextPref = LanguageUtils.match.bind(\n      null, LanguageUtils.MatchType.OTHER_SUB_LANGUAGE_OKAY, textLangPref);\n  selectedTracks.push.apply(selectedTracks, tracks.filter(function(t) {\n    var language = LanguageUtils.normalize(t.language);\n    return t.type == 'text' && matchesTextPref(language);\n  }));\n\n  return selectedTracks;\n};\n\n\n/**\n * @return {shakaExtern.OfflineConfiguration}\n * @private\n */\nshaka.offline.Storage.prototype.defaultConfig_ = function() {\n  return {\n    trackSelectionCallback: this.defaultTrackSelect_.bind(this),\n    progressCallback: function(storedContent, percent) {\n      // Reference arguments to keep closure from removing it.\n      // If the argument is removed, it breaks our function length check\n      // in mergeConfigObjects_().\n      // NOTE: Chrome App Content Security Policy prohibits usage of new\n      // Function().\n      if (storedContent || percent) return null;\n    }\n  };\n};\n\n\n/**\n * Initializes the DBEngine if it is not already.\n *\n * @return {!Promise}\n * @private\n */\nshaka.offline.Storage.prototype.initIfNeeded_ = function() {\n  var scheme = shaka.offline.OfflineUtils.DB_SCHEME;\n  return this.dbEngine_.initialized() ? Promise.resolve() :\n                                        this.dbEngine_.init(scheme);\n};\n\n\n/**\n * @param {shakaExtern.Period} period\n * @private\n */\nshaka.offline.Storage.prototype.filterPeriod_ = function(period) {\n  function getFirstStreamOfType(period, tracks, contentType) {\n    var tracksOfType =\n        tracks.filter(function(track) { return track.type == contentType; });\n    if (tracksOfType.length == 0)\n      return null;\n    var data =\n        shaka.util.StreamUtils.findStreamForTrack(period, tracksOfType[0]);\n    goog.asserts.assert(\n        data, 'Could not find stream with id ' + tracksOfType[0].id);\n    return data.stream;\n  }\n\n  var StreamUtils = shaka.util.StreamUtils;\n  var activeStreams = {};\n  if (this.firstPeriodTracks_) {\n    // Use the first stream of each content type as the \"active stream\".  This\n    // is then used to filter out the streams that are not compatible with it.\n    // This ensures that in multi-Period content, all Periods have streams\n    // with compatible MIME types.\n    activeStreams = {\n      'video': getFirstStreamOfType(\n          this.manifest_.periods[0], this.firstPeriodTracks_, 'video'),\n      'audio': getFirstStreamOfType(\n          this.manifest_.periods[0], this.firstPeriodTracks_, 'audio')\n    };\n  }\n  StreamUtils.filterPeriod(this.drmEngine_, activeStreams, period);\n  StreamUtils.applyRestrictions(\n      period, this.player_.getConfiguration().restrictions,\n      /* maxHwRes */ { width: Infinity, height: Infinity });\n};\n\n\n/**\n * Cleans up the current store and destroys any objects.  This object is still\n * usable after this.\n *\n * @return {!Promise}\n * @private\n */\nshaka.offline.Storage.prototype.cleanup_ = function() {\n  var ret = this.drmEngine_ ? this.drmEngine_.destroy() : Promise.resolve();\n  this.drmEngine_ = null;\n  this.manifest_ = null;\n  this.storeInProgress_ = false;\n  this.firstPeriodTracks_ = null;\n  this.inProgressSegmentIds_ = [];\n  this.manifestId_ = -1;\n  return ret;\n};\n\n\n/**\n * Calls createSegmentIndex for all streams in the manifest.\n *\n * @param {shakaExtern.Manifest} manifest\n * @return {!Promise}\n * @private\n */\nshaka.offline.Storage.prototype.createSegmentIndex_ = function(manifest) {\n  var Functional = shaka.util.Functional;\n  var streams = manifest.periods\n      .map(function(period) { return period.streamSets; })\n      .reduce(Functional.collapseArrays, [])\n      .map(function(streamSet) { return streamSet.streams; })\n      .reduce(Functional.collapseArrays, []);\n  return Promise.all(\n      streams.map(function(stream) { return stream.createSegmentIndex(); }));\n};\n\n\n/**\n * Creates an offline 'manifest' for the real manifest.  This does not store\n * the segments yet, only adds them to the download manager through\n * createPeriod_.\n *\n * @param {string} originalManifestUri\n * @param {!Object} appMetadata\n * @return {shakaExtern.ManifestDB}\n * @private\n */\nshaka.offline.Storage.prototype.createOfflineManifest_ = function(\n    originalManifestUri, appMetadata) {\n  var periods = this.manifest_.periods.map(this.createPeriod_.bind(this));\n  var drmInfo = this.drmEngine_.getDrmInfo();\n  var sessions = this.drmEngine_.getSessionIds();\n  if (drmInfo) {\n    if (!sessions.length) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.NO_INIT_DATA_FOR_OFFLINE, originalManifestUri);\n    }\n    // Don't store init data since we have stored sessions.\n    drmInfo.initData = [];\n  }\n\n  return {\n    key: this.manifestId_,\n    originalManifestUri: originalManifestUri,\n    duration: this.duration_,\n    size: 0,\n    periods: periods,\n    sessionIds: sessions,\n    drmInfo: drmInfo,\n    appMetadata: appMetadata\n  };\n};\n\n\n/**\n * Converts a manifest Period to a database Period.  This will use the current\n * configuration to get the tracks to use, then it will search each segment\n * index and add all the segments to the download manager through createStream_.\n *\n * @param {shakaExtern.Period} period\n * @return {shakaExtern.PeriodDB}\n * @private\n */\nshaka.offline.Storage.prototype.createPeriod_ = function(period) {\n  var allTracks = shaka.util.StreamUtils.getTracks(period, null);\n  var tracks = this.config_.trackSelectionCallback(allTracks);\n  if (this.firstPeriodTracks_ == null) {\n    this.firstPeriodTracks_ = tracks;\n    // Now that the first tracks are chosen, filter again.  This ensures all\n    // Periods have compatible content types.\n    this.manifest_.periods.forEach(this.filterPeriod_.bind(this));\n  }\n\n  for (var i = tracks.length - 1; i > 0; --i) {\n    var found = false;\n    for (var j = i - 1; j >= 0; --j) {\n      if (tracks[i].type == tracks[j].type &&\n          tracks[i].kind == tracks[j].kind &&\n          tracks[i].language == tracks[j].language) {\n        shaka.log.warning(\n            'Multiple tracks of the same type/kind/language given.');\n        found = true;\n        break;\n      }\n    }\n    if (found) break;\n  }\n\n  var streams = tracks.map(function(track) {\n    var data = shaka.util.StreamUtils.findStreamForTrack(period, track);\n    goog.asserts.assert(data, 'Could not find track with id ' + track.id);\n    return this.createStream_(period, data.streamSet, data.stream);\n  }.bind(this));\n\n  return {\n    startTime: period.startTime,\n    streams: streams\n  };\n};\n\n\n/**\n * Converts a manifest stream to a database stream.  This will search the\n * segment index and add all the segments to the download manager.\n *\n * @param {shakaExtern.Period} period\n * @param {shakaExtern.StreamSet} streamSet\n * @param {shakaExtern.Stream} stream\n * @return {shakaExtern.StreamDB}\n * @private\n */\nshaka.offline.Storage.prototype.createStream_ = function(\n    period, streamSet, stream) {\n  /** @type {!Array.<shakaExtern.SegmentDB>} */\n  var segmentsDb = [];\n  var startTime = this.manifest_.presentationTimeline.getEarliestStart();\n  var endTime = startTime;\n  var i = stream.findSegmentPosition(startTime);\n  var ref = (i != null ? stream.getSegmentReference(i) : null);\n  while (ref) {\n    var id = this.dbEngine_.reserveId('segment');\n    var bandwidthSize = (ref.endTime - ref.startTime) * stream.bandwidth / 8;\n    this.downloadManager_.addSegment(\n        streamSet.type, ref, bandwidthSize, function(id, pos, streamId, data) {\n          /** @type {shakaExtern.SegmentDataDB} */\n          var dataDb = {\n            key: id,\n            data: data,\n            manifestKey: this.manifestId_,\n            streamNumber: streamId,\n            segmentNumber: pos\n          };\n          this.inProgressSegmentIds_.push(id);\n          return this.dbEngine_.insert('segment', dataDb);\n        }.bind(this, id, ref.position, stream.id));\n\n    segmentsDb.push({\n      startTime: ref.startTime,\n      endTime: ref.endTime,\n      uri: 'offline:' + this.manifestId_ + '/' + stream.id + '/' + id\n    });\n\n    endTime = ref.endTime + period.startTime;\n    ref = stream.getSegmentReference(++i);\n  }\n\n  this.duration_ = Math.max(this.duration_, (endTime - startTime));\n  var initUri = null;\n  if (stream.initSegmentReference) {\n    var id = this.dbEngine_.reserveId('segment');\n    initUri = 'offline:' + this.manifestId_ + '/' + stream.id + '/' + id;\n    this.downloadManager_.addSegment(streamSet.type,\n        stream.initSegmentReference, 0,\n        function(streamId, data) {\n          /** @type {shakaExtern.SegmentDataDB} */\n          var dataDb = {\n            key: id,\n            data: data,\n            manifestKey: this.manifestId_,\n            streamNumber: streamId,\n            segmentNumber: -1\n          };\n          this.inProgressSegmentIds_.push(id);\n          return this.dbEngine_.insert('segment', dataDb);\n        }.bind(this, stream.id));\n  }\n\n  return {\n    id: stream.id,\n    primary: streamSet.primary,\n    presentationTimeOffset: stream.presentationTimeOffset || 0,\n    contentType: streamSet.type,\n    mimeType: stream.mimeType,\n    codecs: stream.codecs,\n    frameRate: stream.frameRate,\n    kind: stream.kind,\n    language: streamSet.language,\n    width: stream.width || null,\n    height: stream.height || null,\n    initSegmentUri: initUri,\n    encrypted: stream.encrypted,\n    keyId: stream.keyId,\n    segments: segmentsDb\n  };\n};\n\n\n/**\n * Throws an error if the object is destroyed.\n * @private\n */\nshaka.offline.Storage.prototype.checkDestroyed_ = function() {\n  if (!this.player_) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.STORAGE,\n        shaka.util.Error.Code.OPERATION_ABORTED);\n  }\n};\n\n\nshaka.Player.registerSupportPlugin('offline', shaka.offline.Storage.support);\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/polyfill/all.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.polyfill.installAll');\ngoog.provide('shaka.polyfill.register');\n\n\n/**\n * @namespace shaka.polyfill\n * @summary A one-stop installer for all polyfills.\n * @see http://enwp.org/polyfill\n * @exportDoc\n */\n\n\n/**\n * Install all polyfills.\n * @export\n */\nshaka.polyfill.installAll = function() {\n  for (var i = 0; i < shaka.polyfill.polyfills_.length; ++i) {\n    shaka.polyfill.polyfills_[i]();\n  }\n};\n\n\n/**\n * Contains the polyfills that will be installed.\n * @private {!Array.<function()>}\n */\nshaka.polyfill.polyfills_ = [];\n\n\n/**\n * Registers a new polyfill to be installed.\n *\n * @param {function()} polyfill\n * @export\n */\nshaka.polyfill.register = function(polyfill) {\n  shaka.polyfill.polyfills_.push(polyfill);\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/polyfill/fullscreen.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.polyfill.Fullscreen');\n\ngoog.require('shaka.polyfill.register');\n\n\n/**\n * @namespace shaka.polyfill.Fullscreen\n *\n * @summary A polyfill to unify fullscreen APIs across browsers.\n * Many browsers have prefixed fullscreen methods on Element and document.\n * See {@link http://goo.gl/n7TYl0 Using fullscreen mode} on MDN for more\n * information.\n */\n\n\n/**\n * Install the polyfill if needed.\n */\nshaka.polyfill.Fullscreen.install = function() {\n  if (!window.Document) {\n    // Avoid errors on very old browsers.\n    return;\n  }\n\n  var proto = Element.prototype;\n  proto.requestFullscreen = proto.requestFullscreen ||\n                            proto.mozRequestFullScreen ||\n                            proto.msRequestFullscreen ||\n                            proto.webkitRequestFullscreen;\n\n  proto = Document.prototype;\n  proto.exitFullscreen = proto.exitFullscreen ||\n                         proto.mozCancelFullScreen ||\n                         proto.msExitFullscreen ||\n                         proto.webkitExitFullscreen;\n\n  if (!('fullscreenElement' in document)) {\n    Object.defineProperty(document, 'fullscreenElement', {\n      get: function() {\n        return document.mozFullScreenElement ||\n               document.msFullscreenElement ||\n               document.webkitFullscreenElement;\n      }\n    });\n    Object.defineProperty(document, 'fullscreenEnabled', {\n      get: function() {\n        return document.mozFullScreenEnabled ||\n               document.msFullscreenEnabled ||\n               document.webkitFullscreenEnabled;\n      }\n    });\n  }\n\n  var proxy = shaka.polyfill.Fullscreen.proxyEvent_;\n  document.addEventListener('webkitfullscreenchange', proxy);\n  document.addEventListener('webkitfullscreenerror', proxy);\n  document.addEventListener('mozfullscreenchange', proxy);\n  document.addEventListener('mozfullscreenerror', proxy);\n  document.addEventListener('MSFullscreenChange', proxy);\n  document.addEventListener('MSFullscreenError', proxy);\n};\n\n\n/**\n * Proxy fullscreen events after changing their name.\n * @param {!Event} event\n * @private\n */\nshaka.polyfill.Fullscreen.proxyEvent_ = function(event) {\n  var type2 = event.type.replace(/^(webkit|moz|MS)/, '').toLowerCase();\n  var event2 = new Event(type2, /** @type {EventInit} */(event));\n  event.target.dispatchEvent(event2);\n};\n\n\nshaka.polyfill.register(shaka.polyfill.Fullscreen.install);\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/polyfill/indexed_db.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.polyfill.IndexedDB');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill.register');\n\n\n/**\n * @namespace shaka.polyfill.IndexedDB\n *\n * @summary A polyfill to patch indexed db bugs.\n */\n\n\n/**\n * Install the polyfill if needed.\n */\nshaka.polyfill.IndexedDB.install = function() {\n  shaka.log.debug('IndexedDB.install');\n\n  var agent = navigator.userAgent;\n  if (agent && agent.indexOf('CrKey') >= 0) {\n    shaka.log.debug('Removing IndexedDB from ChromeCast');\n    delete window.indexedDB;\n    goog.asserts.assert(\n        !window.indexedDB, 'Failed to override window.indexedDB');\n  }\n};\n\nshaka.polyfill.register(shaka.polyfill.IndexedDB.install);\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/polyfill/mediakeys.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.polyfill.MediaKeys');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill.PatchedMediaKeysMs');\ngoog.require('shaka.polyfill.PatchedMediaKeysNop');\ngoog.require('shaka.polyfill.PatchedMediaKeysWebkit');\ngoog.require('shaka.polyfill.register');\n\n\n/**\n * @namespace shaka.polyfill.MediaKeys\n *\n * @summary A polyfill to unify EME APIs across browser versions.\n *\n * The {@link https://w3c.github.io/encrypted-media/ EME spec} is still a\n * work-in-progress.  As such, we need to provide a consistent API to the Shaka\n * Player.  Until the spec is completely stable, the API provided by this\n * polyfill may lag behind the latest spec developments.\n */\n\n\n/**\n * Install the polyfill if needed.\n */\nshaka.polyfill.MediaKeys.install = function() {\n  shaka.log.debug('MediaKeys.install');\n\n  if (!window.HTMLVideoElement) {\n    // Avoid errors on very old browsers.\n    return;\n  }\n\n  if (navigator.requestMediaKeySystemAccess &&\n      MediaKeySystemAccess.prototype.getConfiguration) {\n    shaka.log.info('Using native EME as-is.');\n  } else if (HTMLMediaElement.prototype.webkitGenerateKeyRequest) {\n    shaka.log.info('Using webkit-prefixed EME v0.1b');\n    shaka.polyfill.PatchedMediaKeysWebkit.install('webkit');\n  } else if (HTMLMediaElement.prototype['generateKeyRequest']) {\n    // There is a compiler error that would convert\n    // \"HTMLMediaElement.prototype.generateKeyRequest\" into\n    // \"HTMLMediaElement.prototype.a\". Until resolved, array access\n    // seems to work ok.\n    shaka.log.info('Using nonprefixed EME v0.1b');\n    shaka.polyfill.PatchedMediaKeysWebkit.install('');\n  } else if (window.MSMediaKeys) {\n    shaka.log.info('Using ms-prefixed EME v20140218');\n    shaka.polyfill.PatchedMediaKeysMs.install();\n  } else {\n    shaka.log.info('EME not available.');\n    shaka.polyfill.PatchedMediaKeysNop.install();\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.MediaKeys.install);\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/polyfill/mediasource.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.polyfill.MediaSource');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill.register');\n\n\n/**\n * @namespace shaka.polyfill.MediaSource\n *\n * @summary A polyfill to patch MSE bugs.\n */\n\n\n/**\n * Install the polyfill if needed.\n */\nshaka.polyfill.MediaSource.install = function() {\n  shaka.log.debug('MediaSource.install');\n\n  if (!window.MediaSource) {\n    shaka.log.info('No MSE implementation available.');\n    return;\n  }\n\n  // Detection is complicated by the fact that Safari does not expose\n  // SourceBuffer on window.  So we can't detect missing features by accessing\n  // SourceBuffer.prototype.  That is why we use navigator to detect Safari and\n  // particular versions of it.\n  var vendor = navigator.vendor;\n  var version = navigator.appVersion;\n  if (!vendor || !version || vendor.indexOf('Apple') < 0) {\n    shaka.log.info('Using native MSE as-is.');\n    return;\n  }\n\n  if (version.indexOf('Version/8') >= 0) {\n    // Safari 8 does not implement appendWindowEnd.  If we ignore the\n    // incomplete MSE implementation, some content (especially multi-period)\n    // will fail to play correctly.  The best we can do is blacklist Safari 8.\n    shaka.log.info('Blacklisting Safari 8 MSE.');\n    shaka.polyfill.MediaSource.blacklist_();\n  } else if (version.indexOf('Version/9') >= 0) {\n    shaka.log.info('Patching Safari 9 MSE bugs.');\n    // Safari 9 does not correctly implement abort() on SourceBuffer.\n    // Calling abort() causes a decoder failure, rather than resetting the\n    // decode timestamp as called for by the spec.\n    // Bug filed: http://goo.gl/UZ2rPp\n    shaka.polyfill.MediaSource.stubAbort_();\n  } else if (version.indexOf('Version/10') >= 0) {\n    shaka.log.info('Patching Safari 10 MSE bugs.');\n    // Safari 10 does not correctly implement abort() on SourceBuffer.\n    // Calling abort() before appending a segment causes that segment to be\n    // incomplete in buffer.\n    // Bug filed: https://goo.gl/rC3CLj\n    shaka.polyfill.MediaSource.stubAbort_();\n    // Safari 10 fires spurious 'updateend' events after endOfStream().\n    // Bug filed: https://goo.gl/qCeTZr\n    shaka.polyfill.MediaSource.patchEndOfStreamEvents_();\n  } else {\n    shaka.log.info('Using native MSE as-is.');\n  }\n};\n\n\n/**\n * Blacklist the current browser by making MediaSourceEngine.isBrowserSupported\n * fail later.\n *\n * @private\n */\nshaka.polyfill.MediaSource.blacklist_ = function() {\n  window['MediaSource'] = null;\n};\n\n\n/**\n * Stub out abort().  On some buggy MSE implementations, calling abort() causes\n * various problems.\n *\n * @private\n */\nshaka.polyfill.MediaSource.stubAbort_ = function() {\n  var addSourceBuffer = MediaSource.prototype.addSourceBuffer;\n  MediaSource.prototype.addSourceBuffer = function() {\n    var sourceBuffer = addSourceBuffer.apply(this, arguments);\n    sourceBuffer.abort = function() {};  // Stub out for buggy implementations.\n    return sourceBuffer;\n  };\n};\n\n\n/**\n * Patch endOfStream() to get rid of 'updateend' events that should not fire.\n * These extra events confuse MediaSourceEngine, which relies on correct events\n * to manage SourceBuffer state.\n *\n * @private\n */\nshaka.polyfill.MediaSource.patchEndOfStreamEvents_ = function() {\n  var endOfStream = MediaSource.prototype.endOfStream;\n  MediaSource.prototype.endOfStream = function() {\n    // This bug manifests only when endOfStream() results in the truncation\n    // of the MediaSource's duration.  So first we must calculate what the\n    // new duration will be.\n    var newDuration = 0;\n    for (var i = 0; i < this.sourceBuffers.length; ++i) {\n      var buffer = this.sourceBuffers[i];\n      var bufferEnd = buffer.buffered.end(buffer.buffered.length - 1);\n      newDuration = Math.max(newDuration, bufferEnd);\n    }\n\n    // If the duration is going to be reduced, suppress the next 'updateend'\n    // event on each SourceBuffer.\n    if (!isNaN(this.duration) &&\n        newDuration < this.duration) {\n      this.ignoreUpdateEnd_ = true;\n      for (var i = 0; i < this.sourceBuffers.length; ++i) {\n        var buffer = this.sourceBuffers[i];\n        buffer.eventSuppressed_ = false;\n      }\n    }\n\n    return endOfStream.apply(this, arguments);\n  };\n\n  var addSourceBuffer = MediaSource.prototype.addSourceBuffer;\n  MediaSource.prototype.addSourceBuffer = function() {\n    // After adding a new source buffer, add an event listener to allow us to\n    // suppress events.\n    var sourceBuffer = addSourceBuffer.apply(this, arguments);\n    sourceBuffer.mediaSource_ = this;\n    sourceBuffer.addEventListener('updateend',\n        shaka.polyfill.MediaSource.ignoreUpdateEnd_, false);\n\n    if (!this.cleanUpHandlerInstalled_) {\n      // If we haven't already, install an event listener to allow us to clean\n      // up listeners when MediaSource is torn down.\n      this.addEventListener('sourceclose',\n          shaka.polyfill.MediaSource.cleanUpListeners_, false);\n      this.cleanUpHandlerInstalled_ = true;\n    }\n    return sourceBuffer;\n  };\n};\n\n\n/**\n * An event listener for 'updateend' which selectively suppresses the events.\n *\n * @see shaka.polyfill.MediaSource.patchEndOfStreamEvents_\n *\n * @param {Event} event\n * @private\n */\nshaka.polyfill.MediaSource.ignoreUpdateEnd_ = function(event) {\n  var sourceBuffer = event.target;\n  var mediaSource = sourceBuffer.mediaSource_;\n\n  if (mediaSource.ignoreUpdateEnd_) {\n    event.preventDefault();\n    event.stopPropagation();\n    event.stopImmediatePropagation();\n    sourceBuffer.eventSuppressed_ = true;\n\n    for (var i = 0; i < mediaSource.sourceBuffers.length; ++i) {\n      var buffer = mediaSource.sourceBuffers[i];\n      if (buffer.eventSuppressed_ == false) {\n        // More events need to be suppressed.\n        return;\n      }\n    }\n\n    // All events have been suppressed, all buffers are out of 'updating'\n    // mode.  Stop suppressing events.\n    mediaSource.ignoreUpdateEnd_ = false;\n  }\n};\n\n\n/**\n * An event listener for 'sourceclose' which cleans up listeners for 'updateend'\n * to avoid memory leaks.\n *\n * @see shaka.polyfill.MediaSource.patchEndOfStreamEvents_\n * @see shaka.polyfill.MediaSource.ignoreUpdateEnd_\n *\n * @param {Event} event\n * @private\n */\nshaka.polyfill.MediaSource.cleanUpListeners_ = function(event) {\n  var mediaSource = event.target;\n  for (var i = 0; i < mediaSource.sourceBuffers.length; ++i) {\n    var buffer = mediaSource.sourceBuffers[i];\n    buffer.removeEventListener('updateend',\n        shaka.polyfill.MediaSource.ignoreUpdateEnd_, false);\n  }\n  mediaSource.removeEventListener('sourceclose',\n      shaka.polyfill.MediaSource.cleanUpListeners_, false);\n};\n\n\nshaka.polyfill.register(shaka.polyfill.MediaSource.install);\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/polyfill/patchedmediakeys_ms.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.polyfill.PatchedMediaKeysMs');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.ArrayUtils');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.Pssh');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * Install a polyfill to implement {@link http://goo.gl/blgtZZ EME draft\n * 12 March 2015} on top of ms-prefixed\n * {@link http://www.w3.org/TR/2014/WD-encrypted-media-20140218/ EME v20140218}.\n */\nshaka.polyfill.PatchedMediaKeysMs.install = function() {\n  shaka.log.debug('PatchedMediaKeysMs.install');\n\n  // Alias\n  var PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n\n  // Construct fake key ID.  This is not done at load-time to avoid exceptions\n  // on unsupported browsers.  This particular fake key ID was suggested in\n  // w3c/encrypted-media#32.\n  PatchedMediaKeysMs.MediaKeyStatusMap.KEY_ID_ = (new Uint8Array([0])).buffer;\n\n  // Delete mediaKeys to work around strict mode compatibility issues.\n  delete HTMLMediaElement.prototype['mediaKeys'];\n  // Work around read-only declaration for mediaKeys by using a string.\n  HTMLMediaElement.prototype['mediaKeys'] = null;\n  HTMLMediaElement.prototype.setMediaKeys = PatchedMediaKeysMs.setMediaKeys;\n\n  // Install patches\n  window.MediaKeys = PatchedMediaKeysMs.MediaKeys;\n  window.MediaKeySystemAccess = PatchedMediaKeysMs.MediaKeySystemAccess;\n  navigator.requestMediaKeySystemAccess =\n      PatchedMediaKeysMs.requestMediaKeySystemAccess;\n};\n\n\n/**\n * An implementation of navigator.requestMediaKeySystemAccess.\n * Retrieve a MediaKeySystemAccess object.\n *\n * @this {!Navigator}\n * @param {string} keySystem\n * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n * @return {!Promise.<!MediaKeySystemAccess>}\n */\nshaka.polyfill.PatchedMediaKeysMs.requestMediaKeySystemAccess =\n    function(keySystem, supportedConfigurations) {\n  shaka.log.debug('PatchedMediaKeysMs.requestMediaKeySystemAccess');\n  goog.asserts.assert(this == navigator,\n                      'bad \"this\" for requestMediaKeySystemAccess');\n\n  // Alias.\n  var PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n  try {\n    var access = new PatchedMediaKeysMs.MediaKeySystemAccess(\n        keySystem, supportedConfigurations);\n    return Promise.resolve(/** @type {!MediaKeySystemAccess} */ (access));\n  } catch (exception) {\n    return Promise.reject(exception);\n  }\n};\n\n\n\n/**\n * An implementation of MediaKeySystemAccess.\n *\n * @constructor\n * @struct\n * @param {string} keySystem\n * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n * @implements {MediaKeySystemAccess}\n * @throws {Error} if the key system is not supported.\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySystemAccess =\n    function(keySystem, supportedConfigurations) {\n  shaka.log.debug('PatchedMediaKeysMs.MediaKeySystemAccess');\n\n  /** @type {string} */\n  this.keySystem = keySystem;\n\n  /** @private {!MediaKeySystemConfiguration} */\n  this.configuration_;\n\n  var allowPersistentState = true;\n\n  var success = false;\n  for (var i = 0; i < supportedConfigurations.length; ++i) {\n    var cfg = supportedConfigurations[i];\n\n    // Create a new config object and start adding in the pieces which we\n    // find support for.  We will return this from getConfiguration() if\n    // asked.\n    /** @type {!MediaKeySystemConfiguration} */\n    var newCfg = {\n      'audioCapabilities': [],\n      'videoCapabilities': [],\n      // It is technically against spec to return these as optional, but we\n      // don't truly know their values from the prefixed API:\n      'persistentState': 'optional',\n      'distinctiveIdentifier': 'optional',\n      // Pretend the requested init data types are supported, since we don't\n      // really know that either:\n      'initDataTypes': cfg.initDataTypes,\n      'sessionTypes': ['temporary'],\n      'label': cfg.label\n    };\n\n    // PatchedMediaKeysMs tests for key system availability through\n    // MSMediaKeys.isTypeSupported\n    var ranAnyTests = false;\n    if (cfg.audioCapabilities) {\n      for (var j = 0; j < cfg.audioCapabilities.length; ++j) {\n        var cap = cfg.audioCapabilities[j];\n        if (cap.contentType) {\n          ranAnyTests = true;\n          var contentType = cap.contentType.split(';')[0];\n          if (MSMediaKeys.isTypeSupported(this.keySystem, contentType)) {\n            newCfg.audioCapabilities.push(cap);\n            success = true;\n          }\n        }\n      }\n    }\n    if (cfg.videoCapabilities) {\n      for (var j = 0; j < cfg.videoCapabilities.length; ++j) {\n        var cap = cfg.videoCapabilities[j];\n        if (cap.contentType) {\n          ranAnyTests = true;\n          var contentType = cap.contentType.split(';')[0];\n          if (MSMediaKeys.isTypeSupported(this.keySystem, contentType)) {\n            newCfg.videoCapabilities.push(cap);\n            success = true;\n          }\n        }\n      }\n    }\n\n    if (!ranAnyTests) {\n      // If no specific types were requested, we check all common types to find\n      // out if the key system is present at all.\n      success = MSMediaKeys.isTypeSupported(this.keySystem, 'video/mp4');\n    }\n    if (cfg.persistentState == 'required') {\n      if (allowPersistentState) {\n        newCfg.persistentState = 'required';\n        newCfg.sessionTypes = ['persistent-license'];\n      } else {\n        success = false;\n      }\n    }\n\n    if (success) {\n      this.configuration_ = newCfg;\n      return;\n    }\n  }  // for each cfg in supportedConfigurations\n\n  // As per the spec, this should be a DOMException, but\n  // there is not a public constructor for this\n  var unsupportedKeySystemError = new Error('Unsupported keySystem');\n  unsupportedKeySystemError.name = 'NotSupportedError';\n  unsupportedKeySystemError.code = DOMException.NOT_SUPPORTED_ERR;\n  throw unsupportedKeySystemError;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySystemAccess.prototype.\n    createMediaKeys = function() {\n  shaka.log.debug('PatchedMediaKeysMs.MediaKeySystemAccess.createMediaKeys');\n\n  // Alias\n  var PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n\n  var mediaKeys = new PatchedMediaKeysMs.MediaKeys(this.keySystem);\n  return Promise.resolve(/** @type {!MediaKeys} */ (mediaKeys));\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySystemAccess.prototype.\n    getConfiguration = function() {\n  shaka.log.debug('PatchedMediaKeysMs.MediaKeySystemAccess.getConfiguration');\n  return this.configuration_;\n};\n\n\n/**\n * An implementation of HTMLMediaElement.prototype.setMediaKeys.\n * Attach a MediaKeys object to the media element.\n *\n * @this {!HTMLMediaElement}\n * @param {MediaKeys} mediaKeys\n * @return {!Promise}\n */\nshaka.polyfill.PatchedMediaKeysMs.setMediaKeys = function(mediaKeys) {\n  shaka.log.debug('PatchedMediaKeysMs.setMediaKeys');\n  goog.asserts.assert(this instanceof HTMLMediaElement,\n                      'bad \"this\" for setMediaKeys');\n\n  // Alias\n  var PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n\n  var newMediaKeys =\n      /** @type {shaka.polyfill.PatchedMediaKeysMs.MediaKeys} */ (\n      mediaKeys);\n  var oldMediaKeys =\n      /** @type {shaka.polyfill.PatchedMediaKeysMs.MediaKeys} */ (\n      this.mediaKeys);\n\n  if (oldMediaKeys && oldMediaKeys != newMediaKeys) {\n    goog.asserts.assert(oldMediaKeys instanceof PatchedMediaKeysMs.MediaKeys,\n                        'non-polyfill instance of oldMediaKeys');\n    // Have the old MediaKeys stop listening to events on the video tag.\n    oldMediaKeys.setMedia(null);\n  }\n\n  delete this['mediaKeys'];  // in case there is an existing getter\n  this['mediaKeys'] = mediaKeys;  // work around read-only declaration\n\n  if (newMediaKeys) {\n    goog.asserts.assert(newMediaKeys instanceof PatchedMediaKeysMs.MediaKeys,\n                        'non-polyfill instance of newMediaKeys');\n    return newMediaKeys.setMedia(this);\n  }\n\n  return Promise.resolve();\n};\n\n\n\n/**\n * An implementation of MediaKeys.\n *\n * @constructor\n * @struct\n * @param {string} keySystem\n * @implements {MediaKeys}\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeys = function(keySystem) {\n  shaka.log.debug('PatchedMediaKeysMs.MediaKeys');\n\n  /** @private {!MSMediaKeys} */\n  this.nativeMediaKeys_ = new MSMediaKeys(keySystem);\n\n  /** @private {!shaka.util.EventManager} */\n  this.eventManager_ = new shaka.util.EventManager();\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeys.prototype.\n    createSession = function(opt_sessionType) {\n  shaka.log.debug('PatchedMediaKeysMs.MediaKeys.createSession');\n\n  var sessionType = opt_sessionType || 'temporary';\n  // For now, only 'temporary' type is supported\n  if (sessionType != 'temporary') {\n    throw new TypeError('Session type ' + opt_sessionType +\n        ' is unsupported on this platform.');\n  }\n\n  // Alias\n  var PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n\n  return new PatchedMediaKeysMs.MediaKeySession(\n      this.nativeMediaKeys_, sessionType);\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeys.prototype.\n    setServerCertificate = function(serverCertificate) {\n  shaka.log.debug('PatchedMediaKeysMs.MediaKeys.setServerCertificate');\n\n  // There is no equivalent in PatchedMediaKeysMs, so return failure.\n  return Promise.reject(new Error('setServerCertificate not supported on ' +\n      'this platform.'));\n};\n\n\n/**\n * @param {HTMLMediaElement} media\n * @protected\n * @return {!Promise}\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeys.prototype.\n    setMedia = function(media) {\n\n  // Alias\n  var PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n\n  // Remove any old listeners.\n  this.eventManager_.removeAll();\n\n  // It is valid for media to be null, it's used to flag that event handlers\n  // need to be cleaned up\n  if (!media) {\n    return Promise.resolve();\n  }\n\n  // Intercept and translate these prefixed EME events.\n  this.eventManager_.listen(media, 'msneedkey',\n      /** @type {shaka.util.EventManager.ListenerType} */\n      (PatchedMediaKeysMs.onMsNeedKey_));\n\n  var self = this;\n  function setMediaKeysDeferred() {\n    media.msSetMediaKeys(self.nativeMediaKeys_);\n    media.removeEventListener('loadedmetadata', setMediaKeysDeferred);\n  }\n\n  // Wrap native HTMLMediaElement.msSetMediaKeys with Promise\n  try {\n    // IE11/Edge requires that readyState >=1 before mediaKeys can be set, so\n    // check this and wait for loadedmetadata if we are not in the correct state\n    if (media.readyState >= 1) {\n      media.msSetMediaKeys(this.nativeMediaKeys_);\n    } else {\n      media.addEventListener('loadedmetadata', setMediaKeysDeferred);\n    }\n\n    return Promise.resolve();\n\n  } catch (exception) {\n    return Promise.reject(exception);\n  }\n};\n\n\n\n/**\n * An implementation of MediaKeySession.\n *\n * @constructor\n * @struct\n * @param {MSMediaKeys} nativeMediaKeys\n * @param {string} sessionType\n * @implements {MediaKeySession}\n * @extends {shaka.util.FakeEventTarget}\n */\nshaka.polyfill.PatchedMediaKeysMs.\n    MediaKeySession = function(nativeMediaKeys, sessionType) {\n  shaka.log.debug('PatchedMediaKeysMs.MediaKeySession');\n  shaka.util.FakeEventTarget.call(this);\n\n  // Native MediaKeySession, which will be created in generateRequest\n  /** @private {MSMediaKeySession} */\n  this.nativeMediaKeySession_ = null;\n\n  /** @private {MSMediaKeys} */\n  this.nativeMediaKeys_ = nativeMediaKeys;\n\n  // Promises that are resolved later\n  /** @private {Promise} */\n  this.generateRequestPromise_ = null;\n\n  /** @private {Promise} */\n  this.updatePromise_ = null;\n\n  /** @private {!shaka.util.EventManager} */\n  this.eventManager_ = new shaka.util.EventManager();\n\n  /** @type {string} */\n  this.sessionId = '';\n\n  /** @type {number} */\n  this.expiration = NaN;\n\n  /** @type {!shaka.util.PublicPromise} */\n  this.closed = new shaka.util.PublicPromise();\n\n  /** @type {!MediaKeyStatusMap} */\n  this.keyStatuses =\n      new shaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap();\n};\ngoog.inherits(shaka.polyfill.PatchedMediaKeysMs.MediaKeySession,\n    shaka.util.FakeEventTarget);\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.\n    generateRequest = function(initDataType, initData) {\n  shaka.log.debug('PatchedMediaKeysMs.MediaKeySession.generateRequest');\n\n  this.generateRequestPromise_ = new shaka.util.PublicPromise();\n\n  try {\n    // This EME spec version requires a MIME content type as the 1st param\n    // to createSession, but doesn't seem to matter what the value is.\n\n    // NOTE: IE11 takes either Uint8Array or ArrayBuffer, but Edge 12 only\n    // accepts Uint8Array.\n    this.nativeMediaKeySession_ = this.nativeMediaKeys_\n        .createSession('video/mp4', new Uint8Array(initData), null);\n\n    // Attach session event handlers here\n    this.eventManager_.listen(this.nativeMediaKeySession_, 'mskeymessage',\n        /** @type {shaka.util.EventManager.ListenerType} */\n        (this.onMsKeyMessage_.bind(this)));\n    this.eventManager_.listen(this.nativeMediaKeySession_, 'mskeyadded',\n        /** @type {shaka.util.EventManager.ListenerType} */\n        (this.onMsKeyAdded_.bind(this)));\n    this.eventManager_.listen(this.nativeMediaKeySession_, 'mskeyerror',\n        /** @type {shaka.util.EventManager.ListenerType} */\n        (this.onMsKeyError_.bind(this)));\n\n    this.updateKeyStatus_('status-pending');\n  } catch (exception) {\n    this.generateRequestPromise_.reject(exception);\n  }\n\n  return this.generateRequestPromise_;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.\n    load = function() {\n  shaka.log.debug('PatchedMediaKeysMs.MediaKeySession.load');\n\n  return Promise.reject(new Error('MediaKeySession.load not yet supported'));\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.\n    update = function(response) {\n  shaka.log.debug('PatchedMediaKeysMs.MediaKeySession.update');\n\n  this.updatePromise_ = new shaka.util.PublicPromise();\n\n  try {\n    // Pass through to the native session.\n    // NOTE: IE11 takes either Uint8Array or ArrayBuffer, but Edge 12 only\n    // accepts Uint8Array.\n    this.nativeMediaKeySession_.update(new Uint8Array(response));\n  } catch (exception) {\n    this.updatePromise_.reject(exception);\n  }\n\n  return this.updatePromise_;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.\n    close = function() {\n  shaka.log.debug('PatchedMediaKeysMs.MediaKeySession.close');\n\n  try {\n    // Pass through to the native session\n    // NOTE: IE seems to have spec discrepancy here - v2010218 should have\n    // MediaKeySession.release, but actually uses \"close\". The next version\n    // of the spec is the initial Promise based one, so it's not the target spec\n    // either.\n    this.nativeMediaKeySession_.close();\n\n    this.closed.resolve();\n    this.eventManager_.removeAll();\n  } catch (exception) {\n    this.closed.reject(exception);\n  }\n\n  return this.closed;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.\n    remove = function() {\n  shaka.log.debug('PatchedMediaKeysMs.MediaKeySession.remove');\n\n  return Promise.reject(new Error('MediaKeySession.remove is only ' +\n      'applicable for persistent licenses, which are not supported on ' +\n      'this platform'));\n};\n\n\n/**\n * Handler for the native media elements msNeedKey event.\n *\n * @this {!HTMLMediaElement}\n * @param {!MediaKeyEvent} event\n * @private\n */\nshaka.polyfill.PatchedMediaKeysMs.onMsNeedKey_ = function(event) {\n  shaka.log.debug('PatchedMediaKeysMs.onMsNeedKey_', event);\n\n  // Alias\n  var PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n\n  // NOTE: Because \"this\" is a real EventTarget, on IE, the event we dispatch\n  // here must also be a real Event.\n  var event2 = /** @type {!CustomEvent} */(document.createEvent('CustomEvent'));\n  event2.initCustomEvent('encrypted', false, false, null);\n  event2.initDataType = 'cenc';\n  event2.initData = PatchedMediaKeysMs.NormaliseInitData_(event.initData);\n\n  this.dispatchEvent(event2);\n};\n\n\n/**\n * Normalise the initData array. This is to apply browser specific work-arounds,\n * e.g. removing duplicates which appears to occur intermittently when the\n * native msneedkey event fires (i.e. event.initData contains dupes).\n *\n * @param {?Uint8Array} initData\n * @private\n * @return {?Uint8Array}\n */\nshaka.polyfill.PatchedMediaKeysMs.\n    NormaliseInitData_ = function(initData) {\n  if (!initData) {\n    return initData;\n  }\n\n  var pssh = new shaka.util.Pssh(initData);\n\n  // If there is only a single pssh, return the original array\n  if (pssh.dataBoundaries.length <= 1) {\n    return initData;\n  }\n\n  var unfilteredInitDatas = [];\n  for (var i = 0; i < pssh.dataBoundaries.length; i++) {\n    var currPssh = initData.subarray(\n        pssh.dataBoundaries[i].start,\n        pssh.dataBoundaries[i].end + 1); // end is exclusive, hence the +1\n\n    unfilteredInitDatas.push(currPssh);\n  }\n\n  // Dedupe psshData\n  var dedupedInitDatas = shaka.util.ArrayUtils.removeDuplicates(\n      unfilteredInitDatas,\n      shaka.polyfill.PatchedMediaKeysMs.compareInitDatas_);\n\n  var targetLength = 0;\n  for (var i = 0; i < dedupedInitDatas.length; i++) {\n    targetLength += dedupedInitDatas[i].length;\n  }\n\n  // Concat array of Uint8Arrays back into a single Uint8Array\n  var normalisedInitData = new Uint8Array(targetLength);\n  var offset = 0;\n  for (var i = 0; i < dedupedInitDatas.length; i++) {\n    normalisedInitData.set(dedupedInitDatas[i], offset);\n    offset += dedupedInitDatas[i].length;\n  }\n\n  return normalisedInitData;\n};\n\n\n/**\n * @param {!Uint8Array} initDataA\n * @param {!Uint8Array} initDataB\n * @return {boolean}\n * @private\n */\nshaka.polyfill.PatchedMediaKeysMs.compareInitDatas_ =\n    function(initDataA, initDataB) {\n  return shaka.util.Uint8ArrayUtils.equal(initDataA, initDataB);\n};\n\n\n/**\n * Handler for the native keymessage event on MSMediaKeySession.\n *\n * @param {!MediaKeyEvent} event\n * @private\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.\n    onMsKeyMessage_ = function(event) {\n  shaka.log.debug('PatchedMediaKeysMs.onMsKeyMessage_', event);\n\n  // We can now resolve this.generateRequestPromise (it should be non-null)\n  goog.asserts.assert(this.generateRequestPromise_,\n                      'generateRequestPromise_ not set in onMsKeyMessage_');\n  if (this.generateRequestPromise_) {\n    this.generateRequestPromise_.resolve();\n    this.generateRequestPromise_ = null;\n  }\n\n  var isNew = this.keyStatuses.getStatus() == undefined;\n\n  var event2 = new shaka.util.FakeEvent('message', {\n    messageType: isNew ? 'licenserequest' : 'licenserenewal',\n    message: event.message.buffer\n  });\n\n  this.dispatchEvent(event2);\n};\n\n\n/**\n * Handler for the native keyadded event on MSMediaKeySession.\n *\n * @param {!MediaKeyEvent} event\n * @private\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.\n    onMsKeyAdded_ = function(event) {\n  shaka.log.debug('PatchedMediaKeysMs.onMsKeyAdded_', event);\n\n  // PlayReady's concept of persistent licenses makes emulation difficult here.\n  // A license policy can say that the license persists, which causes the CDM to\n  // store it for use in a later session.  The result is that in IE11, the CDM\n  // fires 'mskeyadded' without ever firing 'mskeymessage'.\n  if (this.generateRequestPromise_) {\n    shaka.log.debug('Simulating completion for a PR persistent license.');\n    goog.asserts.assert(!this.updatePromise_,\n        'updatePromise_ and generateRequestPromise_ set in onMsKeyAdded_');\n    this.updateKeyStatus_('usable');\n    this.generateRequestPromise_.resolve();\n    this.generateRequestPromise_ = null;\n    return;\n  }\n\n  // We can now resolve this.updatePromise (it should be non-null)\n  goog.asserts.assert(this.updatePromise_,\n                      'updatePromise_ not set in onMsKeyAdded_');\n  if (this.updatePromise_) {\n    this.updateKeyStatus_('usable');\n    this.updatePromise_.resolve();\n    this.updatePromise_ = null;\n  }\n};\n\n\n/**\n * Handler for the native keyerror event on MSMediaKeySession.\n *\n * @param {!MediaKeyEvent} event\n * @private\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.\n    onMsKeyError_ = function(event) {\n  shaka.log.debug('PatchedMediaKeysMs.onMsKeyError_', event);\n\n  var error = new Error('EME PatchedMediaKeysMs key error');\n  error.errorCode = this.nativeMediaKeySession_.error;\n\n  if (this.generateRequestPromise_ != null) {\n    this.generateRequestPromise_.reject(error);\n    this.generateRequestPromise_ = null;\n  } else if (this.updatePromise_ != null) {\n    this.updatePromise_.reject(error);\n    this.updatePromise_ = null;\n  } else {\n    /*\n    Unexpected error - map native codes to standardised key statuses.\n    Possible values of this.nativeMediaKeySession_.error.code\n\n    MS_MEDIA_KEYERR_UNKNOWN        = 1\n    MS_MEDIA_KEYERR_CLIENT         = 2\n    MS_MEDIA_KEYERR_SERVICE        = 3\n    MS_MEDIA_KEYERR_OUTPUT         = 4\n    MS_MEDIA_KEYERR_HARDWARECHANGE = 5\n    MS_MEDIA_KEYERR_DOMAIN         = 6\n    */\n\n    switch (this.nativeMediaKeySession_.error.code) {\n      case MSMediaKeyError.MS_MEDIA_KEYERR_OUTPUT:\n      case MSMediaKeyError.MS_MEDIA_KEYERR_HARDWARECHANGE:\n        this.updateKeyStatus_('output-not-allowed');\n      default:\n        this.updateKeyStatus_('internal-error');\n    }\n  }\n};\n\n\n/**\n * Update key status and dispatch a 'keystatuseschange' event.\n *\n * @param {string} status\n * @private\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype.\n    updateKeyStatus_ = function(status) {\n  this.keyStatuses.setStatus(status);\n  var event = new shaka.util.FakeEvent('keystatuseschange');\n  this.dispatchEvent(event);\n};\n\n\n\n/**\n * An implementation of MediaKeyStatusMap.\n * This fakes a map with a single key ID.\n *\n * @constructor\n * @struct\n * @implements {MediaKeyStatusMap}\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap = function() {\n  /**\n   * @type {number}\n   */\n  this.size = 0;\n\n  /**\n   * @private {string|undefined}\n   */\n  this.status_ = undefined;\n};\n\n\n/**\n * @const {!ArrayBuffer}\n * @private\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.KEY_ID_;\n\n\n/**\n * An internal method used by the session to set key status.\n * @param {string|undefined} status\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.prototype.\n    setStatus = function(status) {\n  this.size = status == undefined ? 0 : 1;\n  this.status_ = status;\n};\n\n\n/**\n * An internal method used by the session to get key status.\n * @return {string|undefined}\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.prototype.\n    getStatus = function() {\n  return this.status_;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.prototype.\n    forEach = function(fn) {\n  if (this.status_) {\n    var fakeKeyId =\n        shaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.KEY_ID_;\n    fn(this.status_, fakeKeyId);\n  }\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.prototype.\n    get = function(keyId) {\n  if (this.has(keyId)) {\n    return this.status_;\n  }\n  return undefined;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.prototype.\n    has = function(keyId) {\n  var fakeKeyId =\n      shaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.KEY_ID_;\n  if (this.status_ &&\n      shaka.util.Uint8ArrayUtils.equal(\n          new Uint8Array(keyId), new Uint8Array(fakeKeyId))) {\n    return true;\n  }\n  return false;\n};\n\n\n/** @suppress {missingReturn} */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.prototype.\n    entries = function() {\n  goog.asserts.assert(false, 'Not used!  Provided only for compiler.');\n};\n\n\n/** @suppress {missingReturn} */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.prototype.\n    keys = function() {\n  goog.asserts.assert(false, 'Not used!  Provided only for compiler.');\n};\n\n\n/** @suppress {missingReturn} */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.prototype.\n    values = function() {\n  goog.asserts.assert(false, 'Not used!  Provided only for compiler.');\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/polyfill/patchedmediakeys_nop.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.polyfill.PatchedMediaKeysNop');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\n\n\n/**\n * Install a polyfill to stub out {@link http://goo.gl/blgtZZ EME draft\n * 12 March 2015} on browsers without EME.  All methods will fail.\n */\nshaka.polyfill.PatchedMediaKeysNop.install = function() {\n  shaka.log.debug('PatchedMediaKeysNop.install');\n\n  // Alias.\n  var PatchedMediaKeysNop = shaka.polyfill.PatchedMediaKeysNop;\n\n  // Install patches.\n  navigator.requestMediaKeySystemAccess =\n      PatchedMediaKeysNop.requestMediaKeySystemAccess;\n  // Delete mediaKeys to work around strict mode compatibility issues.\n  delete HTMLMediaElement.prototype['mediaKeys'];\n  // Work around read-only declaration for mediaKeys by using a string.\n  HTMLMediaElement.prototype['mediaKeys'] = null;\n  HTMLMediaElement.prototype.setMediaKeys = PatchedMediaKeysNop.setMediaKeys;\n  // These are not usable, but allow Player.isBrowserSupported to pass.\n  window.MediaKeys = PatchedMediaKeysNop.MediaKeys;\n  window.MediaKeySystemAccess = PatchedMediaKeysNop.MediaKeySystemAccess;\n};\n\n\n/**\n * An implementation of navigator.requestMediaKeySystemAccess.\n * Retrieve a MediaKeySystemAccess object.\n *\n * @this {!Navigator}\n * @param {string} keySystem\n * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n * @return {!Promise.<!MediaKeySystemAccess>}\n */\nshaka.polyfill.PatchedMediaKeysNop.requestMediaKeySystemAccess =\n    function(keySystem, supportedConfigurations) {\n  shaka.log.debug('PatchedMediaKeysNop.requestMediaKeySystemAccess');\n  goog.asserts.assert(this == navigator,\n                      'bad \"this\" for requestMediaKeySystemAccess');\n\n\n  return Promise.reject(new Error(\n      'The key system specified is not supported.'));\n};\n\n\n/**\n * An implementation of HTMLMediaElement.prototype.setMediaKeys.\n * Attach a MediaKeys object to the media element.\n *\n * @this {!HTMLMediaElement}\n * @param {MediaKeys} mediaKeys\n * @return {!Promise}\n */\nshaka.polyfill.PatchedMediaKeysNop.setMediaKeys = function(mediaKeys) {\n  shaka.log.debug('PatchedMediaKeysNop.setMediaKeys');\n  goog.asserts.assert(this instanceof HTMLMediaElement,\n                      'bad \"this\" for setMediaKeys');\n\n  if (mediaKeys == null) {\n    return Promise.resolve();\n  }\n\n  return Promise.reject(new Error('MediaKeys not supported.'));\n};\n\n\n\n/**\n * An unusable constructor for MediaKeys.\n * @constructor\n * @struct\n * @implements {MediaKeys}\n */\nshaka.polyfill.PatchedMediaKeysNop.MediaKeys = function() {\n  throw new TypeError('Illegal constructor.');\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysNop.MediaKeys.prototype.createSession =\n    function() {};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysNop.MediaKeys.prototype.setServerCertificate =\n    function() {};\n\n\n\n/**\n * An unusable constructor for MediaKeySystemAccess.\n * @constructor\n * @struct\n * @implements {MediaKeySystemAccess}\n */\nshaka.polyfill.PatchedMediaKeysNop.MediaKeySystemAccess = function() {\n  throw new TypeError('Illegal constructor.');\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysNop.MediaKeySystemAccess.prototype.\n    getConfiguration = function() {};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysNop.MediaKeySystemAccess.prototype.\n    createMediaKeys = function() {};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysNop.MediaKeySystemAccess.prototype.\n    keySystem;\n\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/polyfill/patchedmediakeys_webkit.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.polyfill.PatchedMediaKeysWebkit');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * Store api prefix.\n *\n * @private {string}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.prefix_ = '';\n\n\n/**\n * Install a polyfill to implement {@link http://goo.gl/blgtZZ EME draft\n * 12 March 2015} on top of webkit-prefixed\n * {@link http://goo.gl/FSpoAo EME v0.1b}.\n *\n * @param {string} prefix\n */\nshaka.polyfill.PatchedMediaKeysWebkit.install = function(prefix) {\n  shaka.log.debug('PatchedMediaKeysWebkit.install');\n\n  // Alias.\n  var PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n  PatchedMediaKeysWebkit.prefix_ = prefix;\n  var prefixApi = PatchedMediaKeysWebkit.prefixApi_;\n\n  goog.asserts.assert(\n      HTMLMediaElement.prototype[prefixApi('generateKeyRequest')],\n                      'PatchedMediaKeysWebkit APIs not available!');\n\n  // Construct fake key ID.  This is not done at load-time to avoid exceptions\n  // on unsupported browsers.  This particular fake key ID was suggested in\n  // w3c/encrypted-media#32.\n  PatchedMediaKeysWebkit.MediaKeyStatusMap.KEY_ID_ =\n      (new Uint8Array([0])).buffer;\n\n  // Install patches.\n  navigator.requestMediaKeySystemAccess =\n      PatchedMediaKeysWebkit.requestMediaKeySystemAccess;\n  // Delete mediaKeys to work around strict mode compatibility issues.\n  delete HTMLMediaElement.prototype['mediaKeys'];\n  // Work around read-only declaration for mediaKeys by using a string.\n  HTMLMediaElement.prototype['mediaKeys'] = null;\n  HTMLMediaElement.prototype.setMediaKeys = PatchedMediaKeysWebkit.setMediaKeys;\n  window.MediaKeys = PatchedMediaKeysWebkit.MediaKeys;\n  window.MediaKeySystemAccess = PatchedMediaKeysWebkit.MediaKeySystemAccess;\n};\n\n\n/**\n * Prefix api by stored prefix.\n *\n * @param {string} api\n * @return {string}\n * @private\n */\nshaka.polyfill.PatchedMediaKeysWebkit.prefixApi_ = function(api) {\n  var prefix = shaka.polyfill.PatchedMediaKeysWebkit.prefix_;\n  if (prefix) {\n    return prefix + api.charAt(0).toUpperCase() + api.slice(1);\n  }\n  return api;\n};\n\n\n/**\n * An implementation of navigator.requestMediaKeySystemAccess.\n * Retrieve a MediaKeySystemAccess object.\n *\n * @this {!Navigator}\n * @param {string} keySystem\n * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n * @return {!Promise.<!MediaKeySystemAccess>}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.requestMediaKeySystemAccess =\n    function(keySystem, supportedConfigurations) {\n  shaka.log.debug('PatchedMediaKeysWebkit.requestMediaKeySystemAccess');\n  goog.asserts.assert(this == navigator,\n                      'bad \"this\" for requestMediaKeySystemAccess');\n\n  // Alias.\n  var PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n  try {\n    var access = new PatchedMediaKeysWebkit.MediaKeySystemAccess(\n        keySystem, supportedConfigurations);\n    return Promise.resolve(/** @type {!MediaKeySystemAccess} */ (access));\n  } catch (exception) {\n    return Promise.reject(exception);\n  }\n};\n\n\n/**\n * An implementation of HTMLMediaElement.prototype.setMediaKeys.\n * Attach a MediaKeys object to the media element.\n *\n * @this {!HTMLMediaElement}\n * @param {MediaKeys} mediaKeys\n * @return {!Promise}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.setMediaKeys = function(mediaKeys) {\n  shaka.log.debug('PatchedMediaKeysWebkit.setMediaKeys');\n  goog.asserts.assert(this instanceof HTMLMediaElement,\n                      'bad \"this\" for setMediaKeys');\n\n  // Alias.\n  var PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n\n  var newMediaKeys =\n      /** @type {shaka.polyfill.PatchedMediaKeysWebkit.MediaKeys} */ (\n          mediaKeys);\n  var oldMediaKeys =\n      /** @type {shaka.polyfill.PatchedMediaKeysWebkit.MediaKeys} */ (\n          this.mediaKeys);\n\n  if (oldMediaKeys && oldMediaKeys != newMediaKeys) {\n    goog.asserts.assert(\n        oldMediaKeys instanceof PatchedMediaKeysWebkit.MediaKeys,\n        'non-polyfill instance of oldMediaKeys');\n    // Have the old MediaKeys stop listening to events on the video tag.\n    oldMediaKeys.setMedia(null);\n  }\n\n  delete this['mediaKeys'];  // in case there is an existing getter\n  this['mediaKeys'] = mediaKeys;  // work around read-only declaration\n\n  if (newMediaKeys) {\n    goog.asserts.assert(\n        newMediaKeys instanceof PatchedMediaKeysWebkit.MediaKeys,\n        'non-polyfill instance of newMediaKeys');\n    newMediaKeys.setMedia(this);\n  }\n\n  return Promise.resolve();\n};\n\n\n/**\n * For some of this polyfill's implementation, we need to query a video element.\n * But for some embedded systems, it is memory-expensive to create multiple\n * video elements.  Therefore, we check the document to see if we can borrow one\n * to query before we fall back to creating one temporarily.\n *\n * @return {!HTMLVideoElement}\n * @private\n */\nshaka.polyfill.PatchedMediaKeysWebkit.getVideoElement_ = function() {\n  var videos = document.getElementsByTagName('video');\n  var tmpVideo = videos.length ? videos[0] : document.createElement('video');\n  return /** @type {!HTMLVideoElement} */(tmpVideo);\n};\n\n\n\n/**\n * An implementation of MediaKeySystemAccess.\n *\n * @constructor\n * @struct\n * @param {string} keySystem\n * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n * @implements {MediaKeySystemAccess}\n * @throws {Error} if the key system is not supported.\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySystemAccess =\n    function(keySystem, supportedConfigurations) {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySystemAccess');\n\n  /** @type {string} */\n  this.keySystem = keySystem;\n\n  /** @private {string} */\n  this.internalKeySystem_ = keySystem;\n\n  /** @private {!MediaKeySystemConfiguration} */\n  this.configuration_;\n\n  // This is only a guess, since we don't really know from the prefixed API.\n  var allowPersistentState = true;\n\n  if (keySystem == 'org.w3.clearkey') {\n    // ClearKey's string must be prefixed in v0.1b.\n    this.internalKeySystem_ = 'webkit-org.w3.clearkey';\n    // ClearKey doesn't support persistence.\n    allowPersistentState = false;\n  }\n\n  var success = false;\n  var tmpVideo = shaka.polyfill.PatchedMediaKeysWebkit.getVideoElement_();\n  for (var i = 0; i < supportedConfigurations.length; ++i) {\n    var cfg = supportedConfigurations[i];\n\n    // Create a new config object and start adding in the pieces which we\n    // find support for.  We will return this from getConfiguration() if\n    // asked.\n    /** @type {!MediaKeySystemConfiguration} */\n    var newCfg = {\n      'audioCapabilities': [],\n      'videoCapabilities': [],\n      // It is technically against spec to return these as optional, but we\n      // don't truly know their values from the prefixed API:\n      'persistentState': 'optional',\n      'distinctiveIdentifier': 'optional',\n      // Pretend the requested init data types are supported, since we don't\n      // really know that either:\n      'initDataTypes': cfg.initDataTypes,\n      'sessionTypes': ['temporary'],\n      'label': cfg.label\n    };\n\n    // v0.1b tests for key system availability with an extra argument on\n    // canPlayType.\n    var ranAnyTests = false;\n    if (cfg.audioCapabilities) {\n      for (var j = 0; j < cfg.audioCapabilities.length; ++j) {\n        var cap = cfg.audioCapabilities[j];\n        if (cap.contentType) {\n          ranAnyTests = true;\n          // In Chrome <= 40, if you ask about Widevine-encrypted audio support,\n          // you get a false-negative when you specify codec information.\n          // Work around this by stripping codec info for audio types.\n          var contentType = cap.contentType.split(';')[0];\n          if (tmpVideo.canPlayType(contentType, this.internalKeySystem_)) {\n            newCfg.audioCapabilities.push(cap);\n            success = true;\n          }\n        }\n      }\n    }\n    if (cfg.videoCapabilities) {\n      for (var j = 0; j < cfg.videoCapabilities.length; ++j) {\n        var cap = cfg.videoCapabilities[j];\n        if (cap.contentType) {\n          ranAnyTests = true;\n          if (tmpVideo.canPlayType(cap.contentType, this.internalKeySystem_)) {\n            newCfg.videoCapabilities.push(cap);\n            success = true;\n          }\n        }\n      }\n    }\n\n    if (!ranAnyTests) {\n      // If no specific types were requested, we check all common types to find\n      // out if the key system is present at all.\n      success = tmpVideo.canPlayType('video/mp4', this.internalKeySystem_) ||\n                tmpVideo.canPlayType('video/webm', this.internalKeySystem_);\n    }\n    if (cfg.persistentState == 'required') {\n      if (allowPersistentState) {\n        newCfg.persistentState = 'required';\n        newCfg.sessionTypes = ['persistent-license'];\n      } else {\n        success = false;\n      }\n    }\n\n    if (success) {\n      this.configuration_ = newCfg;\n      return;\n    }\n  }  // for each cfg in supportedConfigurations\n\n  var message = 'Unsupported keySystem';\n  if (keySystem == 'org.w3.clearkey' || keySystem == 'com.widevine.alpha') {\n    message = 'None of the requested configurations were supported.';\n  }\n  var unsupportedError = new Error(message);\n  unsupportedError.name = 'NotSupportedError';\n  unsupportedError.code = DOMException.NOT_SUPPORTED_ERR;\n  throw unsupportedError;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySystemAccess.prototype.\n    createMediaKeys = function() {\n  shaka.log.debug(\n      'PatchedMediaKeysWebkit.MediaKeySystemAccess.createMediaKeys');\n\n  // Alias.\n  var PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n  var mediaKeys = new PatchedMediaKeysWebkit.MediaKeys(this.internalKeySystem_);\n  return Promise.resolve(/** @type {!MediaKeys} */ (mediaKeys));\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySystemAccess.prototype.\n    getConfiguration = function() {\n  shaka.log.debug(\n      'PatchedMediaKeysWebkit.MediaKeySystemAccess.getConfiguration');\n  return this.configuration_;\n};\n\n\n\n/**\n * An implementation of MediaKeys.\n *\n * @constructor\n * @struct\n * @param {string} keySystem\n * @implements {MediaKeys}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeys = function(keySystem) {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeys');\n\n  /** @private {string} */\n  this.keySystem_ = keySystem;\n\n  /** @private {HTMLMediaElement} */\n  this.media_ = null;\n\n  /** @private {!shaka.util.EventManager} */\n  this.eventManager_ = new shaka.util.EventManager();\n\n  /**\n   * @private {!Array.<!shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession>}\n   */\n  this.newSessions_ = [];\n\n  /**\n   * @private {!Object.<string,\n   *                    !shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession>}\n   */\n  this.sessionMap_ = {};\n};\n\n\n/**\n * @param {HTMLMediaElement} media\n * @protected\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeys.prototype.setMedia =\n    function(media) {\n  this.media_ = media;\n\n  // Remove any old listeners.\n  this.eventManager_.removeAll();\n\n  var prefix = shaka.polyfill.PatchedMediaKeysWebkit.prefix_;\n  if (media) {\n    // Intercept and translate these prefixed EME events.\n    this.eventManager_.listen(media, prefix + 'needkey',\n        /** @type {shaka.util.EventManager.ListenerType} */ (\n            this.onWebkitNeedKey_.bind(this)));\n\n    this.eventManager_.listen(media, prefix + 'keymessage',\n        /** @type {shaka.util.EventManager.ListenerType} */ (\n            this.onWebkitKeyMessage_.bind(this)));\n\n    this.eventManager_.listen(media, prefix + 'keyadded',\n        /** @type {shaka.util.EventManager.ListenerType} */ (\n            this.onWebkitKeyAdded_.bind(this)));\n\n    this.eventManager_.listen(media, prefix + 'keyerror',\n        /** @type {shaka.util.EventManager.ListenerType} */ (\n            this.onWebkitKeyError_.bind(this)));\n  }\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeys.prototype.createSession =\n    function(opt_sessionType) {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeys.createSession');\n\n  var sessionType = opt_sessionType || 'temporary';\n  // TODO: Consider adding support for persistent-release once Chrome has\n  // implemented it natively.  http://crbug.com/448888\n  // This is a non-issue if we've deprecated the polyfill by then, since\n  // prefixed EME is on its way out.\n  if (sessionType != 'temporary' && sessionType != 'persistent-license') {\n    throw new TypeError('Session type ' + opt_sessionType +\n                        ' is unsupported on this platform.');\n  }\n\n  // Alias.\n  var PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n\n  // Unprefixed EME allows for session creation without a video tag or src.\n  // Prefixed EME requires both a valid HTMLMediaElement and a src.\n  var media = this.media_ || /** @type {!HTMLMediaElement} */(\n      document.createElement('video'));\n  if (!media.src) media.src = 'about:blank';\n\n  var session = new PatchedMediaKeysWebkit.MediaKeySession(\n      media, this.keySystem_, sessionType);\n  this.newSessions_.push(session);\n  return session;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeys.prototype.setServerCertificate =\n    function(serverCertificate) {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeys.setServerCertificate');\n\n  // There is no equivalent in v0.1b, so return failure.\n  return Promise.reject(new Error(\n      'setServerCertificate not supported on this platform.'));\n};\n\n\n/**\n * @param {!MediaKeyEvent} event\n * @private\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeys.prototype.onWebkitNeedKey_ =\n    function(event) {\n  shaka.log.debug('PatchedMediaKeysWebkit.onWebkitNeedKey_', event);\n  goog.asserts.assert(this.media_, 'media_ not set in onWebkitNeedKey_');\n\n  var event2 = document.createEvent('CustomEvent');\n  event2.initCustomEvent('encrypted', false, false, null);\n\n  // not used by v0.1b EME, but given a valid value\n  event2.initDataType = 'webm';\n  event2.initData = event.initData;\n\n  this.media_.dispatchEvent(event2);\n};\n\n\n/**\n * @param {!MediaKeyEvent} event\n * @private\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeys.prototype.onWebkitKeyMessage_ =\n    function(event) {\n  shaka.log.debug('PatchedMediaKeysWebkit.onWebkitKeyMessage_', event);\n\n  var session = this.findSession_(event.sessionId);\n  if (!session) {\n    shaka.log.error('Session not found', event.sessionId);\n    return;\n  }\n\n  var isNew = session.keyStatuses.getStatus() == undefined;\n\n  var event2 = new shaka.util.FakeEvent('message', {\n    messageType: isNew ? 'licenserequest' : 'licenserenewal',\n    message: event.message\n  });\n\n  session.generated();\n  session.dispatchEvent(event2);\n};\n\n\n/**\n * @param {!MediaKeyEvent} event\n * @private\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeys.prototype.onWebkitKeyAdded_ =\n    function(event) {\n  shaka.log.debug('PatchedMediaKeysWebkit.onWebkitKeyAdded_', event);\n\n  var session = this.findSession_(event.sessionId);\n  goog.asserts.assert(session, 'unable to find session in onWebkitKeyAdded_');\n  if (session) {\n    session.ready();\n  }\n};\n\n\n/**\n * @param {!MediaKeyEvent} event\n * @private\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeys.prototype.onWebkitKeyError_ =\n    function(event) {\n  shaka.log.debug('PatchedMediaKeysWebkit.onWebkitKeyError_', event);\n\n  var session = this.findSession_(event.sessionId);\n  goog.asserts.assert(session, 'unable to find session in onWebkitKeyError_');\n  if (session) {\n    session.handleError(event);\n  }\n};\n\n\n/**\n * @param {string} sessionId\n * @return {shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession}\n * @private\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeys.prototype.findSession_ =\n    function(sessionId) {\n  var session = this.sessionMap_[sessionId];\n  if (session) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeys.findSession_', session);\n    return session;\n  }\n\n  session = this.newSessions_.shift();\n  if (session) {\n    session.sessionId = sessionId;\n    this.sessionMap_[sessionId] = session;\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeys.findSession_', session);\n    return session;\n  }\n\n  return null;\n};\n\n\n\n/**\n * An implementation of MediaKeySession.\n *\n * @param {!HTMLMediaElement} media\n * @param {string} keySystem\n * @param {string} sessionType\n *\n * @constructor\n * @struct\n * @implements {MediaKeySession}\n * @extends {shaka.util.FakeEventTarget}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession =\n    function(media, keySystem, sessionType) {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession');\n  shaka.util.FakeEventTarget.call(this);\n\n  /** @private {!HTMLMediaElement} */\n  this.media_ = media;\n\n  /** @private {boolean} */\n  this.initialized_ = false;\n\n  /** @private {shaka.util.PublicPromise} */\n  this.generatePromise_ = null;\n\n  /** @private {shaka.util.PublicPromise} */\n  this.updatePromise_ = null;\n\n  /** @private {string} */\n  this.keySystem_ = keySystem;\n\n  /** @private {string} */\n  this.type_ = sessionType;\n\n  /** @type {string} */\n  this.sessionId = '';\n\n  /** @type {number} */\n  this.expiration = NaN;\n\n  /** @type {!shaka.util.PublicPromise} */\n  this.closed = new shaka.util.PublicPromise();\n\n  /** @type {!MediaKeyStatusMap} */\n  this.keyStatuses =\n      new shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap();\n};\ngoog.inherits(shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession,\n              shaka.util.FakeEventTarget);\n\n\n/**\n * Signals that the license request has been generated.  This resolves the\n * 'generateRequest' promise.\n *\n * @protected\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.generated =\n    function() {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.generated');\n\n  if (this.generatePromise_) {\n    this.generatePromise_.resolve();\n    this.generatePromise_ = null;\n  }\n};\n\n\n/**\n * Signals that the session is 'ready', which is the terminology used in older\n * versions of EME.  The new signal is to resolve the 'update' promise.  This\n * translates between the two.\n *\n * @protected\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.ready =\n    function() {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.ready');\n\n  this.updateKeyStatus_('usable');\n\n  if (this.updatePromise_) {\n    this.updatePromise_.resolve();\n  }\n  this.updatePromise_ = null;\n};\n\n\n/**\n * Either rejects a promise, or dispatches an error event, as appropriate.\n *\n * @param {!MediaKeyEvent} event\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.handleError =\n    function(event) {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.handleError', event);\n\n  // This does not match the DOMException we get in current WD EME, but it will\n  // at least provide some information which can be used to look into the\n  // problem.\n  var error = new Error('EME v0.1b key error');\n  error.errorCode = event.errorCode;\n  error.errorCode.systemCode = event.systemCode;\n\n  // The presence or absence of sessionId indicates whether this corresponds to\n  // generateRequest() or update().\n  if (!event.sessionId && this.generatePromise_) {\n    error.method = 'generateRequest';\n    if (event.systemCode == 45) {\n      error.message = 'Unsupported session type.';\n    }\n    this.generatePromise_.reject(error);\n    this.generatePromise_ = null;\n  } else if (event.sessionId && this.updatePromise_) {\n    error.method = 'update';\n    this.updatePromise_.reject(error);\n    this.updatePromise_ = null;\n  } else {\n    // This mapping of key statuses is imperfect at best.\n    var code = event.errorCode.code;\n    var systemCode = event.systemCode;\n    if (code == MediaKeyError['MEDIA_KEYERR_OUTPUT']) {\n      this.updateKeyStatus_('output-restricted');\n    } else if (systemCode == 1) {\n      this.updateKeyStatus_('expired');\n    } else {\n      this.updateKeyStatus_('internal-error');\n    }\n  }\n};\n\n\n/**\n * Logic which is shared between generateRequest() and load(), both of which\n * are ultimately implemented with webkitGenerateKeyRequest in prefixed EME.\n *\n * @param {?BufferSource} initData\n * @param {?string} offlineSessionId\n * @return {!Promise}\n * @private\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.generate_ =\n    function(initData, offlineSessionId) {\n  if (this.initialized_) {\n    return Promise.reject(new Error('The session is already initialized.'));\n  }\n\n  this.initialized_ = true;\n\n  /** @type {!Uint8Array} */\n  var mangledInitData;\n\n  try {\n    if (this.type_ == 'persistent-license') {\n      var StringUtils = shaka.util.StringUtils;\n      if (!offlineSessionId) {\n        // Persisting the initial license.\n        // Prefix the init data with a tag to indicate persistence.\n        var prefix = StringUtils.toUTF8('PERSISTENT|');\n        var result = new Uint8Array(prefix.byteLength + initData.byteLength);\n        result.set(new Uint8Array(prefix), 0);\n        result.set(new Uint8Array(initData), prefix.byteLength);\n        mangledInitData = result;\n      } else {\n        // Loading a stored license.\n        // Prefix the init data (which is really a session ID) with a tag to\n        // indicate that we are loading a persisted session.\n        mangledInitData = new Uint8Array(\n            StringUtils.toUTF8('LOAD_SESSION|' + offlineSessionId));\n      }\n    } else {\n      // Streaming.\n      goog.asserts.assert(this.type_ == 'temporary',\n                          'expected temporary session');\n      goog.asserts.assert(!offlineSessionId,\n                          'unexpected offline session ID');\n      mangledInitData = new Uint8Array(initData);\n    }\n\n    goog.asserts.assert(mangledInitData,\n                        'init data not set!');\n  } catch (exception) {\n    return Promise.reject(exception);\n  }\n\n  goog.asserts.assert(this.generatePromise_ == null,\n                      'generatePromise_ should be null');\n  this.generatePromise_ = new shaka.util.PublicPromise();\n\n  // Because we are hacking media.src in createSession to better emulate\n  // unprefixed EME's ability to create sessions and license requests without a\n  // video tag, we can get ourselves into trouble.  It seems that sometimes,\n  // the setting of media.src hasn't been processed by some other thread, and\n  // GKR can throw an exception.  If this occurs, wait 10 ms and try again at\n  // most once.  This situation should only occur when init data is available\n  // ahead of the 'needkey' event.\n\n  var prefixApi = shaka.polyfill.PatchedMediaKeysWebkit.prefixApi_;\n  var generateKeyRequestName = prefixApi('generateKeyRequest');\n  try {\n    this.media_[generateKeyRequestName](this.keySystem_, mangledInitData);\n  } catch (exception) {\n    if (exception.name != 'InvalidStateError') {\n      this.generatePromise_ = null;\n      return Promise.reject(exception);\n    }\n\n    setTimeout(function() {\n      try {\n        this.media_[generateKeyRequestName](this.keySystem_, mangledInitData);\n      } catch (exception) {\n        this.generatePromise_.reject(exception);\n        this.generatePromise_ = null;\n      }\n    }.bind(this), 10);\n  }\n\n  return this.generatePromise_;\n};\n\n\n/**\n * An internal version of update which defers new calls while old ones are in\n * progress.\n *\n * @param {!shaka.util.PublicPromise} promise  The promise associated with this\n *   call.\n * @param {?BufferSource} response\n * @private\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.update_ =\n    function(promise, response) {\n  if (this.updatePromise_) {\n    // We already have an update in-progress, so defer this one until after the\n    // old one is resolved.  Execute this whether the original one succeeds or\n    // fails.\n    this.updatePromise_.then(\n        this.update_.bind(this, promise, response)\n    ).catch(\n        this.update_.bind(this, promise, response)\n    );\n    return;\n  }\n\n  this.updatePromise_ = promise;\n\n  var key;\n  var keyId;\n\n  if (this.keySystem_ == 'webkit-org.w3.clearkey') {\n    // The current EME version of clearkey wants a structured JSON response.\n    // The v0.1b version wants just a raw key.  Parse the JSON response and\n    // extract the key and key ID.\n    var StringUtils = shaka.util.StringUtils;\n    var Uint8ArrayUtils = shaka.util.Uint8ArrayUtils;\n    var licenseString = StringUtils.fromUTF8(response);\n    var jwkSet = /** @type {JWKSet} */ (JSON.parse(licenseString));\n    var kty = jwkSet.keys[0].kty;\n    if (kty != 'oct') {\n      // Reject the promise.\n      var error = new Error('Response is not a valid JSON Web Key Set.');\n      this.updatePromise_.reject(error);\n      this.updatePromise_ = null;\n    }\n    key = Uint8ArrayUtils.fromBase64(jwkSet.keys[0].k);\n    keyId = Uint8ArrayUtils.fromBase64(jwkSet.keys[0].kid);\n  } else {\n    // The key ID is not required.\n    key = new Uint8Array(response);\n    keyId = null;\n  }\n\n  var prefixApi = shaka.polyfill.PatchedMediaKeysWebkit.prefixApi_;\n  var addKeyName = prefixApi('addKey');\n  try {\n    this.media_[addKeyName](this.keySystem_, key, keyId, this.sessionId);\n  } catch (exception) {\n    // Reject the promise.\n    this.updatePromise_.reject(exception);\n    this.updatePromise_ = null;\n  }\n};\n\n\n/**\n * Update key status and dispatch a 'keystatuseschange' event.\n *\n * @param {string} status\n * @private\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.\n    updateKeyStatus_ = function(status) {\n  this.keyStatuses.setStatus(status);\n  var event = new shaka.util.FakeEvent('keystatuseschange');\n  this.dispatchEvent(event);\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.\n    generateRequest = function(initDataType, initData) {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.generateRequest');\n  return this.generate_(initData, null);\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.load =\n    function(sessionId) {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.load');\n  if (this.type_ == 'persistent-license') {\n    return this.generate_(null, sessionId);\n  } else {\n    return Promise.reject(new Error('Not a persistent session.'));\n  }\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.update =\n    function(response) {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.update', response);\n  goog.asserts.assert(this.sessionId, 'update without session ID');\n\n  var nextUpdatePromise = new shaka.util.PublicPromise();\n  this.update_(nextUpdatePromise, response);\n  return nextUpdatePromise;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.close =\n    function() {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.close');\n\n  // This will remove a persistent session, but it's also the only way to\n  // free CDM resources on v0.1b.\n  if (this.type_ != 'persistent-license') {\n    // sessionId may reasonably be null if no key request has been generated\n    // yet.  Unprefixed EME will return a rejected promise in this case.\n    // We will use the same error message that Chrome 41 uses in its EME\n    // implementation.\n    if (!this.sessionId) {\n      this.closed.reject(new Error('The session is not callable.'));\n      return this.closed;\n    }\n\n    // This may throw an exception, but we ignore it because we are only using\n    // it to clean up resources in v0.1b.  We still consider the session closed.\n    // We can't let the exception propagate because MediaKeySession.close()\n    // should not throw.\n    var prefixApi = shaka.polyfill.PatchedMediaKeysWebkit.prefixApi_;\n    var cancelKeyRequestName = prefixApi('cancelKeyRequest');\n    try {\n      this.media_[cancelKeyRequestName](this.keySystem_, this.sessionId);\n    } catch (exception) {}\n  }\n\n  // Resolve the 'closed' promise and return it.\n  this.closed.resolve();\n  return this.closed;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype.remove =\n    function() {\n  shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.remove');\n\n  if (this.type_ != 'persistent-license') {\n    return Promise.reject(new Error('Not a persistent session.'));\n  }\n\n  return this.close();\n};\n\n\n\n/**\n * An implementation of MediaKeyStatusMap.\n * This fakes a map with a single key ID.\n *\n * @constructor\n * @struct\n * @implements {MediaKeyStatusMap}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap = function() {\n  /**\n   * @type {number}\n   */\n  this.size = 0;\n\n  /**\n   * @private {string|undefined}\n   */\n  this.status_ = undefined;\n};\n\n\n/**\n * @const {!ArrayBuffer}\n * @private\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.KEY_ID_;\n\n\n/**\n * An internal method used by the session to set key status.\n * @param {string|undefined} status\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.prototype.setStatus =\n    function(status) {\n  this.size = status == undefined ? 0 : 1;\n  this.status_ = status;\n};\n\n\n/**\n * An internal method used by the session to get key status.\n * @return {string|undefined}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.prototype.getStatus =\n    function() {\n  return this.status_;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.prototype.forEach =\n    function(fn) {\n  if (this.status_) {\n    var fakeKeyId =\n        shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.KEY_ID_;\n    fn(this.status_, fakeKeyId);\n  }\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.prototype.get =\n    function(keyId) {\n  if (this.has(keyId)) {\n    return this.status_;\n  }\n  return undefined;\n};\n\n\n/** @override */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.prototype.has =\n    function(keyId) {\n  var fakeKeyId =\n      shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.KEY_ID_;\n  if (this.status_ &&\n      shaka.util.Uint8ArrayUtils.equal(\n          new Uint8Array(keyId), new Uint8Array(fakeKeyId))) {\n    return true;\n  }\n  return false;\n};\n\n\n/** @suppress {missingReturn} */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.prototype.\n    entries = function() {\n  goog.asserts.assert(false, 'Not used!  Provided only for compiler.');\n};\n\n\n/** @suppress {missingReturn} */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.prototype.\n    keys = function() {\n  goog.asserts.assert(false, 'Not used!  Provided only for compiler.');\n};\n\n\n/** @suppress {missingReturn} */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.prototype.\n    values = function() {\n  goog.asserts.assert(false, 'Not used!  Provided only for compiler.');\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/polyfill/promise.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.polyfill.Promise');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill.register');\n\n\n\n/**\n * @summary A polyfill to implement Promises, primarily for IE.\n * Only partially supports thenables, but otherwise passes the A+ conformance\n * tests.\n * Note that Promise.all() and Promise.race() are not tested by that suite.\n *\n * @constructor\n * @struct\n * @param {function(function(*), function(*))=} opt_callback\n * @template T\n */\nshaka.polyfill.Promise = function(opt_callback) {\n  /** @private {!Array.<shaka.polyfill.Promise.Child>} */\n  this.thens_ = [];\n\n  /** @private {!Array.<shaka.polyfill.Promise.Child>} */\n  this.catches_ = [];\n\n  /** @private {shaka.polyfill.Promise.State} */\n  this.state_ = shaka.polyfill.Promise.State.PENDING;\n\n  /** @private {*} */\n  this.value_;\n\n  // External callers must supply the callback.  Internally, we may construct\n  // child Promises without it, since we can directly access their resolve_ and\n  // reject_ methods when convenient.\n  if (opt_callback) {\n    try {\n      opt_callback(this.resolve_.bind(this), this.reject_.bind(this));\n    } catch (e) {\n      this.reject_(e);\n    }\n  }\n};\n\n\n/**\n * @typedef {{\n *   promise: !shaka.polyfill.Promise,\n *   callback: (function(*)|undefined)\n * }}\n *\n * @summary A child promise, used for chaining.\n * @description\n *   Only exists in the context of a then or catch chain.\n * @property {!shaka.polyfill.Promise} promise\n *   The child promise.\n * @property {(function(*)|undefined)} callback\n *   The then or catch callback to be invoked as part of this chain.\n */\nshaka.polyfill.Promise.Child;\n\n\n/**\n * @enum {number}\n */\nshaka.polyfill.Promise.State = {\n  PENDING: 0,\n  RESOLVED: 1,\n  REJECTED: 2\n};\n\n\n/**\n * Install the polyfill if needed.\n * @param {boolean=} opt_force If true, force the polyfill to be installed.\n *   Used in some unit tests.\n */\nshaka.polyfill.Promise.install = function(opt_force) {\n  // Decide on the best way to invoke a callback as soon as possible.\n  // Precompute the setImmediate/clearImmediate convenience methods to avoid the\n  // overhead of this switch every time a callback has to be invoked.\n  if (window.setImmediate) {\n    // For IE and node.js:\n    shaka.polyfill.Promise.setImmediate_ = function(callback) {\n      return window.setImmediate(callback);\n    };\n    shaka.polyfill.Promise.clearImmediate_ = function(id) {\n      return window.clearImmediate(id);\n    };\n  } else {\n    // For everyone else:\n    shaka.polyfill.Promise.setImmediate_ = function(callback) {\n      return window.setTimeout(callback, 0);\n    };\n    shaka.polyfill.Promise.clearImmediate_ = function(id) {\n      return window.clearTimeout(id);\n    };\n  }\n\n  if (window.Promise && !opt_force) {\n    shaka.log.info('Using native Promises.');\n    return;\n  }\n\n  shaka.log.info('Using Promises polyfill.');\n  // Quoted to work around type-checking, since our then() signature doesn't\n  // exactly match that of a native Promise.\n  window['Promise'] = shaka.polyfill.Promise;\n\n  // Explicitly installed because the compiler won't necessarily attach them\n  // to the compiled constructor.  Exporting them will only attach them to\n  // their original namespace, which isn't the same as attaching them to the\n  // constructor unless you also export the constructor.\n  window['Promise'].resolve = shaka.polyfill.Promise.resolve;\n  window['Promise'].reject = shaka.polyfill.Promise.reject;\n  window['Promise'].all = shaka.polyfill.Promise.all;\n  window['Promise'].race = shaka.polyfill.Promise.race;\n\n  // These are manually exported as well, because allowing the compiler to\n  // export them for us will cause the polyfill to end up in our generated\n  // externs.  Since nobody should be accessing this directly using the\n  // shaka.polyfill namespace, it is okay not to @export these methods.\n  window['Promise']['prototype']['then'] =\n      shaka.polyfill.Promise.prototype.then;\n  window['Promise']['prototype']['catch'] =\n      shaka.polyfill.Promise.prototype.catch;\n};\n\n\n/**\n * Uninstall the polyfill.  Used in some unit tests.\n */\nshaka.polyfill.Promise.uninstall = function() {\n  // Do nothing if there is no native implementation.\n  if (shaka.polyfill.Promise.nativePromise_) {\n    shaka.log.info('Removing Promise polyfill.');\n    window['Promise'] = shaka.polyfill.Promise.nativePromise_;\n    shaka.polyfill.Promise.q_ = [];\n  }\n};\n\n\n/**\n * @param {*} value\n * @return {!shaka.polyfill.Promise}\n */\nshaka.polyfill.Promise.resolve = function(value) {\n  var p = new shaka.polyfill.Promise();\n  p.resolve_(undefined);\n  return p.then(function() {\n    return value;\n  });\n};\n\n\n/**\n * @param {*} reason\n * @return {!shaka.polyfill.Promise}\n */\nshaka.polyfill.Promise.reject = function(reason) {\n  var p = new shaka.polyfill.Promise();\n  p.reject_(reason);\n  return p;\n};\n\n\n/**\n * @param {!Array.<!shaka.polyfill.Promise>} others\n * @return {!shaka.polyfill.Promise}\n */\nshaka.polyfill.Promise.all = function(others) {\n  var p = new shaka.polyfill.Promise();\n  if (!others.length) {\n    p.resolve_([]);\n    return p;\n  }\n\n  // The array of results must be in the same order as the array of Promises\n  // passed to all().  So we pre-allocate the array and keep a count of how\n  // many have resolved.  Only when all have resolved is the returned Promise\n  // itself resolved.\n  var count = 0;\n  var values = new Array(others.length);\n  var resolve = function(p, i, newValue) {\n    goog.asserts.assert(p.state_ != shaka.polyfill.Promise.State.RESOLVED,\n                        'Invalid Promise state in Promise.all');\n    // If one of the Promises in the array was rejected, this Promise was\n    // rejected and new values are ignored.  In such a case, the values array\n    // and its contents continue to be alive in memory until all of the Promises\n    // in the array have completed.\n    if (p.state_ == shaka.polyfill.Promise.State.PENDING) {\n      values[i] = newValue;\n      count++;\n      if (count == values.length) {\n        p.resolve_(values);\n      }\n    }\n  };\n\n  var reject = p.reject_.bind(p);\n  for (var i = 0; i < others.length; ++i) {\n    if (others[i] && others[i].then) {\n      others[i].then(resolve.bind(null, p, i), reject);\n    } else {\n      resolve(p, i, others[i]);\n    }\n  }\n  return p;\n};\n\n\n/**\n * @param {!Array.<!shaka.polyfill.Promise>} others\n * @return {!shaka.polyfill.Promise}\n */\nshaka.polyfill.Promise.race = function(others) {\n  var p = new shaka.polyfill.Promise();\n\n  // The returned Promise is resolved or rejected as soon as one of the others\n  // is.\n  var resolve = p.resolve_.bind(p);\n  var reject = p.reject_.bind(p);\n  for (var i = 0; i < others.length; ++i) {\n    if (others[i] && others[i].then) {\n      others[i].then(resolve, reject);\n    } else {\n      resolve(others[i]);\n    }\n  }\n  return p;\n};\n\n\n/**\n * @param {function(*)=} opt_successCallback\n * @param {function(*)=} opt_failCallback\n * @return {!shaka.polyfill.Promise}\n */\nshaka.polyfill.Promise.prototype.then = function(opt_successCallback,\n                                                 opt_failCallback) {\n  // then() returns a child Promise which is chained onto this one.\n  var child = new shaka.polyfill.Promise();\n  switch (this.state_) {\n    case shaka.polyfill.Promise.State.RESOLVED:\n      // This is already resolved, so we can chain to the child ASAP.\n      this.schedule_(child, opt_successCallback);\n      break;\n    case shaka.polyfill.Promise.State.REJECTED:\n      // This is already rejected, so we can chain to the child ASAP.\n      this.schedule_(child, opt_failCallback);\n      break;\n    case shaka.polyfill.Promise.State.PENDING:\n      // This is pending, so we have to track both callbacks and the child\n      // in order to chain later.\n      this.thens_.push({ promise: child, callback: opt_successCallback});\n      this.catches_.push({ promise: child, callback: opt_failCallback});\n      break;\n  }\n\n  return child;\n};\n\n\n/**\n * @param {function(*)=} opt_callback\n * @return {!shaka.polyfill.Promise}\n */\nshaka.polyfill.Promise.prototype.catch = function(opt_callback) {\n  // Devolves into a two-argument call to 'then'.\n  return this.then(undefined, opt_callback);\n};\n\n\n/**\n * @param {*} value\n * @private\n */\nshaka.polyfill.Promise.prototype.resolve_ = function(value) {\n  // Ignore resolve calls if we aren't still pending.\n  if (this.state_ == shaka.polyfill.Promise.State.PENDING) {\n    this.value_ = value;\n    this.state_ = shaka.polyfill.Promise.State.RESOLVED;\n    // Schedule calls to all of the chained callbacks.\n    for (var i = 0; i < this.thens_.length; ++i) {\n      this.schedule_(this.thens_[i].promise, this.thens_[i].callback);\n    }\n    this.thens_ = [];\n    this.catches_ = [];\n  }\n};\n\n\n/**\n * @param {*} reason\n * @private\n */\nshaka.polyfill.Promise.prototype.reject_ = function(reason) {\n  // Ignore reject calls if we aren't still pending.\n  if (this.state_ == shaka.polyfill.Promise.State.PENDING) {\n    this.value_ = reason;\n    this.state_ = shaka.polyfill.Promise.State.REJECTED;\n    // Schedule calls to all of the chained callbacks.\n    for (var i = 0; i < this.catches_.length; ++i) {\n      this.schedule_(this.catches_[i].promise, this.catches_[i].callback);\n    }\n    this.thens_ = [];\n    this.catches_ = [];\n  }\n};\n\n\n/**\n * @param {!shaka.polyfill.Promise} child\n * @param {function(*)|undefined} callback\n * @private\n */\nshaka.polyfill.Promise.prototype.schedule_ = function(child, callback) {\n  goog.asserts.assert(this.state_ != shaka.polyfill.Promise.State.PENDING,\n                      'Invalid Promise state in Promise.schedule_');\n  var Promise = shaka.polyfill.Promise;\n\n  var wrapper = function() {\n    if (callback && typeof callback == 'function') {\n      // Wrap around the callback.  Exceptions thrown by the callback are\n      // converted to failures.\n      try {\n        var value = callback(this.value_);\n      } catch (exception) {\n        child.reject_(exception);\n        return;\n      }\n\n      // According to the spec, 'then' in a thenable may only be accessed once\n      // and any thrown exceptions in the getter must cause the Promise chain\n      // to fail.\n      var then;\n      try {\n        then = value && value.then;\n      } catch (exception) {\n        child.reject_(exception);\n        return;\n      }\n\n      if (value instanceof Promise) {\n        // If the returned value is a Promise, we bind it's state to the child.\n        if (value == child) {\n          // Without this, a bad calling pattern can cause an infinite loop.\n          child.reject_(new TypeError('Chaining cycle detected'));\n        } else {\n          value.then(child.resolve_.bind(child), child.reject_.bind(child));\n        }\n      } else if (then) {\n        // If the returned value is thenable, chain it to the child.\n        Promise.handleThenable_(value, then, child);\n      } else {\n        // If the returned value is not a Promise, the child is resolved with\n        // that value.\n        child.resolve_(value);\n      }\n    } else if (this.state_ == Promise.State.RESOLVED) {\n      // No callback for this state, so just chain on down the line.\n      child.resolve_(this.value_);\n    } else {\n      // No callback for this state, so just chain on down the line.\n      child.reject_(this.value_);\n    }\n  };\n\n  // Enqueue a call to the wrapper.\n  Promise.q_.push(wrapper.bind(this));\n  if (Promise.flushTimer_ == null) {\n    Promise.flushTimer_ = Promise.setImmediate_(Promise.flush);\n  }\n};\n\n\n/**\n * @param {!Object} thenable\n * @param {Function} then\n * @param {!shaka.polyfill.Promise} child\n * @private\n */\nshaka.polyfill.Promise.handleThenable_ = function(thenable, then, child) {\n  var Promise = shaka.polyfill.Promise;\n  try {\n    var sealed = false;\n    then.call(thenable, function(value) {\n      if (sealed) return;\n      sealed = true;\n\n      var nextThen;\n      try {\n        nextThen = value && value.then;\n      } catch (exception) {\n        child.reject_(exception);\n        return;\n      }\n\n      if (nextThen) {\n        Promise.handleThenable_(value, nextThen, child);\n      } else {\n        child.resolve_(value);\n      }\n    }, child.reject_.bind(child));\n  } catch (exception) {\n    child.reject_(exception);\n  }\n};\n\n\n/**\n * Flush the queue of callbacks.\n * Used directly by some unit tests.\n */\nshaka.polyfill.Promise.flush = function() {\n  var Promise = shaka.polyfill.Promise;\n\n  // Flush as long as we have callbacks.  This means we can finish a chain more\n  // quickly, since we avoid the overhead of multiple calls to setTimeout, each\n  // of which has a minimum resolution of as much as 15ms on IE11.\n  // This helps to fix the out-of-order task bug on IE:\n  //   https://github.com/google/shaka-player/issues/251#issuecomment-178146242\n  while (Promise.q_.length) {\n    // Callbacks may enqueue other callbacks, so clear the timer ID and swap the\n    // queue before we do anything else.\n    if (Promise.flushTimer_ != null) {\n      Promise.clearImmediate_(Promise.flushTimer_);\n      Promise.flushTimer_ = null;\n    }\n    var q = Promise.q_;\n    Promise.q_ = [];\n\n    for (var i = 0; i < q.length; ++i) {\n      q[i]();\n    }\n  }\n};\n\n\n/**\n * @param {function()} callback\n * @return {number}\n * Schedule a callback as soon as possible.\n * Bound in shaka.polyfill.Promise.install() to a specific implementation.\n * @private\n */\nshaka.polyfill.Promise.setImmediate_ = function(callback) { return 0; };\n\n\n/**\n * @param {number} id\n * Clear a scheduled callback.\n * Bound in shaka.polyfill.Promise.install() to a specific implementation.\n * @private\n */\nshaka.polyfill.Promise.clearImmediate_ = function(id) {};\n\n\n/**\n * A timer ID to flush the queue.\n * @private {?number}\n */\nshaka.polyfill.Promise.flushTimer_ = null;\n\n\n/**\n * A queue of callbacks to be invoked ASAP in the next frame.\n * @private {!Array.<function()>}\n */\nshaka.polyfill.Promise.q_ = [];\n\n\n/** @private {?} */\nshaka.polyfill.Promise.nativePromise_ = window.Promise;\n\n\nshaka.polyfill.register(shaka.polyfill.Promise.install);\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/polyfill/videoplaybackquality.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.polyfill.VideoPlaybackQuality');\n\ngoog.require('shaka.polyfill.register');\n\n\n/**\n * @namespace shaka.polyfill.VideoPlaybackQuality\n *\n * @summary A polyfill to provide MSE VideoPlaybackQuality metrics.\n * Many browsers do not yet provide this API, and Chrome currently provides\n * similar data through individual prefixed attributes on HTMLVideoElement.\n */\n\n\n/**\n * Install the polyfill if needed.\n */\nshaka.polyfill.VideoPlaybackQuality.install = function() {\n  if (!window.HTMLVideoElement) {\n    // Avoid errors on very old browsers.\n    return;\n  }\n\n  var proto = HTMLVideoElement.prototype;\n  if (proto.getVideoPlaybackQuality) {\n    // No polyfill needed.\n    return;\n  }\n\n  if ('webkitDroppedFrameCount' in proto) {\n    proto.getVideoPlaybackQuality =\n        shaka.polyfill.VideoPlaybackQuality.webkit_;\n  }\n};\n\n\n/**\n * @this {HTMLVideoElement}\n * @return {!VideoPlaybackQuality}\n * @private\n */\nshaka.polyfill.VideoPlaybackQuality.webkit_ = function() {\n  return {\n    'droppedVideoFrames': this.webkitDroppedFrameCount,\n    'totalVideoFrames': this.webkitDecodedFrameCount,\n    // Not provided by this polyfill:\n    'corruptedVideoFrames': 0,\n    'creationTime': NaN,\n    'totalFrameDelay': 0\n  };\n};\n\n\nshaka.polyfill.register(shaka.polyfill.VideoPlaybackQuality.install);\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/polyfill/vttcue.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.polyfill.VTTCue');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill.register');\n\n\n/**\n * @namespace shaka.polyfill.VTTCue\n *\n * @summary A polyfill to provide VTTCue.\n */\n\n\n/**\n * Install the polyfill if needed.\n */\nshaka.polyfill.VTTCue.install = function() {\n  if (window.VTTCue) {\n    shaka.log.info('Using native VTTCue.');\n    return;\n  }\n\n  if (!window.TextTrackCue) {\n    shaka.log.error('VTTCue not available.');\n    return;\n  }\n\n  var constructorLength = TextTrackCue.length;\n  if (constructorLength == 3) {\n    shaka.log.info('Using VTTCue polyfill from 3 argument TextTrackCue.');\n    window.VTTCue = shaka.polyfill.VTTCue.from3ArgsTextTrackCue_;\n  } else if (constructorLength == 6) {\n    shaka.log.info('Using VTTCue polyfill from 6 argument TextTrackCue.');\n    window.VTTCue = shaka.polyfill.VTTCue.from6ArgsTextTrackCue_;\n  } else if (shaka.polyfill.VTTCue.canUse3ArgsTextTrackCue_()) {\n    shaka.log.info('Using VTTCue polyfill from 3 argument TextTrackCue.');\n    window.VTTCue = shaka.polyfill.VTTCue.from3ArgsTextTrackCue_;\n  }\n};\n\n\n/**\n * Draft spec TextTrackCue with 3 constructor arguments.\n * See {@link https://goo.gl/ZXBWZi W3C Working Draft 25 October 2012}.\n *\n * @param {number} startTime\n * @param {number} endTime\n * @param {string} text\n * @return {TextTrackCue}\n * @private\n */\nshaka.polyfill.VTTCue.from3ArgsTextTrackCue_ = function(startTime, endTime,\n    text) {\n  return new window.TextTrackCue(startTime, endTime, text);\n};\n\n\n/**\n * Draft spec TextTrackCue with 6 constructor arguments (5th & 6th are\n * optional).\n * See {@link https://goo.gl/AYFqUh W3C Working Draft 29 March 2012}.\n * Quoting the access to the TextTrackCue object to avoid the compiler\n * complaining.\n *\n * @param {number} startTime\n * @param {number} endTime\n * @param {string} text\n * @return {TextTrackCue}\n * @private\n */\nshaka.polyfill.VTTCue.from6ArgsTextTrackCue_ = function(startTime, endTime,\n    text) {\n  var id = startTime + '-' + endTime + '-' + text;\n  return new window['TextTrackCue'](id, startTime, endTime, text);\n};\n\n\n/**\n * IE10, IE11 and Edge returns TextTrackCue.length = 0 although it accepts 3\n * constructor arguments.\n *\n * @return {boolean}\n * @private\n */\nshaka.polyfill.VTTCue.canUse3ArgsTextTrackCue_ = function() {\n  try {\n    return !!shaka.polyfill.VTTCue.from3ArgsTextTrackCue_(1, 2, '');\n  } catch (error) {\n    return false;\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.VTTCue.install);\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/util/array_utils.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.ArrayUtils');\n\n\n/**\n * @namespace shaka.util.ArrayUtils\n * @summary Array utility functions.\n */\n\n\n/**\n * Remove duplicate entries from an array.  Order N^2, so use with caution.\n * @param {!Array.<T>} array\n * @param {function(T, T): boolean=} opt_compareFn An optional function which\n *   will be used to compare items in the array.\n * @return {!Array.<T>}\n * @template T\n */\nshaka.util.ArrayUtils.removeDuplicates = function(array, opt_compareFn) {\n  var result = [];\n  for (var i = 0; i < array.length; ++i) {\n    var matchFound = false;\n    for (var j = 0; j < result.length; ++j) {\n      matchFound = opt_compareFn ? opt_compareFn(array[i], result[j]) :\n                                   array[i] === result[j];\n      if (matchFound) break;\n    }\n    if (!matchFound) {\n      result.push(array[i]);\n    }\n  }\n  return result;\n};\n\n\n/**\n * Find an item in an array.  For use when comparison of entries via == will\n * not suffice.\n * @param {!Array.<T>} array\n * @param {T} value\n * @param {function(T, T): boolean} compareFn A function which will be used to\n *   compare items in the array.\n * @return {number} The index, or -1 if not found.\n * @template T\n */\nshaka.util.ArrayUtils.indexOf = function(array, value, compareFn) {\n  for (var i = 0; i < array.length; ++i) {\n    if (compareFn(array[i], value)) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/util/cancelable_chain.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.CancelableChain');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.Error');\n\n\n\n/**\n * A Promise-based abstraction that creates cancelable Promise chains.\n * When canceled, subsequent stages of the internal Promise chain will stop.\n * A canceled chain is rejected with a user-specified value.\n *\n * A CancelableChain only supports linear Promise chains.  Chains which branch\n * (more than one then() handler chained to a particular stage) are not\n * supported.  You will not be prevented from treating this as if branching\n * were supported, but everything will be serialized into a linear chain.\n * Be careful!\n *\n * @constructor\n * @struct\n */\nshaka.util.CancelableChain = function() {\n  /** @private {!Promise} */\n  this.promise_ = Promise.resolve();\n\n  /** @private {boolean} */\n  this.final_ = false;\n\n  /** @private {boolean} */\n  this.complete_ = false;\n\n  /** @private {boolean} */\n  this.canceled_ = false;\n\n  /** @private {shaka.util.Error} */\n  this.rejectionValue_;\n\n  /** @private {function()} */\n  this.onCancelComplete_;\n\n  /** @private {!Promise} */\n  this.cancelPromise_ = new Promise(function(resolve) {\n    this.onCancelComplete_ = resolve;\n  }.bind(this));\n};\n\n\n/**\n * @param {function(*)} callback\n * @return {!shaka.util.CancelableChain} the chain itself.\n */\nshaka.util.CancelableChain.prototype.then = function(callback) {\n  goog.asserts.assert(!this.final_, 'Chain should not be final!');\n\n  this.promise_ = this.promise_.then(callback).then(function(data) {\n    if (this.canceled_) {\n      this.onCancelComplete_();\n      return Promise.reject(this.rejectionValue_);\n    }\n    return Promise.resolve(data);\n  }.bind(this));\n  return this;\n};\n\n\n/**\n * Finalize the chain.\n * Converts the chain into a simple Promise and stops accepting new stages.\n *\n * @return {!Promise}\n */\nshaka.util.CancelableChain.prototype.finalize = function() {\n  if (!this.final_) {\n    this.promise_ = this.promise_.then(function(data) {\n      this.complete_ = true;\n      return Promise.resolve(data);\n    }.bind(this), function(error) {\n      this.complete_ = true;\n      return Promise.reject(error);\n    }.bind(this));\n  }\n  this.final_ = true;\n  return this.promise_;\n};\n\n\n/**\n * Cancel the Promise chain and reject with the given value.\n *\n * @param {!shaka.util.Error} reason\n * @return {!Promise} resolved when the cancelation has been processed by the\n *   the chain and no more stages will execute.  Note that this may be before\n *   the owner of the finalized chain has seen the rejection.\n */\nshaka.util.CancelableChain.prototype.cancel = function(reason) {\n  if (this.complete_) return Promise.resolve();\n\n  this.canceled_ = true;\n  this.rejectionValue_ = reason;\n  return this.cancelPromise_;\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/util/config_utils.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.ConfigUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\n\n\n/**\n * @param {!Object} destination\n * @param {!Object} source\n * @param {!Object} template supplies default values\n * @param {!Object} overrides\n *   Supplies override type checking.  When the current path matches the key in\n *   this object, each sub-value must match the type in this object.  If this\n *   contains an Object, it is used as the template.\n * @param {string} path to this part of the config\n */\nshaka.util.ConfigUtils.mergeConfigObjects =\n    function(destination, source, template, overrides, path) {\n  goog.asserts.assert(destination, 'Destination config must not be null!');\n\n  /**\n   * @type {boolean}\n   * If true, don't validate the keys in the next level.\n   */\n  var ignoreKeys = path in overrides;\n\n  for (var k in source) {\n    var subPath = path + '.' + k;\n    var subTemplate = ignoreKeys ? overrides[path] : template[k];\n\n    /**\n     * @type {boolean}\n     * If true, simply copy the object over and don't verify.\n     */\n    var copyObject = !!({\n      '.abr.manager': true\n    })[subPath];\n\n    // The order of these checks is important.\n    if (!ignoreKeys && !(k in destination)) {\n      shaka.log.error('Invalid config, unrecognized key ' + subPath);\n    } else if (source[k] === undefined) {\n      // An explicit 'undefined' value causes the key to be deleted from the\n      // destination config and replaced with a default from the template if\n      // possible.\n      if (subTemplate === undefined || ignoreKeys) {\n        delete destination[k];\n      } else {\n        destination[k] = subTemplate;\n      }\n    } else if (copyObject) {\n      destination[k] = source[k];\n    } else if (typeof destination[k] == 'object' &&\n               typeof source[k] == 'object') {\n      shaka.util.ConfigUtils.mergeConfigObjects(\n          destination[k], source[k], subTemplate, overrides, subPath);\n    } else if (typeof source[k] != typeof subTemplate) {\n      shaka.log.error('Invalid config, wrong type for ' + subPath);\n    } else if (typeof destination[k] == 'function' &&\n               destination[k].length != source[k].length) {\n      shaka.log.warning(\n          'Invalid config, wrong number of arguments for ' + subPath);\n      destination[k] = source[k];\n    } else {\n      destination[k] = source[k];\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/util/data_view_reader.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.DataViewReader');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\n\n\n\n/**\n * Creates a DataViewReader, which abstracts a DataView object.\n *\n * @param {!DataView} dataView The DataView.\n * @param {shaka.util.DataViewReader.Endianness} endianness The endianness.\n *\n * @struct\n * @constructor\n */\nshaka.util.DataViewReader = function(dataView, endianness) {\n  /** @private {!DataView} */\n  this.dataView_ = dataView;\n\n  /** @private {boolean} */\n  this.littleEndian_ =\n      endianness == shaka.util.DataViewReader.Endianness.LITTLE_ENDIAN;\n\n  /** @private {number} */\n  this.position_ = 0;\n};\n\n\n/**\n * Endianness.\n * @enum {number}\n */\nshaka.util.DataViewReader.Endianness = {\n  BIG_ENDIAN: 0,\n  LITTLE_ENDIAN: 1\n};\n\n\n/**\n * @return {boolean} True if the reader has more data, false otherwise.\n */\nshaka.util.DataViewReader.prototype.hasMoreData = function() {\n  return this.position_ < this.dataView_.byteLength;\n};\n\n\n/**\n * Gets the current byte position.\n * @return {number}\n */\nshaka.util.DataViewReader.prototype.getPosition = function() {\n  return this.position_;\n};\n\n\n/**\n * Gets the byte length of the DataView.\n * @return {number}\n */\nshaka.util.DataViewReader.prototype.getLength = function() {\n  return this.dataView_.byteLength;\n};\n\n\n/**\n * Reads an unsigned 8 bit integer, and advances the reader.\n * @return {number} The integer.\n * @throws {shaka.util.Error} when reading past the end of the data view.\n */\nshaka.util.DataViewReader.prototype.readUint8 = function() {\n  try {\n    var value = this.dataView_.getUint8(this.position_);\n  } catch (exception) {\n    this.throwOutOfBounds_();\n  }\n  this.position_ += 1;\n  return value;\n};\n\n\n/**\n * Reads an unsigned 16 bit integer, and advances the reader.\n * @return {number} The integer.\n * @throws {shaka.util.Error} when reading past the end of the data view.\n */\nshaka.util.DataViewReader.prototype.readUint16 = function() {\n  try {\n    var value = this.dataView_.getUint16(this.position_, this.littleEndian_);\n  } catch (exception) {\n    this.throwOutOfBounds_();\n  }\n  this.position_ += 2;\n  return value;\n};\n\n\n/**\n * Reads an unsigned 32 bit integer, and advances the reader.\n * @return {number} The integer.\n * @throws {shaka.util.Error} when reading past the end of the data view.\n */\nshaka.util.DataViewReader.prototype.readUint32 = function() {\n  try {\n    var value = this.dataView_.getUint32(this.position_, this.littleEndian_);\n  } catch (exception) {\n    this.throwOutOfBounds_();\n  }\n  this.position_ += 4;\n  return value;\n};\n\n\n/**\n * Reads an unsigned 64 bit integer, and advances the reader.\n * @return {number} The integer.\n * @throws {shaka.util.Error} when reading past the end of the data view or\n *   when reading an integer too large to store accurately in JavaScript.\n */\nshaka.util.DataViewReader.prototype.readUint64 = function() {\n  var low, high;\n\n  try {\n    if (this.littleEndian_) {\n      low = this.dataView_.getUint32(this.position_, true);\n      high = this.dataView_.getUint32(this.position_ + 4, true);\n    } else {\n      high = this.dataView_.getUint32(this.position_, false);\n      low = this.dataView_.getUint32(this.position_ + 4, false);\n    }\n  } catch (exception) {\n    this.throwOutOfBounds_();\n  }\n\n  if (high > 0x1FFFFF) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.JS_INTEGER_OVERFLOW);\n  }\n\n  this.position_ += 8;\n\n  // NOTE: This is subtle, but in JavaScript you can't shift left by 32 and get\n  // the full range of 53-bit values possible.  You must multiply by 2^32.\n  return (high * Math.pow(2, 32)) + low;\n};\n\n\n/**\n * Reads the specified number of raw bytes.\n * @param {number} bytes The number of bytes to read.\n * @return {!Uint8Array}\n * @throws {shaka.util.Error} when reading past the end of the data view.\n */\nshaka.util.DataViewReader.prototype.readBytes = function(bytes) {\n  goog.asserts.assert(bytes > 0, 'Bad call to DataViewReader.readBytes');\n  if (this.position_ + bytes > this.dataView_.byteLength) {\n    this.throwOutOfBounds_();\n  }\n  var value = this.dataView_.buffer.slice(\n      this.position_, this.position_ + bytes);\n  this.position_ += bytes;\n  return new Uint8Array(value);\n};\n\n\n/**\n * Skips the specified number of bytes.\n * @param {number} bytes The number of bytes to skip.\n * @throws {shaka.util.Error} when skipping past the end of the data view.\n */\nshaka.util.DataViewReader.prototype.skip = function(bytes) {\n  goog.asserts.assert(bytes >= 0, 'Bad call to DataViewReader.skip');\n  if (this.position_ + bytes > this.dataView_.byteLength) {\n    this.throwOutOfBounds_();\n  }\n  this.position_ += bytes;\n};\n\n\n/**\n * Keeps reading until it reaches a byte that equals to zero.  The text is\n * assumed to be UTF-8.\n * @return {string}\n * @throws {shaka.util.Error} when reading past the end of the data view.\n */\nshaka.util.DataViewReader.prototype.readTerminatedString = function() {\n  var start = this.position_;\n  try {\n    while (this.hasMoreData()) {\n      var value = this.dataView_.getUint8(this.position_);\n      if (value == 0) break;\n      this.position_ += 1;\n    }\n  } catch (exception) {\n    this.throwOutOfBounds_();\n  }\n\n  var ret = this.dataView_.buffer.slice(start, this.position_);\n  // skip string termination\n  this.position_ += 1;\n  return shaka.util.StringUtils.fromUTF8(ret);\n};\n\n\n/**\n * @throws {shaka.util.Error}\n * @private\n */\nshaka.util.DataViewReader.prototype.throwOutOfBounds_ = function() {\n  throw new shaka.util.Error(\n      shaka.util.Error.Category.MEDIA,\n      shaka.util.Error.Code.BUFFER_READ_OUT_OF_BOUNDS);\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/util/ebml_parser.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.EbmlElement');\ngoog.provide('shaka.util.EbmlParser');\n\ngoog.require('shaka.util.DataViewReader');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n\n/**\n * Creates an Extensible Binary Markup Language (EBML) parser.\n * @param {!DataView} dataView The EBML data.\n * @constructor\n * @struct\n */\nshaka.util.EbmlParser = function(dataView) {\n  /** @private {!DataView} */\n  this.dataView_ = dataView;\n\n  /** @private {!shaka.util.DataViewReader} */\n  this.reader_ = new shaka.util.DataViewReader(\n      dataView,\n      shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n\n  // If not already constructed, build a list of EBML dynamic size constants.\n  // This is not done at load-time to avoid exceptions on unsupported browsers.\n  if (!shaka.util.EbmlParser.DYNAMIC_SIZES) {\n    shaka.util.EbmlParser.DYNAMIC_SIZES = [\n      new Uint8Array([0xff]),\n      new Uint8Array([0x7f, 0xff]),\n      new Uint8Array([0x3f, 0xff, 0xff]),\n      new Uint8Array([0x1f, 0xff, 0xff, 0xff]),\n      new Uint8Array([0x0f, 0xff, 0xff, 0xff, 0xff]),\n      new Uint8Array([0x07, 0xff, 0xff, 0xff, 0xff, 0xff]),\n      new Uint8Array([0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]),\n      new Uint8Array([0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])\n    ];\n  }\n};\n\n\n/** @const {!Array.<!Uint8Array>} */\nshaka.util.EbmlParser.DYNAMIC_SIZES;\n\n\n/**\n * @return {boolean} True if the parser has more data, false otherwise.\n */\nshaka.util.EbmlParser.prototype.hasMoreData = function() {\n  return this.reader_.hasMoreData();\n};\n\n\n/**\n * Parses an EBML element from the parser's current position, and advances\n * the parser.\n * @return {!shaka.util.EbmlElement} The EBML element.\n * @throws {shaka.util.Error}\n * @see http://matroska.org/technical/specs/rfc/index.html\n */\nshaka.util.EbmlParser.prototype.parseElement = function() {\n  var id = this.parseId_();\n\n  // Parse the element's size.\n  var vint = this.parseVint_();\n  var size;\n  if (shaka.util.EbmlParser.isDynamicSizeValue_(vint)) {\n    // If this has an unknown size, assume that it takes up the rest of the\n    // data.\n    size = this.dataView_.byteLength - this.reader_.getPosition();\n  } else {\n    size = shaka.util.EbmlParser.getVintValue_(vint);\n  }\n\n  // Note that if the element's size is larger than the buffer then we are\n  // parsing a \"partial element\". This may occur if for example we are\n  // parsing the beginning of some WebM container data, but our buffer does\n  // not contain the entire WebM container data.\n  var elementSize =\n      this.reader_.getPosition() + size <= this.dataView_.byteLength ?\n      size :\n      this.dataView_.byteLength - this.reader_.getPosition();\n\n  var dataView = new DataView(\n      this.dataView_.buffer,\n      this.dataView_.byteOffset + this.reader_.getPosition(), elementSize);\n\n  this.reader_.skip(elementSize);\n\n  return new shaka.util.EbmlElement(id, dataView);\n};\n\n\n/**\n * Parses an EBML ID from the parser's current position, and advances the\n * parser.\n * @throws {shaka.util.Error}\n * @return {number} The EBML ID.\n * @private\n */\nshaka.util.EbmlParser.prototype.parseId_ = function() {\n  var vint = this.parseVint_();\n\n  if (vint.length > 7) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.EBML_OVERFLOW);\n  }\n\n  var id = 0;\n  for (var i = 0; i < vint.length; i++) {\n    // Note that we cannot use << since |value| may exceed 32 bits.\n    id = (256 * id) + vint[i];\n  }\n\n  return id;\n};\n\n\n/**\n * Parses a variable sized integer from the parser's current position, and\n * advances the parser.\n * For example:\n *   1 byte  wide: 1xxx xxxx\n *   2 bytes wide: 01xx xxxx xxxx xxxx\n *   3 bytes wide: 001x xxxx xxxx xxxx xxxx xxxx\n * @throws {shaka.util.Error}\n * @return {!Uint8Array} The variable sized integer.\n * @private\n */\nshaka.util.EbmlParser.prototype.parseVint_ = function() {\n  var firstByte = this.reader_.readUint8();\n  var numBytes;\n\n  // Determine the byte width of the variable sized integer.\n  for (numBytes = 1; numBytes <= 8; numBytes++) {\n    var mask = 0x1 << (8 - numBytes);\n    if (firstByte & mask) {\n      break;\n    }\n  }\n\n  if (numBytes > 8) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.EBML_OVERFLOW);\n  }\n\n  var vint = new Uint8Array(numBytes);\n  vint[0] = firstByte;\n\n  // Include the remaining bytes.\n  for (var i = 1; i < numBytes; i++) {\n    vint[i] = this.reader_.readUint8();\n  }\n\n  return vint;\n};\n\n\n/**\n * Gets the value of a variable sized integer.\n * For example, the x's below are part of the vint's value.\n *    7-bit value: 1xxx xxxx\n *   14-bit value: 01xx xxxx xxxx xxxx\n *   21-bit value: 001x xxxx xxxx xxxx xxxx xxxx\n * @param {!Uint8Array} vint The variable sized integer.\n * @throws {shaka.util.Error}\n * @return {number} The value of the variable sized integer.\n * @private\n */\nshaka.util.EbmlParser.getVintValue_ = function(vint) {\n  // If |vint| is 8 bytes wide then we must ensure that it does not have more\n  // than 53 meaningful bits. For example, assume |vint| is 8 bytes wide,\n  // so it has the following structure,\n  // 0000 0001 | xxxx xxxx ...\n  // Thus, the the first 3 bits following the first byte of |vint| must be 0.\n  if ((vint.length == 8) && (vint[1] & 0xe0)) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.JS_INTEGER_OVERFLOW);\n  }\n\n  // Mask out the first few bits of |vint|'s first byte to get the most\n  // significant bits of |vint|'s value. If |vint| is 8 bytes wide then |value|\n  // will be set to 0.\n  var mask = 0x1 << (8 - vint.length);\n  var value = vint[0] & (mask - 1);\n\n  // Add the remaining bytes.\n  for (var i = 1; i < vint.length; i++) {\n    // Note that we cannot use << since |value| may exceed 32 bits.\n    value = (256 * value) + vint[i];\n  }\n\n  return value;\n};\n\n\n/**\n * Checks if the given variable sized integer represents a dynamic size value.\n * @param {!Uint8Array} vint The variable sized integer.\n * @return {boolean} true if |vint| represents a dynamic size value,\n *   false otherwise.\n * @private\n */\nshaka.util.EbmlParser.isDynamicSizeValue_ = function(vint) {\n  var EbmlParser = shaka.util.EbmlParser;\n  var uint8ArrayEqual = shaka.util.Uint8ArrayUtils.equal;\n\n  for (var i = 0; i < EbmlParser.DYNAMIC_SIZES.length; i++) {\n    if (uint8ArrayEqual(vint, EbmlParser.DYNAMIC_SIZES[i])) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\n\n\n/**\n * Creates an EbmlElement.\n * @param {number} id The ID.\n * @param {!DataView} dataView The DataView.\n * @constructor\n */\nshaka.util.EbmlElement = function(id, dataView) {\n  /** @type {number} */\n  this.id = id;\n\n  /** @private {!DataView} */\n  this.dataView_ = dataView;\n};\n\n\n/**\n * Gets the element's offset from the beginning of the buffer.\n * @return {number}\n */\nshaka.util.EbmlElement.prototype.getOffset = function() {\n  return this.dataView_.byteOffset;\n};\n\n\n/**\n * Interpret the element's data as a list of sub-elements.\n * @throws {shaka.util.Error}\n * @return {!shaka.util.EbmlParser} A parser over the sub-elements.\n */\nshaka.util.EbmlElement.prototype.createParser = function() {\n  return new shaka.util.EbmlParser(this.dataView_);\n};\n\n\n/**\n * Interpret the element's data as an unsigned integer.\n * @throws {shaka.util.Error}\n * @return {number}\n */\nshaka.util.EbmlElement.prototype.getUint = function() {\n  if (this.dataView_.byteLength > 8) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.EBML_OVERFLOW);\n  }\n\n  // Ensure we have at most 53 meaningful bits.\n  if ((this.dataView_.byteLength == 8) && (this.dataView_.getUint8(0) & 0xe0)) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.JS_INTEGER_OVERFLOW);\n  }\n\n  var value = 0;\n\n  for (var i = 0; i < this.dataView_.byteLength; i++) {\n    var chunk = this.dataView_.getUint8(i);\n    value = (256 * value) + chunk;\n  }\n\n  return value;\n};\n\n\n/**\n * Interpret the element's data as a floating point number (32 bits or 64 bits).\n * 80-bit floating point numbers are not supported.\n * @throws {shaka.util.Error}\n * @return {number}\n */\nshaka.util.EbmlElement.prototype.getFloat = function() {\n  if (this.dataView_.byteLength == 4) {\n    return this.dataView_.getFloat32(0);\n  } else if (this.dataView_.byteLength == 8) {\n    return this.dataView_.getFloat64(0);\n  } else {\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.EBML_BAD_FLOATING_POINT_SIZE);\n  }\n};\n\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/util/error.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.Error');\n\n\n\n/**\n * Creates a new Error.\n *\n * @param {shaka.util.Error.Category} category\n * @param {shaka.util.Error.Code} code\n * @param {...*} var_args\n *\n * @constructor\n * @struct\n * @export\n * @extends {Error}\n */\nshaka.util.Error = function(category, code, var_args) {\n  this.category = category;\n  this.code = code;\n  this.data = Array.prototype.slice.call(arguments, 2);\n\n  // This improves formatting of Errors in failure messages in the tests.\n  if (!COMPILED) {\n    var categoryName = 'UNKNOWN';\n    var codeName = 'UNKNOWN';\n\n    for (var k in shaka.util.Error.Category) {\n      if (shaka.util.Error.Category[k] == this.category)\n        categoryName = k;\n    }\n    for (var k in shaka.util.Error.Code) {\n      if (shaka.util.Error.Code[k] == this.code)\n        codeName = k;\n    }\n\n    /**\n     * A human-readable version of the category and code.\n     * <i>(Only available in uncompiled mode.)</i>\n     *\n     * @const {string}\n     * @exportDoc\n     */\n    this.message = 'Shaka Error ' + categoryName + '.' + codeName +\n                   ' (' + this.data.toString() + ')';\n    try {\n      throw new Error(this.message);\n    } catch (e) {\n      /**\n       * A stack-trace showing where the error occurred.\n       * <i>(Only available in uncompiled mode.)</i>\n       *\n       * @const {string}\n       * @exportDoc\n       */\n      this.stack = e.stack;\n    }\n  }\n};\n\n\n/**\n * @const {shaka.util.Error.Category}\n * @expose\n */\nshaka.util.Error.prototype.category;\n\n\n/**\n * @const {shaka.util.Error.Code}\n * @expose\n */\nshaka.util.Error.prototype.code;\n\n\n/**\n * @const {!Array.<*>}\n * @expose\n */\nshaka.util.Error.prototype.data;\n\n\n/**\n * @return {string}\n * @override\n */\nshaka.util.Error.prototype.toString = function() {\n  return 'shaka.util.Error ' + JSON.stringify(this, null, '  ');\n};\n\n\n/**\n * @enum {number}\n * @export\n */\nshaka.util.Error.Category = {\n  /** Errors from the network stack. */\n  'NETWORK': 1,\n\n  /** Errors parsing text streams. */\n  'TEXT': 2,\n\n  /** Errors parsing or processing audio or video streams. */\n  'MEDIA': 3,\n\n  /** Errors parsing the Manifest. */\n  'MANIFEST': 4,\n\n  /** Errors related to streaming. */\n  'STREAMING': 5,\n\n  /** Errors related to DRM. */\n  'DRM': 6,\n\n  /** Miscellaneous errors from the player. */\n  'PLAYER': 7,\n\n  /** Errors related to cast. */\n  'CAST': 8,\n\n  /** Errors in the database storage (offline). */\n  'STORAGE': 9\n};\n\n\n/**\n * @enum {number}\n * @export\n */\nshaka.util.Error.Code = {\n  /**\n   * A network request was made using an unsupported URI scheme.\n   * <br> error.data[0] is the URI.\n   */\n  'UNSUPPORTED_SCHEME': 1000,\n\n  /**\n   * An HTTP network request returned an HTTP status that indicated a failure.\n   * <br> error.data[0] is the URI.\n   * <br> error.data[1] is the status code.\n   * <br> error.data[2] is the response text, or null if the response could not\n   *   be interpretted as text.\n   * <br> error.data[3] is the map of response headers.\n   */\n  'BAD_HTTP_STATUS': 1001,\n\n  /**\n   * An HTTP network request failed with an error, but not from the server.\n   * <br> error.data[0] is the URI.\n   */\n  'HTTP_ERROR': 1002,\n\n  /**\n   * A network request timed out.\n   * <br> error.data[0] is the URI.\n   */\n  'TIMEOUT': 1003,\n\n  /**\n   * A network request was made with a malformed data URI.\n   * <br> error.data[0] is the URI.\n   */\n  'MALFORMED_DATA_URI': 1004,\n\n  /**\n   * A network request was made with a data URI using an unknown encoding.\n   * <br> error.data[0] is the URI.\n   */\n  'UNKNOWN_DATA_URI_ENCODING': 1005,\n\n\n  /** The text parser failed to parse a text stream due to an invalid header. */\n  'INVALID_TEXT_HEADER': 2000,\n\n  /** The text parser failed to parse a text stream due to an invalid cue. */\n  'INVALID_TEXT_CUE': 2001,\n\n  // RETIRED: 'INVALID_TEXT_SETTINGS': 2002,\n\n  /**\n   * Was unable to detect the encoding of the response text.  Suggest adding\n   * byte-order-markings to the response data.\n   */\n  'UNABLE_TO_DETECT_ENCODING': 2003,\n\n  /** The response data contains invalid Unicode character encoding. */\n  'BAD_ENCODING': 2004,\n\n  /**\n   * The XML parser failed to parse an xml stream.\n   */\n  'INVALID_XML': 2005,\n\n  /**\n   * TTML stream lacks mandatory elements.\n   */\n  'INVALID_TTML': 2006,\n\n  /**\n   * MP4 segment does not contain TTML.\n   */\n  'INVALID_MP4_TTML': 2007,\n\n  /**\n   * MP4 segment does not contain VTT.\n   */\n  'INVALID_MP4_VTT': 2008,\n\n\n  /**\n   * Some component tried to read past the end of a buffer.  The segment index,\n   * init segment, or PSSH may be malformed.\n   */\n  'BUFFER_READ_OUT_OF_BOUNDS': 3000,\n\n  /**\n   * Some component tried to parse an integer that was too large to fit in a\n   * JavaScript number without rounding error.  JavaScript can only natively\n   * represent integers up to 53 bits.\n   */\n  'JS_INTEGER_OVERFLOW': 3001,\n\n  /**\n   * The EBML parser used to parse the WebM container encountered an integer,\n   * ID, or other field larger than the maximum supported by the parser.\n   */\n  'EBML_OVERFLOW': 3002,\n\n  /**\n   * The EBML parser used to parse the WebM container encountered a floating-\n   * point field of a size not supported by the parser.\n   */\n  'EBML_BAD_FLOATING_POINT_SIZE': 3003,\n\n  /**\n   * The MP4 SIDX parser found the wrong box type.\n   * Either the segment index range is incorrect or the data is corrupt.\n   */\n  'MP4_SIDX_WRONG_BOX_TYPE': 3004,\n\n  /**\n   * The MP4 SIDX parser encountered an invalid timescale.\n   * The segment index data may be corrupt.\n   */\n  'MP4_SIDX_INVALID_TIMESCALE': 3005,\n\n  /** The MP4 SIDX parser encountered a type of SIDX that is not supported. */\n  'MP4_SIDX_TYPE_NOT_SUPPORTED': 3006,\n\n  /**\n   * The WebM Cues parser was unable to locate the Cues element.\n   * The segment index data may be corrupt.\n   */\n  'WEBM_CUES_ELEMENT_MISSING': 3007,\n\n  /**\n   * The WebM header parser was unable to locate the Ebml element.\n   * The init segment data may be corrupt.\n   */\n  'WEBM_EBML_HEADER_ELEMENT_MISSING': 3008,\n\n  /**\n   * The WebM header parser was unable to locate the Segment element.\n   * The init segment data may be corrupt.\n   */\n  'WEBM_SEGMENT_ELEMENT_MISSING': 3009,\n\n  /**\n   * The WebM header parser was unable to locate the Info element.\n   * The init segment data may be corrupt.\n   */\n  'WEBM_INFO_ELEMENT_MISSING': 3010,\n\n  /**\n   * The WebM header parser was unable to locate the Duration element.\n   * The init segment data may be corrupt or may have been incorrectly encoded.\n   * Shaka requires a duration in WebM DASH content.\n   */\n  'WEBM_DURATION_ELEMENT_MISSING': 3011,\n\n  /**\n   * The WebM Cues parser was unable to locate the Cue Track Positions element.\n   * The segment index data may be corrupt.\n   */\n  'WEBM_CUE_TRACK_POSITIONS_ELEMENT_MISSING': 3012,\n\n  /**\n   * The WebM Cues parser was unable to locate the Cue Time element.\n   * The segment index data may be corrupt.\n   */\n  'WEBM_CUE_TIME_ELEMENT_MISSING': 3013,\n\n  /**\n   * A MediaSource operation failed.\n   * <br> error.data[0] is a MediaError code from the video element.\n   */\n  'MEDIA_SOURCE_OPERATION_FAILED': 3014,\n\n  /**\n   * A MediaSource operation threw an exception.\n   * <br> error.data[0] is the exception that was thrown.\n   */\n  'MEDIA_SOURCE_OPERATION_THREW': 3015,\n\n  /**\n   * The video element reported an error.\n   * <br> error.data[0] is a MediaError code from the video element.\n   * <br> On Edge & IE, error.data[1] is a Microsoft extended error code in hex.\n   */\n  'VIDEO_ERROR': 3016,\n\n  /**\n   * A MediaSource operation threw QuotaExceededError and recovery failed. The\n   * content cannot be played correctly because the segments are too large for\n   * the browser/platform. This may occur when attempting to play very high\n   * quality, very high bitrate content on low-end devices.\n   * <br> error.data[0] is the type of content which caused the error.\n   */\n  'QUOTA_EXCEEDED_ERROR': 3017,\n\n\n  /**\n   * The Player was unable to guess the manifest type based on file extension\n   * or MIME type.  To fix, try one of the following:\n   * <br><ul>\n   *   <li>Rename the manifest so that the URI ends in a well-known extension.\n   *   <li>Configure the server to send a recognizable Content-Type header.\n   *   <li>Configure the server to accept a HEAD request for the manifest.\n   * </ul>\n   * <br> error.data[0] is the manifest URI.\n   */\n  'UNABLE_TO_GUESS_MANIFEST_TYPE': 4000,\n\n  /** The DASH Manifest contained invalid XML markup. */\n  'DASH_INVALID_XML': 4001,\n\n  /**\n   * The DASH Manifest contained a Representation with insufficient segment\n   * information.\n   */\n  'DASH_NO_SEGMENT_INFO': 4002,\n\n  /** The DASH Manifest contained an AdaptationSet with no Representations. */\n  'DASH_EMPTY_ADAPTATION_SET': 4003,\n\n  /** The DASH Manifest contained an Period with no AdaptationSets. */\n  'DASH_EMPTY_PERIOD': 4004,\n\n  /**\n   * The DASH Manifest does not specify an init segment with a WebM container.\n   */\n  'DASH_WEBM_MISSING_INIT': 4005,\n\n  /** The DASH Manifest contained an unsupported container format. */\n  'DASH_UNSUPPORTED_CONTAINER': 4006,\n\n  /** The embedded PSSH data has invalid encoding. */\n  'DASH_PSSH_BAD_ENCODING': 4007,\n\n  /**\n   * There is an AdaptationSet whose Representations do not have any common\n   * key-systems.\n   */\n  'DASH_NO_COMMON_KEY_SYSTEM': 4008,\n\n  /** Having multiple key IDs per Representation is not supported. */\n  'DASH_MULTIPLE_KEY_IDS_NOT_SUPPORTED': 4009,\n\n  /** The DASH Manifest specifies conflicting key IDs. */\n  'DASH_CONFLICTING_KEY_IDS': 4010,\n\n  /**\n   * The manifest contains a period with no playable streams.\n   * Either the period was originally empty, or the streams within cannot be\n   * played on this browser or platform.\n   */\n  'UNPLAYABLE_PERIOD': 4011,\n\n  /**\n   * There exist some streams that could be decoded, but restrictions imposed\n   * by the application or the key system prevent us from playing.  This may\n   * happen under the following conditions:\n   * <ul>\n   *   <li>The application has given restrictions to the Player that restrict\n   *       at least one content type completely (e.g. no playable audio).\n   *   <li>The key system has imposed output restrictions that cannot be met\n   *       (such as HDCP) and there are no unrestricted alternatives.\n   * </ul>\n   */\n  'RESTRICTIONS_CANNOT_BE_MET': 4012,\n\n  // RETIRED: 'INTERNAL_ERROR_KEY_STATUS': 4013,\n\n  /**\n   * No valid periods were found in the manifest.  Please check that your\n   * manifest is correct and free of typos.\n   */\n  'NO_PERIODS': 4014,\n\n\n  /**\n   * A Representation has an id that is the same as another Representation in\n   * the same Period.  This makes manifest updates impossible since we cannot\n   * map the updated Representation to the old one.\n   */\n  'DASH_DUPLICATE_REPRESENTATION_ID': 4018,\n\n  // RETIRED: 'INCONSISTENT_BUFFER_STATE': 5000,\n  // RETIRED: 'INVALID_SEGMENT_INDEX': 5001,\n  // RETIRED: 'SEGMENT_DOES_NOT_EXIST': 5002,\n  // RETIRED: 'CANNOT_SATISFY_BYTE_LIMIT': 5003,\n  // RETIRED: 'BAD_SEGMENT': 5004,\n\n  /**\n   * The StreamingEngine called onChooseStreams() but the callback receiver\n   * did not return the correct number or type of Streams.\n   *\n   * This can happen when there is multi-Period content where one Period is\n   * video+audio and another is video-only or audio-only.  We don't support this\n   * case because it is incompatible with MSE.  When the browser reaches the\n   * transition, it will pause, waiting for the audio stream.\n   */\n  'INVALID_STREAMS_CHOSEN': 5005,\n\n\n  /**\n   * The manifest indicated protected content, but the manifest parser was\n   * unable to determine what key systems should be used.\n   */\n  'NO_RECOGNIZED_KEY_SYSTEMS': 6000,\n\n  /**\n   * None of the requested key system configurations are available.  This may\n   * happen under the following conditions:\n   * <ul>\n   *   <li> The key system is not supported.\n   *   <li> The key system does not support the features requested (e.g.\n   *        persistent state).\n   *   <li> A user prompt was shown and the user denied access.\n   *   <li> The key system is not available from unsecure contexts. (ie.\n            requires HTTPS) See https://goo.gl/EEhZqT.\n   * </ul>\n   */\n  'REQUESTED_KEY_SYSTEM_CONFIG_UNAVAILABLE': 6001,\n\n  /**\n   * The browser found one of the requested key systems, but it failed to\n   * create an instance of the CDM for some unknown reason.\n   * <br> error.data[0] is an error message string from the browser.\n   */\n  'FAILED_TO_CREATE_CDM': 6002,\n\n  /**\n   * The browser found one of the requested key systems and created an instance\n   * of the CDM, but it failed to attach the CDM to the video for some unknown\n   * reason.\n   * <br> error.data[0] is an error message string from the browser.\n   */\n  'FAILED_TO_ATTACH_TO_VIDEO': 6003,\n\n  /**\n   * The CDM rejected the server certificate supplied by the application.\n   * The certificate may be malformed or in an unsupported format.\n   * <br> error.data[0] is an error message string from the browser.\n   */\n  'INVALID_SERVER_CERTIFICATE': 6004,\n\n  /**\n   * The CDM refused to create a session for some unknown reason.\n   * <br> error.data[0] is an error message string from the browser.\n   */\n  'FAILED_TO_CREATE_SESSION': 6005,\n\n  /**\n   * The CDM was unable to generate a license request for the init data it was\n   * given.  The init data may be malformed or in an unsupported format.\n   * <br> error.data[0] is an error message string from the browser.\n   */\n  'FAILED_TO_GENERATE_LICENSE_REQUEST': 6006,\n\n  /**\n   * The license request failed.  This could be a timeout, a network failure, or\n   * a rejection by the server.\n   * <br> error.data[0] is a shaka.util.Error from the networking engine.\n   */\n  'LICENSE_REQUEST_FAILED': 6007,\n\n  /**\n   * The license response was rejected by the CDM.  The server's response may be\n   * invalid or malformed for this CDM.\n   * <br> error.data[0] is an error message string from the browser.\n   */\n  'LICENSE_RESPONSE_REJECTED': 6008,\n\n  // RETIRED: 'NO_LICENSE_SERVER_SPECIFIED': 6009,\n\n  /**\n   * The manifest does not specify any DRM info, but the content is encrypted.\n   * Either the manifest or the manifest parser are broken.\n   */\n  'ENCRYPTED_CONTENT_WITHOUT_DRM_INFO': 6010,\n\n  // RETIRED: 'WRONG_KEYS': 6011,\n\n  /**\n   * No license server was given for the key system signaled by the manifest.\n   * A license server URI is required for every key system.\n   */\n  'NO_LICENSE_SERVER_GIVEN': 6012,\n\n  /**\n   * A required offline session was removed.  The content is not playable.\n   */\n  'OFFLINE_SESSION_REMOVED': 6013,\n\n  /**\n   * The license has expired.  This is triggered when playback is stalled on a\n   * 'waitingforkeys' event and there are any expired keys in the key status map\n   * of any active session.\n   */\n  'EXPIRED': 6014,\n\n\n  /**\n   * The call to Player.load() was interrupted by a call to Player.unload()\n   * or another call to Player.load().\n   */\n  'LOAD_INTERRUPTED': 7000,\n\n\n  /**\n   * The Cast API is unavailable.  This may be because of one of the following:\n   * - The browser may not have Cast support\n   * - The browser may be missing a necessary Cast extension\n   * - The Cast sender library may not be loaded in your app\n   */\n  'CAST_API_UNAVAILABLE': 8000,\n\n  /**\n   * No cast receivers are available at this time.\n   */\n  'NO_CAST_RECEIVERS': 8001,\n\n  /**\n   * The library is already casting.\n   */\n  'ALREADY_CASTING': 8002,\n\n  /**\n   * A Cast SDK error that we did not explicitly plan for has occurred.\n   * Check data[0] and refer to the Cast SDK documentation for details.\n   * <br> error.data[0] is an error object from the Cast SDK.\n   */\n  'UNEXPECTED_CAST_ERROR': 8003,\n\n  /**\n   * The cast operation was canceled by the user.\n   * <br> error.data[0] is an error object from the Cast SDK.\n   */\n  'CAST_CANCELED_BY_USER': 8004,\n\n  /**\n   * The cast connection timed out.\n   * <br> error.data[0] is an error object from the Cast SDK.\n   */\n  'CAST_CONNECTION_TIMED_OUT': 8005,\n\n  /**\n   * The requested receiver app ID does not exist or is unavailable.\n   * Check the requested app ID for typos.\n   * <br> error.data[0] is an error object from the Cast SDK.\n   */\n  'CAST_RECEIVER_APP_UNAVAILABLE': 8006,\n\n\n  /**\n   * IndexedDb is not supported on this browser; it is required for offline\n   * support.\n   */\n  'INDEXED_DB_NOT_SUPPORTED': 9000,\n\n  /**\n   * An unknown error occurred in the IndexedDB.\n   * <br> error.data[0] is the error object.\n   */\n  'INDEXED_DB_ERROR': 9001,\n\n  /**\n   * The operation was aborted.  For example, by a call to destroy().\n   */\n  'OPERATION_ABORTED': 9002,\n\n  /**\n   * The specified item was not found in the IndexedDB.\n   * <br> error.data[0] is the offline URI.\n   */\n  'REQUESTED_ITEM_NOT_FOUND': 9003,\n\n  /**\n   * A network request was made with a malformed offline URI.\n   * <br> error.data[0] is the URI.\n   */\n  'MALFORMED_OFFLINE_URI': 9004,\n\n  /**\n   * The specified content is live or in-progress.\n   * Live and in-progress streams cannot be stored offline.\n   * <br> error.data[0] is the URI.\n   */\n  'CANNOT_STORE_LIVE_OFFLINE': 9005,\n\n  /**\n   * There is already a store operation in-progress, wait until it completes\n   * before starting another.\n   */\n  'STORE_ALREADY_IN_PROGRESS': 9006,\n\n  /**\n   * The specified manifest is encrypted but does not specify any init data.\n   * Without init data specified in the manifest, the content will not be\n   * playable offline.\n   * <br> error.data[0] is the URI.\n   */\n  'NO_INIT_DATA_FOR_OFFLINE': 9007\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/util/event_manager.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.EventManager');\n\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.MultiMap');\n\n\n\n/**\n * Creates a new EventManager. An EventManager maintains a collection of \"event\n * bindings\" between event targets and event listeners.\n *\n * @struct\n * @constructor\n * @implements {shaka.util.IDestroyable}\n */\nshaka.util.EventManager = function() {\n  /**\n   * Maps an event type to an array of event bindings.\n   * @private {shaka.util.MultiMap.<!shaka.util.EventManager.Binding_>}\n   */\n  this.bindingMap_ = new shaka.util.MultiMap();\n};\n\n\n/**\n * @typedef {function(!Event)}\n */\nshaka.util.EventManager.ListenerType;\n\n\n/**\n * Detaches all event listeners.\n * @override\n */\nshaka.util.EventManager.prototype.destroy = function() {\n  this.removeAll();\n  this.bindingMap_ = null;\n  return Promise.resolve();\n};\n\n\n/**\n * Attaches an event listener to an event target.\n * @param {EventTarget} target The event target.\n * @param {string} type The event type.\n * @param {shaka.util.EventManager.ListenerType} listener The event listener.\n */\nshaka.util.EventManager.prototype.listen = function(target, type, listener) {\n  var binding = new shaka.util.EventManager.Binding_(target, type, listener);\n  this.bindingMap_.push(type, binding);\n};\n\n\n/**\n * Detaches an event listener from an event target.\n * @param {EventTarget} target The event target.\n * @param {string} type The event type.\n */\nshaka.util.EventManager.prototype.unlisten = function(target, type) {\n  var list = this.bindingMap_.get(type) || [];\n\n  for (var i = 0; i < list.length; ++i) {\n    var binding = list[i];\n\n    if (binding.target == target) {\n      binding.unlisten();\n      this.bindingMap_.remove(type, binding);\n    }\n  }\n};\n\n\n/**\n * Detaches all event listeners from all targets.\n */\nshaka.util.EventManager.prototype.removeAll = function() {\n  var list = this.bindingMap_.getAll();\n\n  for (var i = 0; i < list.length; ++i) {\n    list[i].unlisten();\n  }\n\n  this.bindingMap_.clear();\n};\n\n\n\n/**\n * Creates a new Binding_ and attaches the event listener to the event target.\n * @param {EventTarget} target The event target.\n * @param {string} type The event type.\n * @param {shaka.util.EventManager.ListenerType} listener The event listener.\n * @constructor\n * @private\n */\nshaka.util.EventManager.Binding_ = function(target, type, listener) {\n  /** @type {EventTarget} */\n  this.target = target;\n\n  /** @type {string} */\n  this.type = type;\n\n  /** @type {?shaka.util.EventManager.ListenerType} */\n  this.listener = listener;\n\n  this.target.addEventListener(type, listener, false);\n};\n\n\n/**\n * Detaches the event listener from the event target. This does nothing if the\n * event listener is already detached.\n */\nshaka.util.EventManager.Binding_.prototype.unlisten = function() {\n  if (!this.target)\n    return;\n\n  this.target.removeEventListener(this.type, this.listener, false);\n\n  this.target = null;\n  this.listener = null;\n};\n\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/util/fake_event.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.FakeEvent');\n\n\n\n/**\n * Create an Event work-alike object based on the dictionary.\n * The event should contain all of the same properties from the dict.\n *\n * @param {string} type\n * @param {Object=} opt_dict\n * @constructor\n * @extends {Event}\n */\nshaka.util.FakeEvent = function(type, opt_dict) {\n  // Take properties from dict if present.\n  var dict = opt_dict || {};\n  for (var key in dict) {\n    this[key] = dict[key];\n  }\n\n\n  // These Properties below cannot be set by dict.  They are all provided for\n  // compatibility with native events.\n\n  /** @const {boolean} */\n  this.bubbles = false;\n\n  /** @const {boolean} */\n  this.cancelable = false;\n\n  /** @const {boolean} */\n  this.defaultPrevented = false;\n\n  /**\n   * According to MDN, Chrome uses high-res timers instead of epoch time.\n   * Follow suit so that timeStamps on FakeEvents use the same base as\n   * on native Events.\n   * @const {number}\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Event/timeStamp\n   */\n  this.timeStamp = window.performance && window.performance.now ?\n      window.performance.now() : Date.now();\n\n  /** @const {string} */\n  this.type = type;\n\n  /** @const {boolean} */\n  this.isTrusted = false;\n\n  /** @type {EventTarget} */\n  this.currentTarget = null;\n\n  /** @type {EventTarget} */\n  this.target = null;\n\n\n  /**\n   * Non-standard property read by FakeEventTarget to stop processing listeners.\n   * @type {boolean}\n   */\n  this.stopped = false;\n};\n\n\n/**\n * Does nothing, since FakeEvents have no default.  Provided for compatibility\n * with native Events.\n * @override\n */\nshaka.util.FakeEvent.prototype.preventDefault = function() {};\n\n\n/**\n * Stops processing event listeners for this event.  Provided for compatibility\n * with native Events.\n * @override\n */\nshaka.util.FakeEvent.prototype.stopImmediatePropagation = function() {\n  this.stopped = true;\n};\n\n\n/**\n * Does nothing, since FakeEvents do not bubble.  Provided for compatibility\n * with native Events.\n * @override\n */\nshaka.util.FakeEvent.prototype.stopPropagation = function() {};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/util/fake_event_target.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.FakeEventTarget');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.MultiMap');\n\n\n\n/**\n * A work-alike for EventTarget.  Only DOM elements may be true EventTargets,\n * but this can be used as a base class to provide event dispatch to non-DOM\n * classes.  Only FakeEvents should be dispatched.\n *\n * @struct\n * @constructor\n * @implements {EventTarget}\n * @exportInterface\n */\nshaka.util.FakeEventTarget = function() {\n  /**\n   * @private {!shaka.util.MultiMap.<shaka.util.FakeEventTarget.ListenerType>}\n   */\n  this.listeners_ = new shaka.util.MultiMap();\n\n  /**\n   * The target of all dispatched events.  Defaults to |this|.\n   * @type {EventTarget}\n   */\n  this.dispatchTarget = this;\n};\n\n\n/**\n * These are the listener types defined in the closure extern for EventTarget.\n * @typedef {EventListener|function(!Event):(boolean|undefined)}\n * @exportInterface\n */\nshaka.util.FakeEventTarget.ListenerType;\n\n\n/**\n * Add an event listener to this object.\n *\n * @param {string} type The event type to listen for.\n * @param {shaka.util.FakeEventTarget.ListenerType} listener The callback or\n *   listener object to invoke.\n * @param {boolean=} opt_capturing Ignored.  FakeEventTargets do not have\n *   parents, so events neither capture nor bubble.\n * @override\n * @exportInterface\n */\nshaka.util.FakeEventTarget.prototype.addEventListener =\n    function(type, listener, opt_capturing) {\n  this.listeners_.push(type, listener);\n};\n\n\n/**\n * Remove an event listener from this object.\n *\n * @param {string} type The event type for which you wish to remove a listener.\n * @param {shaka.util.FakeEventTarget.ListenerType} listener The callback or\n *   listener object to remove.\n * @param {boolean=} opt_capturing Ignored.  FakeEventTargets do not have\n *   parents, so events neither capture nor bubble.\n * @override\n * @exportInterface\n */\nshaka.util.FakeEventTarget.prototype.removeEventListener =\n    function(type, listener, opt_capturing) {\n  this.listeners_.remove(type, listener);\n};\n\n\n/**\n * Dispatch an event from this object.\n *\n * @param {!Event} event The event to be dispatched from this object.\n * @return {boolean} True if the default action was prevented.\n * @override\n * @exportInterface\n */\nshaka.util.FakeEventTarget.prototype.dispatchEvent = function(event) {\n  // In many browsers, it is complex to overwrite properties of actual Events.\n  // Here we expect only to dispatch FakeEvents, which are simpler.\n  goog.asserts.assert(event instanceof shaka.util.FakeEvent,\n                      'FakeEventTarget can only dispatch FakeEvents!');\n\n  var list = this.listeners_.get(event.type) || [];\n\n  for (var i = 0; i < list.length; ++i) {\n    // Do this every time, since events can be re-dispatched from handlers.\n    event.target = this.dispatchTarget;\n    event.currentTarget = this.dispatchTarget;\n\n    var listener = list[i];\n    try {\n      if (listener.handleEvent) {\n        listener.handleEvent(event);\n      } else {\n        listener.call(this, event);\n      }\n    } catch (exception) {\n      // Exceptions during event handlers should not affect the caller,\n      // but should appear on the console as uncaught, according to MDN:\n      // http://goo.gl/N6Ff27\n      shaka.log.error('Uncaught exception in event handler', exception);\n    }\n\n    if (event.stopped) {\n      break;\n    }\n  }\n\n  return event.defaultPrevented;\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/util/functional.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.Functional');\n\n\n/**\n * @namespace shaka.util.Functional\n * @summary A set of functional utility functions.\n */\n\n\n/**\n * Creates a promise chain that calls the given callback for each element in\n * the array in a catch of a promise.\n *\n * e.g.:\n * Promise.reject().catch(callback(array[0])).catch(callback(array[1]));\n *\n * @param {!Array.<ELEM>} array\n * @param {function(ELEM):!Promise.<RESULT>} callback\n * @return {!Promise.<RESULT>}\n * @template ELEM,RESULT\n */\nshaka.util.Functional.createFallbackPromiseChain = function(array, callback) {\n  return array.reduce(function(callback, promise, elem) {\n    return promise.catch(callback.bind(null, elem));\n  }.bind(null, callback), Promise.reject());\n};\n\n\n/**\n * Returns the first array concatenated to the second; used to collapse an\n * array of arrays into a single array.\n *\n * @param {!Array.<T>} all\n * @param {!Array.<T>} part\n * @return {!Array.<T>}\n * @template T\n */\nshaka.util.Functional.collapseArrays = function(all, part) {\n  return all.concat(part);\n};\n\n\n/**\n * A no-op function.  Useful in promise chains.\n */\nshaka.util.Functional.noop = function() {};\n\n\n/**\n * Returns if the given value is not null; useful for filtering out null values.\n *\n * @param {T} value\n * @return {boolean}\n * @template T\n */\nshaka.util.Functional.isNotNull = function(value) {\n  return value != null;\n};\n\n\n/**\n * Creates a function that returns whether the given value is equal to the given\n * value.\n *\n * @param {T} compare\n * @return {function(T):boolean}\n * @template T\n */\nshaka.util.Functional.isEqualFunc = function(compare) {\n  return function(a) { return a == compare; };\n};\n\n\n/**\n * Creates a function that returns whether the given value is not equal to the\n * given value.\n *\n * @param {T} compare\n * @return {function(T):boolean}\n * @template T\n */\nshaka.util.Functional.isNotEqualFunc = function(compare) {\n  return function(a) { return a != compare; };\n};\n\n\n/**\n * Used to filter out duplicates in an array.\n * Returns true the first time the element is encountered. Returns false\n * for all the subsequent encounters.\n *\n * @param {T} item\n * @param {number} position\n * @param {!Array.<T>} self\n * @return {boolean}\n * @template T\n * @example [1, 1, 2].filter(shaka.util.Functional.isNotDuplicate) -> [1, 2]\n */\nshaka.util.Functional.isNotDuplicate = function(item, position, self) {\n  return self.indexOf(item) == position;\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/util/i_destroyable.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.IDestroyable');\n\n\n\n/**\n * An interface to standardize how objects are destroyed.\n * @interface\n * @exportInterface\n */\nshaka.util.IDestroyable = function() {};\n\n\n/**\n * Destroys the object, releasing all resources and shutting down all\n * operations.  Returns a Promise which is resolved when destruction is\n * complete.  This Promise should never be rejected.\n *\n * @return {!Promise}\n * @exportInterface\n */\nshaka.util.IDestroyable.prototype.destroy = function() {};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/util/language_utils.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.LanguageUtils');\n\ngoog.require('goog.asserts');\n\n\n/**\n * @namespace shaka.util.LanguageUtils\n * @summary A set of language utility functions.\n */\n\n\n/**\n * Compares two language tags as defined by RFC 5646 and ISO 639.  The\n * comparison takes sublanguages into account via the |fuzz| parameter.\n * The caller is expected to normalize the inputs first.\n *\n * @see shaka.util.LanguageUtils.normalize()\n * @see IETF RFC 5646\n * @see ISO 639\n *\n * @param {shaka.util.LanguageUtils.MatchType} fuzz What kind of match is\n *   acceptable.\n * @param {string} preference The user's preferred language tag.\n * @param {string} candidate An available language tag.\n * @return {boolean}\n */\nshaka.util.LanguageUtils.match = function(fuzz, preference, candidate) {\n  // Alias.\n  var LanguageUtils = shaka.util.LanguageUtils;\n\n  goog.asserts.assert(preference == LanguageUtils.normalize(preference),\n                      'Language pref should be normalized first');\n  goog.asserts.assert(candidate == LanguageUtils.normalize(candidate),\n                      'Language candidate should be normalized first');\n\n  if (candidate == preference) {\n    return true;\n  }\n\n  if (fuzz >= shaka.util.LanguageUtils.MatchType.BASE_LANGUAGE_OKAY &&\n      candidate == preference.split('-')[0]) {\n    return true;\n  }\n\n  if (fuzz >= shaka.util.LanguageUtils.MatchType.OTHER_SUB_LANGUAGE_OKAY &&\n      candidate.split('-')[0] == preference.split('-')[0]) {\n    return true;\n  }\n\n  return false;\n};\n\n\n/**\n * A match type for fuzzy-matching logic.\n *\n * @enum {number}\n */\nshaka.util.LanguageUtils.MatchType = {\n  /** Accepts an exact match. */\n  EXACT: 0,\n  /** Accepts a less-specific version of the preferred sublanguage. */\n  BASE_LANGUAGE_OKAY: 1,\n  /** Accepts a different sublanguage of the preferred base language. */\n  OTHER_SUB_LANGUAGE_OKAY: 2\n};\n\n\n/**\n * Normalize the language tag.\n *\n * RFC 5646 specifies that language tags are case insensitive and that the\n * shortest representation of the base language should always be used.\n * This will convert the tag to lower-case and map 3-letter codes (ISO 639-2)\n * to 2-letter codes (ISO 639-1) whenever possible.\n *\n * @param {string} lang\n * @return {string}\n *\n * @see IETF RFC 5646\n * @see ISO 639\n */\nshaka.util.LanguageUtils.normalize = function(lang) {\n  var fields = lang.toLowerCase().split('-');\n  var base = fields[0];\n  var replacement = shaka.util.LanguageUtils.isoMap_[base];\n  if (replacement) {\n    fields[0] = replacement;\n  }\n  return fields.join('-');\n};\n\n\n/**\n * A map from 3-letter language codes (ISO 639-2) to 2-letter language codes\n * (ISO 639-1) for all languages which have both in the registry.\n *\n * @const {!Object.<string, string>}\n * @private\n */\nshaka.util.LanguageUtils.isoMap_ = {\n  'aar': 'aa', 'abk': 'ab', 'afr': 'af', 'aka': 'ak', 'alb': 'sq', 'amh': 'am',\n  'ara': 'ar', 'arg': 'an', 'arm': 'hy', 'asm': 'as', 'ava': 'av', 'ave': 'ae',\n  'aym': 'ay', 'aze': 'az', 'bak': 'ba', 'bam': 'bm', 'baq': 'eu', 'bel': 'be',\n  'ben': 'bn', 'bih': 'bh', 'bis': 'bi', 'bod': 'bo', 'bos': 'bs', 'bre': 'br',\n  'bul': 'bg', 'bur': 'my', 'cat': 'ca', 'ces': 'cs', 'cha': 'ch', 'che': 'ce',\n  'chi': 'zh', 'chu': 'cu', 'chv': 'cv', 'cor': 'kw', 'cos': 'co', 'cre': 'cr',\n  'cym': 'cy', 'cze': 'cs', 'dan': 'da', 'deu': 'de', 'div': 'dv', 'dut': 'nl',\n  'dzo': 'dz', 'ell': 'el', 'eng': 'en', 'epo': 'eo', 'est': 'et', 'eus': 'eu',\n  'ewe': 'ee', 'fao': 'fo', 'fas': 'fa', 'fij': 'fj', 'fin': 'fi', 'fra': 'fr',\n  'fre': 'fr', 'fry': 'fy', 'ful': 'ff', 'geo': 'ka', 'ger': 'de', 'gla': 'gd',\n  'gle': 'ga', 'glg': 'gl', 'glv': 'gv', 'gre': 'el', 'grn': 'gn', 'guj': 'gu',\n  'hat': 'ht', 'hau': 'ha', 'heb': 'he', 'her': 'hz', 'hin': 'hi', 'hmo': 'ho',\n  'hrv': 'hr', 'hun': 'hu', 'hye': 'hy', 'ibo': 'ig', 'ice': 'is', 'ido': 'io',\n  'iii': 'ii', 'iku': 'iu', 'ile': 'ie', 'ina': 'ia', 'ind': 'id', 'ipk': 'ik',\n  'isl': 'is', 'ita': 'it', 'jav': 'jv', 'jpn': 'ja', 'kal': 'kl', 'kan': 'kn',\n  'kas': 'ks', 'kat': 'ka', 'kau': 'kr', 'kaz': 'kk', 'khm': 'km', 'kik': 'ki',\n  'kin': 'rw', 'kir': 'ky', 'kom': 'kv', 'kon': 'kg', 'kor': 'ko', 'kua': 'kj',\n  'kur': 'ku', 'lao': 'lo', 'lat': 'la', 'lav': 'lv', 'lim': 'li', 'lin': 'ln',\n  'lit': 'lt', 'ltz': 'lb', 'lub': 'lu', 'lug': 'lg', 'mac': 'mk', 'mah': 'mh',\n  'mal': 'ml', 'mao': 'mi', 'mar': 'mr', 'may': 'ms', 'mkd': 'mk', 'mlg': 'mg',\n  'mlt': 'mt', 'mon': 'mn', 'mri': 'mi', 'msa': 'ms', 'mya': 'my', 'nau': 'na',\n  'nav': 'nv', 'nbl': 'nr', 'nde': 'nd', 'ndo': 'ng', 'nep': 'ne', 'nld': 'nl',\n  'nno': 'nn', 'nob': 'nb', 'nor': 'no', 'nya': 'ny', 'oci': 'oc', 'oji': 'oj',\n  'ori': 'or', 'orm': 'om', 'oss': 'os', 'pan': 'pa', 'per': 'fa', 'pli': 'pi',\n  'pol': 'pl', 'por': 'pt', 'pus': 'ps', 'que': 'qu', 'roh': 'rm', 'ron': 'ro',\n  'rum': 'ro', 'run': 'rn', 'rus': 'ru', 'sag': 'sg', 'san': 'sa', 'sin': 'si',\n  'slk': 'sk', 'slo': 'sk', 'slv': 'sl', 'sme': 'se', 'smo': 'sm', 'sna': 'sn',\n  'snd': 'sd', 'som': 'so', 'sot': 'st', 'spa': 'es', 'sqi': 'sq', 'srd': 'sc',\n  'srp': 'sr', 'ssw': 'ss', 'sun': 'su', 'swa': 'sw', 'swe': 'sv', 'tah': 'ty',\n  'tam': 'ta', 'tat': 'tt', 'tel': 'te', 'tgk': 'tg', 'tgl': 'tl', 'tha': 'th',\n  'tib': 'bo', 'tir': 'ti', 'ton': 'to', 'tsn': 'tn', 'tso': 'ts', 'tuk': 'tk',\n  'tur': 'tr', 'twi': 'tw', 'uig': 'ug', 'ukr': 'uk', 'urd': 'ur', 'uzb': 'uz',\n  'ven': 've', 'vie': 'vi', 'vol': 'vo', 'wel': 'cy', 'wln': 'wa', 'wol': 'wo',\n  'xho': 'xh', 'yid': 'yi', 'yor': 'yo', 'zha': 'za', 'zho': 'zh', 'zul': 'zu'\n};\n\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/util/map_utils.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.MapUtils');\n\n\n/**\n * @namespace shaka.util.MapUtils\n * @summary A set of map/object utility functions.\n */\n\n\n/**\n * Returns true if the map is empty; otherwise, returns false.\n *\n * @param {Object.<KEY, VALUE>} object\n * @return {boolean}\n * @template KEY,VALUE\n */\nshaka.util.MapUtils.empty = function(object) {\n  return !object || Object.keys(object).length == 0;\n};\n\n\n/**\n * Gets the map's values.\n *\n * @param {!Object.<KEY, VALUE>} object\n * @return {!Array.<VALUE>}\n * @template KEY,VALUE\n */\nshaka.util.MapUtils.values = function(object) {\n  return Object.keys(object).map(function(key) { return object[key]; });\n};\n\n\n/**\n * Converts the values in the given Map to a different value.\n *\n * @param {!Object.<KEY, VALUE>} object\n * @param {function(VALUE, KEY=):OUTPUT} callback\n * @return {!Object.<KEY, OUTPUT>}\n * @template KEY,VALUE,OUTPUT\n */\nshaka.util.MapUtils.map = function(object, callback) {\n  return Object.keys(object).reduce(function(ret, key) {\n    var value = object[key];\n    ret[key] = callback(value, key);\n    return ret;\n  }, {});\n};\n\n\n/**\n * Creates a new object where the values are filtered out according to a\n * predicate.\n *\n * @param {!Object.<KEY, VALUE>} object\n * @param {function(KEY, VALUE):boolean} callback\n * @return {!Object.<KEY, VALUE>}\n * @template KEY,VALUE\n */\nshaka.util.MapUtils.filter = function(object, callback) {\n  return Object.keys(object).reduce(function(ret, key) {\n    if (callback(key, object[key]))\n      ret[key] = object[key];\n    return ret;\n  }, {});\n};\n\n\n/**\n * Returns true if every entry matches the predicate.\n *\n * @param {!Object.<KEY, VALUE>} object\n * @param {function(KEY, VALUE):boolean} callback\n * @return {boolean}\n * @template KEY,VALUE\n */\nshaka.util.MapUtils.every = function(object, callback) {\n  return Object.keys(object).every(function(key) {\n    return callback(key, object[key]);\n  });\n};\n\n\n/**\n * Returns true if any entry matches the predicate.\n *\n * @param {!Object.<KEY, VALUE>} object\n * @param {function(KEY, VALUE):boolean} callback\n * @return {boolean}\n * @template KEY,VALUE\n */\nshaka.util.MapUtils.some = function(object, callback) {\n  return Object.keys(object).some(function(key) {\n    return callback(key, object[key]);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/util/mp4_parser.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.Mp4Parser');\n\ngoog.require('shaka.util.DataViewReader');\n\n\n/**\n * Looks for a box of a specified type in an mp4 stream and returns\n * it's size if found one. Returns -1 otherwise. Advances the\n * position of the reader to the beginning of the box content.\n * @param {number} boxType\n * @param {!shaka.util.DataViewReader} reader\n * @return {number}\n */\nshaka.util.Mp4Parser.findBox = function(boxType, reader) {\n  while (reader.hasMoreData()) {\n    var start = reader.getPosition();\n    var size = reader.readUint32();\n    var type = reader.readUint32();\n    if (size == 1) {\n      size = reader.readUint64();\n    } else if (size == 0) {\n      size = reader.getLength() - start;\n    }\n\n    if (type == boxType) {\n      return size;\n    } else {\n      reader.skip(size - (reader.getPosition() - start));\n      continue;\n    }\n  }\n  // couldn't find the box\n  return shaka.util.Mp4Parser.BOX_NOT_FOUND;\n};\n\n\n/**\n * Finds a specified child of the sample description box\n * traversing a given path and returns it's size. Returns -1\n * if the box was not found.\n * @param {ArrayBuffer} data\n * @param {number} boxType\n * @return {number}\n */\nshaka.util.Mp4Parser.findSampleDescriptionBox = function(data, boxType) {\n  var reader = new shaka.util.DataViewReader(\n      new DataView(data),\n      shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n\n  /* Path to a sample description box:\n    moov->trak->mdia->minf->stpl->stsd->\n  */\n\n  var Mp4Parser = shaka.util.Mp4Parser;\n  var path = [\n    //[box type, number of bytes to skip before getting to inner boxes\n    // (for flags etc.)]\n    [Mp4Parser.BOX_TYPE_MOOV, 0],\n    [Mp4Parser.BOX_TYPE_TRAK, 0],\n    [Mp4Parser.BOX_TYPE_MDIA, 0],\n    [Mp4Parser.BOX_TYPE_MINF, 0],\n    [Mp4Parser.BOX_TYPE_STBL, 0],\n    [Mp4Parser.BOX_TYPE_STSD, 8],\n    [boxType, 0]\n  ];\n\n  var size = Mp4Parser.BOX_NOT_FOUND;\n  for (var i = 0; i < path.length; i++) {\n    var type = path[i][0];\n    var skipBytes = path[i][1];\n    size = Mp4Parser.findBox(type, reader);\n    if (size == Mp4Parser.BOX_NOT_FOUND)\n      return Mp4Parser.BOX_NOT_FOUND;\n    reader.skip(skipBytes);\n  }\n\n  return size;\n};\n\n\n/** @const {number} */\nshaka.util.Mp4Parser.BOX_NOT_FOUND = -1;\n\n\n/** @const {number} */\nshaka.util.Mp4Parser.BOX_TYPE_MDAT = 0x6D646174;\n\n\n/** @const {number} */\nshaka.util.Mp4Parser.BOX_TYPE_MOOV = 0x6D6F6F76;\n\n\n/** @const {number} */\nshaka.util.Mp4Parser.BOX_TYPE_TRAK = 0x7472616B;\n\n\n/** @const {number} */\nshaka.util.Mp4Parser.BOX_TYPE_MDIA = 0x6D646961;\n\n\n/** @const {number} */\nshaka.util.Mp4Parser.BOX_TYPE_MINF = 0x6D696E66;\n\n\n/** @const {number} */\nshaka.util.Mp4Parser.BOX_TYPE_STBL = 0x7374626C;\n\n\n/** @const {number} */\nshaka.util.Mp4Parser.BOX_TYPE_STSD = 0x73747364;\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/util/multi_map.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.MultiMap');\n\n\n\n/**\n * A simple multimap template.\n * @constructor\n * @struct\n * @template T\n */\nshaka.util.MultiMap = function() {\n  /** @private {!Object.<string, !Array.<T>>} */\n  this.map_ = {};\n};\n\n\n/**\n * Add a key, value pair to the map.\n * @param {string} key\n * @param {T} value\n */\nshaka.util.MultiMap.prototype.push = function(key, value) {\n  if (this.map_.hasOwnProperty(key)) {\n    this.map_[key].push(value);\n  } else {\n    this.map_[key] = [value];\n  }\n};\n\n\n/**\n * Set an array of values for the key, overwriting any previous data.\n * @param {string} key\n * @param {!Array.<T>} values\n */\nshaka.util.MultiMap.prototype.set = function(key, values) {\n  this.map_[key] = values;\n};\n\n\n/**\n * Check for a key.\n * @param {string} key\n * @return {boolean} true if the key exists.\n */\nshaka.util.MultiMap.prototype.has = function(key) {\n  return this.map_.hasOwnProperty(key);\n};\n\n\n/**\n * Get a list of values by key.\n * @param {string} key\n * @return {Array.<T>} or null if no such key exists.\n */\nshaka.util.MultiMap.prototype.get = function(key) {\n  var list = this.map_[key];\n  // slice() clones the list so that it and the map can each be modified\n  // without affecting the other.\n  return list ? list.slice() : null;\n};\n\n\n/**\n * Get a list of all values.\n * @return {!Array.<T>}\n */\nshaka.util.MultiMap.prototype.getAll = function() {\n  var list = [];\n  for (var key in this.map_) {\n    list.push.apply(list, this.map_[key]);\n  }\n  return list;\n};\n\n\n/**\n * Remove a specific value, if it exists.\n * @param {string} key\n * @param {T} value\n */\nshaka.util.MultiMap.prototype.remove = function(key, value) {\n  var list = this.map_[key];\n  if (!list) return;\n  for (var i = 0; i < list.length; ++i) {\n    if (list[i] == value) {\n      list.splice(i, 1);\n      --i;\n    }\n  }\n};\n\n\n/**\n * Get all keys from the multimap.\n * @return {!Array.<string>}\n */\nshaka.util.MultiMap.prototype.keys = function() {\n  var result = [];\n  for (var key in this.map_) {\n    result.push(key);\n  }\n  return result;\n};\n\n\n/**\n * Clear all keys and values from the multimap.\n */\nshaka.util.MultiMap.prototype.clear = function() {\n  this.map_ = {};\n};\n\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/util/pssh.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.Pssh');\n\ngoog.require('shaka.log');\ngoog.require('shaka.util.DataViewReader');\ngoog.require('shaka.util.Mp4Parser');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n\n/**\n * Parse a PSSH box and extract the system IDs.\n *\n * @param {!Uint8Array} psshBox\n * @constructor\n * @struct\n * @throws {shaka.util.Error} if a PSSH box is truncated or contains a size\n *   field over 53 bits.\n */\nshaka.util.Pssh = function(psshBox) {\n  /**\n   * In hex.\n   * @type {!Array.<string>}\n   */\n  this.systemIds = [];\n\n  /**\n   * In hex.\n   * @type {!Array.<string>}\n   */\n  this.cencKeyIds = [];\n\n  /*\n  * Array of tuples that define the startIndex + size for each\n  * discrete pssh within |psshBox|\n  * */\n  this.dataBoundaries = [];\n\n  // Parse the PSSH box.\n  var reader = new shaka.util.DataViewReader(\n      new DataView(psshBox.buffer),\n      shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n\n  var psshBoxFound = false;\n\n  // There could be multiple boxes concatenated together.\n  while (reader.hasMoreData()) {\n    var size = shaka.util.Mp4Parser.findBox(shaka.util.Pssh.BOX_TYPE, reader);\n    if (size == shaka.util.Mp4Parser.BOX_NOT_FOUND)\n      break;\n\n    // a file can have several pssh boxes, mark that at least\n    // one was found\n    psshBoxFound = true;\n    var startPosition = reader.getPosition() - 8;\n    var version = reader.readUint8();\n    if (version > 1) {\n      shaka.log.warning('Unrecognized PSSH version found!');\n      reader.skip(size - (reader.getPosition() - startPosition));\n      continue;\n    }\n\n    reader.skip(3);  // Skip flags.\n\n    var systemId = shaka.util.Uint8ArrayUtils.toHex(reader.readBytes(16));\n    var keyIds = [];\n    if (version > 0) {\n      var numKeyIds = reader.readUint32();\n      for (var i = 0; i < numKeyIds; ++i) {\n        var keyId = shaka.util.Uint8ArrayUtils.toHex(reader.readBytes(16));\n        keyIds.push(keyId);\n      }\n    }\n\n    var dataSize = reader.readUint32();\n    reader.skip(dataSize);  // Ignore the data section.\n\n    // Now that everything has been succesfully parsed from this box,\n    // update member variables.\n    this.cencKeyIds.push.apply(this.cencKeyIds, keyIds);\n    this.systemIds.push(systemId);\n    this.dataBoundaries.push({\n      start: startPosition,\n      end: reader.getPosition() - 1 }\n    );\n\n    if (reader.getPosition() != startPosition + size) {\n      shaka.log.warning('Mismatch between box size and data size!');\n      reader.skip(size - (reader.getPosition() - startPosition));\n    }\n  }\n\n  if (!psshBoxFound)\n    shaka.log.warning('No pssh box found!');\n};\n\n\n/** @const {number} */\nshaka.util.Pssh.BOX_TYPE = 0x70737368;\n\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/util/public_promise.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.PublicPromise');\n\n\n\n/**\n * A utility to create Promises with convenient public resolve and reject\n * methods.\n *\n * @constructor\n * @struct\n * @extends {Promise.<T>}\n * @return {Promise.<T>}\n * @template T\n */\nshaka.util.PublicPromise = function() {\n  var resolvePromise;\n  var rejectPromise;\n\n  // Promise.call causes an error.  It seems that inheriting from a native\n  // Promise is not permitted by JavaScript interpreters.\n\n  // The work-around is to construct a Promise object, modify it to look like\n  // the compiler's picture of PublicPromise, then return it.  The caller of\n  // new PublicPromise will receive |promise| instead of |this|, and the\n  // compiler will be aware of the additional properties |resolve| and\n  // |reject|.\n\n  var promise = new Promise(function(resolve, reject) {\n    resolvePromise = resolve;\n    rejectPromise = reject;\n  });\n\n  promise.resolve = resolvePromise;\n  promise.reject = rejectPromise;\n\n  return promise;\n};\n\n\n/** @type {function(T=)} */\nshaka.util.PublicPromise.prototype.resolve;\n\n\n/** @type {function(*=)} */\nshaka.util.PublicPromise.prototype.reject;\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/util/stream_utils.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.StreamUtils');\n\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.media.MediaSourceEngine');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.LanguageUtils');\n\n\n/**\n * @param {shakaExtern.Period} period\n * @param {shakaExtern.Restrictions} restrictions\n *   Configured restrictions from the user.\n * @param {{width: number, height: number}} maxHwRes\n *   The maximum resolution the hardware can handle.\n *   This is applied separately from user restrictions because the setting\n *   should not be easily replaced by the user's configuration.\n * @return {boolean} Whether the tracks changed.\n */\nshaka.util.StreamUtils.applyRestrictions =\n    function(period, restrictions, maxHwRes) {\n  var tracksChanged = false;\n\n  period.streamSets.forEach(function(streamSet) {\n    streamSet.streams.forEach(function(stream) {\n      var originalAllowed = stream.allowedByApplication;\n      stream.allowedByApplication = true;\n\n      if (streamSet.type == 'video') {\n        if (stream.width < restrictions.minWidth ||\n            stream.width > restrictions.maxWidth ||\n            stream.width > maxHwRes.width ||\n            stream.height < restrictions.minHeight ||\n            stream.height > restrictions.maxHeight ||\n            stream.height > maxHwRes.height ||\n            (stream.width * stream.height) < restrictions.minPixels ||\n            (stream.width * stream.height) > restrictions.maxPixels ||\n            stream.bandwidth < restrictions.minVideoBandwidth ||\n            stream.bandwidth > restrictions.maxVideoBandwidth) {\n          stream.allowedByApplication = false;\n        }\n      } else if (streamSet.type == 'audio') {\n        if (stream.bandwidth < restrictions.minAudioBandwidth ||\n            stream.bandwidth > restrictions.maxAudioBandwidth) {\n          stream.allowedByApplication = false;\n        }\n      }\n\n      if (originalAllowed != stream.allowedByApplication)\n        tracksChanged = true;\n    });\n  });\n\n  return tracksChanged;\n};\n\n\n/**\n * Alters the given Period to filter out any unplayable streams.\n *\n * @param {shaka.media.DrmEngine} drmEngine\n * @param {!Object.<string, shakaExtern.Stream>} activeStreams\n * @param {shakaExtern.Period} period\n */\nshaka.util.StreamUtils.filterPeriod = function(\n    drmEngine, activeStreams, period) {\n  var keySystem = '';\n  var drmSupportedMimeTypes = null;\n  if (drmEngine && drmEngine.initialized()) {\n    keySystem = drmEngine.keySystem();\n    drmSupportedMimeTypes = drmEngine.getSupportedTypes();\n  }\n\n  for (var i = 0; i < period.streamSets.length; ++i) {\n    var streamSet = period.streamSets[i];\n\n    if (keySystem) {\n      // A key system has been selected.\n      // Remove streamSets which can only be used with other key systems.\n      // Note that drmInfos == [] means unencrypted.\n      var match = streamSet.drmInfos.length == 0 ||\n                  streamSet.drmInfos.some(function(drmInfo) {\n                    return drmInfo.keySystem == keySystem; });\n\n      if (!match) {\n        shaka.log.debug('Dropping StreamSet, can\\'t be used with ' + keySystem,\n                        streamSet);\n        period.streamSets.splice(i, 1);\n        --i;\n        continue;\n      }\n    }\n\n    var activeStream = activeStreams[streamSet.type];\n\n    for (var j = 0; j < streamSet.streams.length; ++j) {\n      var stream = streamSet.streams[j];\n      var fullMimeType = shaka.util.StreamUtils.getFullMimeType(\n          stream.mimeType, stream.codecs);\n\n      if (!shaka.media.MediaSourceEngine.isTypeSupported(fullMimeType)) {\n        // Remove streams that cannot be played by the platform.\n        streamSet.streams.splice(j, 1);\n        --j;\n        continue;\n      }\n\n      if (drmSupportedMimeTypes && stream.encrypted &&\n          drmSupportedMimeTypes.indexOf(fullMimeType) < 0) {\n        // Remove encrypted streams that cannot be handled by the key system.\n        streamSet.streams.splice(j, 1);\n        --j;\n        continue;\n      }\n\n      if (activeStream) {\n        // Check that the basic mime types and basic codecs match.\n        // For example, we can't adapt between WebM and MP4,\n        // nor can we adapt between mp4a.* to ec-3.\n        if (stream.mimeType != activeStream.mimeType ||\n            stream.codecs.split('.')[0] != activeStream.codecs.split('.')[0]) {\n          streamSet.streams.splice(j, 1);\n          --j;\n          continue;\n        }\n      }\n    }\n\n    if (streamSet.streams.length == 0) {\n      period.streamSets.splice(i, 1);\n      --i;\n    }\n  }\n};\n\n\n/**\n * Gets an array of Track objects for the given Period\n *\n * @param {shakaExtern.Period} period\n * @param {Object.<string, shakaExtern.Stream>} activeStreams\n * @return {!Array.<shakaExtern.Track>}\n */\nshaka.util.StreamUtils.getTracks = function(period, activeStreams) {\n  // Convert each stream into a track and squash them into one array.\n  var Functional = shaka.util.Functional;\n  return period.streamSets\n      .map(function(streamSet) {\n        var activeStream = activeStreams ? activeStreams[streamSet.type] : null;\n        return streamSet.streams\n            .filter(function(stream) {\n              return stream.allowedByApplication && stream.allowedByKeySystem;\n            })\n            .map(function(stream) {\n              return {\n                id: stream.id,\n                active: activeStream == stream,\n                type: streamSet.type,\n                bandwidth: stream.bandwidth,\n                language: streamSet.language,\n                kind: stream.kind || null,\n                width: stream.width || null,\n                height: stream.height || null,\n                frameRate: stream.frameRate || undefined,\n                codecs: stream.codecs || null\n              };\n            });\n      })\n      .reduce(Functional.collapseArrays, []);\n};\n\n\n/**\n * Find the stream and stream set for the given track.\n *\n * @param {shakaExtern.Period} period\n * @param {shakaExtern.Track} track\n * @return {?{stream: shakaExtern.Stream, streamSet: shakaExtern.StreamSet}}\n */\nshaka.util.StreamUtils.findStreamForTrack = function(period, track) {\n  for (var i = 0; i < period.streamSets.length; i++) {\n    var streamSet = period.streamSets[i];\n    for (var j = 0; j < streamSet.streams.length; j++) {\n      var stream = streamSet.streams[j];\n      if (stream.id == track.id)\n        return {stream: stream, streamSet: streamSet};\n    }\n  }\n  return null;\n};\n\n\n/**\n * Determines if the given stream set has any playable streams.\n * @param {shakaExtern.StreamSet} streamSet\n * @return {boolean}\n */\nshaka.util.StreamUtils.hasPlayableStreams = function(streamSet) {\n  return streamSet.streams.some(function(stream) {\n    return stream.allowedByApplication && stream.allowedByKeySystem;\n  });\n};\n\n\n/**\n * Chooses a stream set of each type according to the given config.\n *\n * @param {shakaExtern.Period} period\n * @param {shakaExtern.PlayerConfiguration} config\n * @param {!Object=} opt_languageMatches\n * @return {!Object.<string, shakaExtern.StreamSet>}\n */\nshaka.util.StreamUtils.chooseStreamSets = function(\n    period, config, opt_languageMatches) {\n  var LanguageUtils = shaka.util.LanguageUtils;\n  var hasPlayableStreams = shaka.util.StreamUtils.hasPlayableStreams;\n  var StreamUtils = shaka.util.StreamUtils;\n\n  // Choose the first stream set listed as the default.\n  /** @type {!Object.<string, shakaExtern.StreamSet>} */\n  var streamSetsByType = {};\n  period.streamSets.forEach(function(set) {\n    if (!hasPlayableStreams(set) || set.type in streamSetsByType) return;\n    streamSetsByType[set.type] = set;\n  });\n\n  // Pick video set with highest top resolution, break ties\n  // by selecting one with lower average bandwidth\n  var highestResolution = 0;\n  period.streamSets.forEach(function(set) {\n    if (hasPlayableStreams(set) && set.type == 'video') {\n      var resolution = StreamUtils.getHighestResolution(set);\n      if (resolution > highestResolution) {\n        highestResolution = resolution;\n        streamSetsByType['video'] = set;\n      } else if (resolution == highestResolution) {\n        if (StreamUtils.getAvgBandwidth(set) <\n            StreamUtils.getAvgBandwidth(streamSetsByType['video'])) {\n          streamSetsByType['video'] = set;\n        }\n      }\n    }\n  });\n\n\n  // Then if there are primary stream sets, override the default.\n  period.streamSets.forEach(function(set) {\n    if (hasPlayableStreams(set) && set.primary) {\n      // if both sets are primary, choose one with lower\n      // average bandwidth\n      if (streamSetsByType[set.type].primary) {\n        if (StreamUtils.getAvgBandwidth(set) <\n            StreamUtils.getAvgBandwidth(streamSetsByType[set.type])) {\n          streamSetsByType[set.type] = set;\n        }\n      } else {\n        streamSetsByType[set.type] = set;\n      }\n    }\n  });\n\n  // Finally, choose based on language preference.  Favor exact matches, then\n  // base matches, finally different subtags.  Execute in reverse order so\n  // the later steps override the previous ones.\n  [LanguageUtils.MatchType.OTHER_SUB_LANGUAGE_OKAY,\n   LanguageUtils.MatchType.BASE_LANGUAGE_OKAY,\n   LanguageUtils.MatchType.EXACT]\n      .forEach(function(matchType) {\n        period.streamSets.forEach(function(set) {\n          if (!hasPlayableStreams(set))\n            return;\n\n          /** @type {string} */\n          var pref;\n          if (set.type == 'audio')\n            pref = config.preferredAudioLanguage;\n          else if (set.type == 'text')\n            pref = config.preferredTextLanguage;\n\n          if (pref) {\n            pref = LanguageUtils.normalize(pref);\n            var lang = LanguageUtils.normalize(set.language);\n            if (LanguageUtils.match(matchType, pref, lang)) {\n              // If this audio stream has the same language as a previous\n              // match, only choose it if it uses less bandwidth.\n              if (set.language == streamSetsByType[set.type].language) {\n                if (StreamUtils.getAvgBandwidth(set) <\n                    StreamUtils.getAvgBandwidth(streamSetsByType[set.type])) {\n                  streamSetsByType[set.type] = set;\n                }\n              } else {\n                streamSetsByType[set.type] = set;\n              }\n              if (opt_languageMatches)\n                opt_languageMatches[set.type] = true;\n            }\n          }\n        });\n      });\n\n  return streamSetsByType;\n};\n\n\n/**\n * Computes average bandwidth across all streams of a stream set.\n * Assumes a stream set of audio/video type, where all streams have\n * bandwidth.\n *\n * @param {shakaExtern.StreamSet} streamSet\n * @return {number}\n */\nshaka.util.StreamUtils.getAvgBandwidth = function(streamSet) {\n  var bandwidthSum = 0;\n\n  // to make sure we don't end up trying to divide by 0\n  if (!streamSet || streamSet.streams.length < 1) return bandwidthSum;\n\n  streamSet.streams.forEach(function(stream) {\n    bandwidthSum += stream.bandwidth;\n  });\n\n  return bandwidthSum / streamSet.streams.length;\n};\n\n\n/**\n * Loops through all the streams in a StreamSet and returns the value\n * of the highest resolution found across all streams.\n * Assumes a valid video StreamSet.\n *\n * @param {shakaExtern.StreamSet} streamSet\n * @return {number}\n */\nshaka.util.StreamUtils.getHighestResolution = function(streamSet) {\n  var highestRes = 0;\n  if (!streamSet) return highestRes;\n\n  streamSet.streams.forEach(function(stream) {\n    if (stream.height > highestRes)\n      highestRes = stream.height;\n  });\n\n  return highestRes;\n};\n\n\n/**\n * Takes a MIME type and optional codecs string and produces the full MIME type.\n *\n * @param {string} mimeType\n * @param {string=} opt_codecs\n * @return {string}\n */\nshaka.util.StreamUtils.getFullMimeType = function(mimeType, opt_codecs) {\n  var fullMimeType = mimeType;\n  if (opt_codecs) {\n    fullMimeType += '; codecs=\"' + opt_codecs + '\"';\n  }\n  return fullMimeType;\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/util/string_utils.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.StringUtils');\n\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\n\n\n/**\n * @namespace shaka.util.StringUtils\n * @summary A set of string utility functions.\n */\n\n\n/**\n * Creates a string from the given buffer as UTF-8 encoding.\n *\n * @param {?BufferSource} data\n * @return {string}\n * @throws {shaka.util.Error}\n */\nshaka.util.StringUtils.fromUTF8 = function(data) {\n  if (!data) return '';\n\n  var uint8 = new Uint8Array(data);\n  // If present, strip off the UTF-8 BOM.\n  if (uint8[0] == 0xef && uint8[1] == 0xbb && uint8[2] == 0xbf) {\n    uint8 = uint8.subarray(3);\n  }\n\n  // http://stackoverflow.com/a/13691499\n  var utf8 = shaka.util.StringUtils.fromCharCode_(uint8);\n  // This converts each character in the string to an escape sequence.  If the\n  // character is in the ASCII range, it is not converted; otherwise it is\n  // converted to a URI escape sequence.\n  // Example: '\\x67\\x35\\xe3\\x82\\xac' -> 'g#%E3%82%AC'\n  var escaped = escape(utf8);\n  // Decode the escaped sequence.  This will interpret UTF-8 sequences into the\n  // correct character.\n  // Example: 'g#%E3%82%AC' -> 'g#€'\n  try {\n    return decodeURIComponent(escaped);\n  } catch (e) {\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.TEXT, shaka.util.Error.Code.BAD_ENCODING);\n  }\n};\n\n\n/**\n * Creates a string from the given buffer as UTF-16 encoding.\n *\n * @param {?BufferSource} data\n * @param {boolean} littleEndian true to read little endian, false to read big.\n * @return {string}\n * @throws {shaka.util.Error}\n */\nshaka.util.StringUtils.fromUTF16 = function(data, littleEndian) {\n  if (!data) return '';\n\n  if (data.byteLength % 2 != 0) {\n    shaka.log.error('Data has an incorrect length, must be even.');\n    throw new shaka.util.Error(\n        shaka.util.Error.Category.TEXT, shaka.util.Error.Code.BAD_ENCODING);\n  }\n\n  /** @type {ArrayBuffer} */\n  var buffer;\n  if (data instanceof ArrayBuffer) {\n    buffer = data;\n  } else {\n    // Have to create a new buffer because the argument may be a smaller\n    // view on a larger ArrayBuffer.  We cannot use an ArrayBufferView in\n    // a DataView.\n    var temp = new Uint8Array(data.byteLength);\n    temp.set(new Uint8Array(data));\n    buffer = temp.buffer;\n  }\n\n  // Use a DataView to ensure correct endianness.\n  var length = data.byteLength / 2;\n  var arr = new Uint16Array(length);\n  var dataView = new DataView(buffer);\n  for (var i = 0; i < length; i++) {\n    arr[i] = dataView.getUint16(i * 2, littleEndian);\n  }\n  return shaka.util.StringUtils.fromCharCode_(arr);\n};\n\n\n/**\n * Creates a string from the given buffer, auto-detecting the encoding that is\n * being used.  If it cannot detect the encoding, it will throw an exception.\n *\n * @param {?BufferSource} data\n * @return {string}\n * @throws {shaka.util.Error}\n */\nshaka.util.StringUtils.fromBytesAutoDetect = function(data) {\n  var StringUtils = shaka.util.StringUtils;\n\n  var uint8 = new Uint8Array(data);\n  if (uint8[0] == 0xef && uint8[1] == 0xbb && uint8[2] == 0xbf)\n    return StringUtils.fromUTF8(uint8);\n  else if (uint8[0] == 0xfe && uint8[1] == 0xff)\n    return StringUtils.fromUTF16(uint8.subarray(2), false /* littleEndian */);\n  else if (uint8[0] == 0xff && uint8[1] == 0xfe)\n    return StringUtils.fromUTF16(uint8.subarray(2), true /* littleEndian */);\n\n  var isAscii = (function(arr, i) {\n    // arr[i] >= ' ' && arr[i] <= '~';\n    return arr.byteLength <= i || (arr[i] >= 0x20 && arr[i] <= 0x7e);\n  }.bind(null, uint8));\n\n  shaka.log.debug('Unable to find byte-order-mark, making an educated guess.');\n  if (uint8[0] == 0 && uint8[2] == 0)\n    return StringUtils.fromUTF16(data, false /* littleEndian */);\n  else if (uint8[1] == 0 && uint8[3] == 0)\n    return StringUtils.fromUTF16(data, true /* littleEndian */);\n  else if (isAscii(0) && isAscii(1) && isAscii(2) && isAscii(3))\n    return StringUtils.fromUTF8(data);\n\n  throw new shaka.util.Error(\n      shaka.util.Error.Category.TEXT,\n      shaka.util.Error.Code.UNABLE_TO_DETECT_ENCODING);\n};\n\n\n/**\n * Creates a ArrayBuffer from the given string, converting to UTF-8 encoding.\n *\n * @param {string} str\n * @return {!ArrayBuffer}\n */\nshaka.util.StringUtils.toUTF8 = function(str) {\n  // http://stackoverflow.com/a/13691499\n  // Converts the given string to a URI encoded string.  If a character falls\n  // in the ASCII range, it is not converted; otherwise it will be converted to\n  // a series of URI escape sequences according to UTF-8.\n  // Example: 'g#€' -> 'g#%E3%82%AC'\n  var encoded = encodeURIComponent(str);\n  // Convert each escape sequence individually into a character.  Each escape\n  // sequence is interpreted as a code-point, so if an escape sequence happens\n  // to be part of a multi-byte sequence, each byte will be converted to a\n  // single character.\n  // Example: 'g#%E3%82%AC' -> '\\x67\\x35\\xe3\\x82\\xac'\n  var utf8 = unescape(encoded);\n\n  var result = new Uint8Array(utf8.length);\n  for (var i = 0; i < utf8.length; ++i) {\n    result[i] = utf8.charCodeAt(i);\n  }\n  return result.buffer;\n};\n\n\n/**\n * Creates a new string from the given array of char codes.\n *\n * @param {!TypedArray} args\n * @return {string}\n * @private\n */\nshaka.util.StringUtils.fromCharCode_ = function(args) {\n  var max = 16000;\n  var ret = '';\n  for (var i = 0; i < args.length; i += max) {\n    var subArray = args.subarray(i, i + max);\n    ret += String.fromCharCode.apply(null, subArray);\n  }\n\n  return ret;\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/util/text_parser.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.TextParser');\n\ngoog.require('goog.asserts');\n\n\n\n/**\n * Reads elements from strings.\n *\n * @param {string} data\n * @constructor\n * @struct\n */\nshaka.util.TextParser = function(data) {\n  /**\n   * @const\n   * @private {string}\n   */\n  this.data_ = data;\n\n  /** @private {number} */\n  this.position_ = 0;\n};\n\n\n/** @return {boolean} Whether it is at the end of the string. */\nshaka.util.TextParser.prototype.atEnd = function() {\n  return this.position_ == this.data_.length;\n};\n\n\n/**\n * Reads a line from the parser.  This will read but not return the newline.\n * Returns null at the end.\n *\n * @return {?string}\n */\nshaka.util.TextParser.prototype.readLine = function() {\n  return this.readRegexReturnCapture_(/(.*?)(\\n|$)/gm, 1);\n};\n\n\n/**\n * Reads a word from the parser.  This will not read or return any whitespace\n * before or after the word (including newlines).  Returns null at the end.\n *\n * @return {?string}\n */\nshaka.util.TextParser.prototype.readWord = function() {\n  return this.readRegexReturnCapture_(/[^ \\t\\n]*/gm, 0);\n};\n\n\n/**\n * Skips any continuous whitespace from the parser.  Returns null at the end.\n */\nshaka.util.TextParser.prototype.skipWhitespace = function() {\n  this.readRegex(/[ \\t]+/gm);\n};\n\n\n/**\n * Reads the given regular expression from the parser.  This requires the match\n * to be at the current position; there is no need to include a head anchor.\n * This requires that the regex have the global flag to be set so that it can\n * set lastIndex to start the search at the current position.  Returns null at\n * the end or if the regex does not match the current position.\n *\n * @param {!RegExp} regex\n * @return {Array.<string>}\n */\nshaka.util.TextParser.prototype.readRegex = function(regex) {\n  var index = this.indexOf_(regex);\n  if (this.atEnd() || index == null || index.position != this.position_)\n    return null;\n\n  this.position_ += index.length;\n  return index.results;\n};\n\n\n/**\n * Reads a regex from the parser and returns the given capture.\n *\n * @param {!RegExp} regex\n * @param {number} index\n * @return {?string}\n * @private\n */\nshaka.util.TextParser.prototype.readRegexReturnCapture_ =\n    function(regex, index) {\n  if (this.atEnd())\n    return null;\n\n  var ret = this.readRegex(regex);\n  if (!ret)\n    return null;\n  else\n    return ret[index];\n};\n\n\n/**\n * Returns the index info about a regular expression match.\n *\n * @param {!RegExp} regex\n * @return {?{position: number, length: number, results: !Array.<string>}}\n * @private\n */\nshaka.util.TextParser.prototype.indexOf_ = function(regex) {\n  // The global flag is required to use lastIndex.\n  goog.asserts.assert(regex.global, 'global flag should be set');\n\n  regex.lastIndex = this.position_;\n  var results = regex.exec(this.data_);\n  if (results == null)\n    return null;\n  else\n    return {\n      position: results.index,\n      length: results[0].length,\n      results: results\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/util/timer.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.Timer');\n\n\n\n/**\n * A simple cancelable timer.\n * @param {Function} callback\n * @constructor\n * @struct\n */\nshaka.util.Timer = function(callback) {\n  /** @private {?number} */\n  this.id_ = null;\n\n  /** @private {number} */\n  this.timeoutSeconds_ = 0;\n\n  /** @private {Function} */\n  this.callback_ = (function() {\n    this.id_ = null;\n    callback();\n  }.bind(this));\n};\n\n\n/**\n * Cancel the timer, if it's running.\n */\nshaka.util.Timer.prototype.cancel = function() {\n  if (this.id_ != null) {\n    clearTimeout(this.id_);\n    this.id_ = null;\n  }\n};\n\n\n/**\n * Schedule the timer, canceling any previous scheduling.\n * @param {number} seconds\n */\nshaka.util.Timer.prototype.schedule = function(seconds) {\n  this.cancel();\n  this.timeoutSeconds_ = seconds;\n  this.id_ = setTimeout(this.callback_, seconds * 1000);\n};\n\n\n/**\n * If the timer is running, reschedule it using the previous scheduled timeout.\n * @example\n *   If scheduled for 5 seconds, and rescheduled 3 seconds later,\n *   the timer will fire 8 seconds after the original scheduling.\n * @example\n *   If scheduled for 5 seconds, and rescheduled 6 seconds later,\n *   the timer will already have fired and will not be rescheduled.\n */\nshaka.util.Timer.prototype.rescheduleIfRunning = function() {\n  if (this.id_ != null) {\n    this.schedule(this.timeoutSeconds_);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/util/uint8array_utils.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * @namespace shaka.util.Uint8ArrayUtils\n * @summary A set of Uint8Array utility functions.\n */\n\n\n/**\n * Convert a Uint8Array to a base64 string.  The output will always use the\n * alternate encoding/alphabet also known as \"base64url\".\n * @param {!Uint8Array} arr\n * @param {boolean=} opt_padding If true, pad the output with equals signs.\n *   Defaults to true.\n * @return {string}\n */\nshaka.util.Uint8ArrayUtils.toBase64 = function(arr, opt_padding) {\n  // btoa expects a \"raw string\" where each character is interpreted as a byte.\n  var bytes = String.fromCharCode.apply(null, arr);\n  var padding = (opt_padding == undefined) ? true : opt_padding;\n  var base64 = window.btoa(bytes).replace(/\\+/g, '-').replace(/\\//g, '_');\n  return padding ? base64 : base64.replace(/=*$/, '');\n};\n\n\n/**\n * Convert a base64 string to a Uint8Array.  Accepts either the standard\n * alphabet or the alternate \"base64url\" alphabet.\n * @param {string} str\n * @return {!Uint8Array}\n */\nshaka.util.Uint8ArrayUtils.fromBase64 = function(str) {\n  // atob creates a \"raw string\" where each character is interpreted as a byte.\n  var bytes = window.atob(str.replace(/-/g, '+').replace(/_/g, '/'));\n  var result = new Uint8Array(bytes.length);\n  for (var i = 0; i < bytes.length; ++i) {\n    result[i] = bytes.charCodeAt(i);\n  }\n  return result;\n};\n\n\n/**\n * Convert a hex string to a Uint8Array.\n * @param {string} str\n * @return {!Uint8Array}\n */\nshaka.util.Uint8ArrayUtils.fromHex = function(str) {\n  var arr = new Uint8Array(str.length / 2);\n  for (var i = 0; i < str.length; i += 2) {\n    arr[i / 2] = window.parseInt(str.substr(i, 2), 16);\n  }\n  return arr;\n};\n\n\n/**\n * Convert a Uint8Array to a hex string.\n * @param {!Uint8Array} arr\n * @return {string}\n */\nshaka.util.Uint8ArrayUtils.toHex = function(arr) {\n  var hex = '';\n  for (var i = 0; i < arr.length; ++i) {\n    var value = arr[i].toString(16);\n    if (value.length == 1) value = '0' + value;\n    hex += value;\n  }\n  return hex;\n};\n\n\n/**\n * Compare two Uint8Arrays for equality.\n * @param {Uint8Array} arr1\n * @param {Uint8Array} arr2\n * @return {boolean}\n */\nshaka.util.Uint8ArrayUtils.equal = function(arr1, arr2) {\n  if (!arr1 && !arr2) return true;\n  if (!arr1 || !arr2) return false;\n  if (arr1.length != arr2.length) return false;\n  for (var i = 0; i < arr1.length; ++i) {\n    if (arr1[i] != arr2[i]) return false;\n  }\n  return true;\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/lib/util/xml_utils.js":"/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('shaka.util.XmlUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\n\n\n/**\n * @namespace shaka.util.XmlUtils\n * @summary A set of XML utility functions.\n */\n\n\n/**\n * Finds a child XML element.\n * @param {!Element} elem The parent XML element.\n * @param {string} name The child XML element's tag name.\n * @return {Element} The child XML element, or null if a child XML element does\n *   not exist with the given tag name OR if there exists more than one\n *   child XML element with the given tag name.\n */\nshaka.util.XmlUtils.findChild = function(elem, name) {\n  var children = shaka.util.XmlUtils.findChildren(elem, name);\n  if (children.length != 1)\n    return null;\n  return children[0];\n};\n\n\n/**\n * Finds child XML elements.\n * @param {!Element} elem The parent XML element.\n * @param {string} name The child XML element's tag name.\n * @return {!Array.<!Element>} The child XML elements.\n */\nshaka.util.XmlUtils.findChildren = function(elem, name) {\n  return Array.prototype.filter.call(elem.childNodes, function(child) {\n    goog.asserts.assert(\n        child.tagName != name || child instanceof Element,\n        'child element should be an Element');\n    return child.tagName == name;\n  });\n};\n\n\n/**\n * Gets the text contents of a node.\n * @param {!Element} elem The XML element.\n * @return {?string} The text contents, or null if there are none.\n */\nshaka.util.XmlUtils.getContents = function(elem) {\n  var contents = elem.firstChild;\n\n  // check content\n  if (!contents || contents.nodeType != Node.TEXT_NODE)\n    return null;\n\n  // read merged text content from all text nodes (fixes MSIE 11 bug)\n  return elem.textContent.trim();\n};\n\n\n/**\n * Parses an attribute by its name.\n * @param {!Element} elem The XML element.\n * @param {string} name The attribute name.\n * @param {function(string): (T|null)} parseFunction A function that parses\n *   the attribute.\n * @param {(T|null)=} opt_defaultValue The attribute's default value, if not\n *   specified, the attibute's default value is null.\n * @return {(T|null)} The parsed attribute on success, or the attribute's\n *   default value if the attribute does not exist or could not be parsed.\n * @template T\n */\nshaka.util.XmlUtils.parseAttr = function(\n    elem, name, parseFunction, opt_defaultValue) {\n  var parsedValue = null;\n\n  var value = elem.getAttribute(name);\n  if (value != null)\n    parsedValue = parseFunction(value);\n\n  if (parsedValue == null)\n    return opt_defaultValue !== undefined ? opt_defaultValue : null;\n\n  return parsedValue;\n};\n\n\n/**\n * Parses an XML date string.\n * @param {string} dateString\n * @return {?number} The parsed date in seconds on success; otherwise, return\n *   null.\n */\nshaka.util.XmlUtils.parseDate = function(dateString) {\n  if (!dateString)\n    return null;\n\n  var result = Date.parse(dateString);\n  return (!isNaN(result) ? Math.floor(result / 1000.0) : null);\n};\n\n\n/**\n * Parses an XML duration string.\n * Negative values are not supported. Years and months are treated as exactly\n * 365 and 30 days respectively.\n * @param {string} durationString The duration string, e.g., \"PT1H3M43.2S\",\n *   which means 1 hour, 3 minutes, and 43.2 seconds.\n * @return {?number} The parsed duration in seconds on success; otherwise,\n *   return null.\n * @see {@link http://www.datypic.com/sc/xsd/t-xsd_duration.html}\n */\nshaka.util.XmlUtils.parseDuration = function(durationString) {\n  if (!durationString)\n    return null;\n\n  var re = '^P(?:([0-9]*)Y)?(?:([0-9]*)M)?(?:([0-9]*)D)?' +\n           '(?:T(?:([0-9]*)H)?(?:([0-9]*)M)?(?:([0-9.]*)S)?)?$';\n  var matches = new RegExp(re).exec(durationString);\n\n  if (!matches) {\n    shaka.log.warning('Invalid duration string:', durationString);\n    return null;\n  }\n\n  // Note: Number(null) == 0 but Number(undefined) == NaN.\n  var years = Number(matches[1] || null);\n  var months = Number(matches[2] || null);\n  var days = Number(matches[3] || null);\n  var hours = Number(matches[4] || null);\n  var minutes = Number(matches[5] || null);\n  var seconds = Number(matches[6] || null);\n\n  // Assume a year always has 365 days and a month always has 30 days.\n  var d = (60 * 60 * 24 * 365) * years +\n          (60 * 60 * 24 * 30) * months +\n          (60 * 60 * 24) * days +\n          (60 * 60) * hours +\n          60 * minutes +\n          seconds;\n  return isFinite(d) ? d : null;\n};\n\n\n/**\n * Parses a range string.\n * @param {string} rangeString The range string, e.g., \"101-9213\".\n * @return {?{start: number, end: number}} The parsed range on success;\n *   otherwise, return null.\n */\nshaka.util.XmlUtils.parseRange = function(rangeString) {\n  var matches = /([0-9]+)-([0-9]+)/.exec(rangeString);\n\n  if (!matches)\n    return null;\n\n  var start = Number(matches[1]);\n  if (!isFinite(start))\n    return null;\n\n  var end = Number(matches[2]);\n  if (!isFinite(end))\n    return null;\n\n  return {start: start, end: end};\n};\n\n\n/**\n * Parses an integer.\n * @param {string} intString The integer string.\n * @return {?number} The parsed integer on success; otherwise, return null.\n */\nshaka.util.XmlUtils.parseInt = function(intString) {\n  var n = Number(intString);\n  return (n % 1 === 0) ? n : null;\n};\n\n\n/**\n * Parses a positive integer.\n * @param {string} intString The integer string.\n * @return {?number} The parsed positive integer on success; otherwise,\n *   return null.\n */\nshaka.util.XmlUtils.parsePositiveInt = function(intString) {\n  var n = Number(intString);\n  return (n % 1 === 0) && (n > 0) ? n : null;\n};\n\n\n/**\n * Parses a non-negative integer.\n * @param {string} intString The integer string.\n * @return {?number} The parsed non-negative integer on success; otherwise,\n *   return null.\n */\nshaka.util.XmlUtils.parseNonNegativeInt = function(intString) {\n  var n = Number(intString);\n  return (n % 1 === 0) && (n >= 0) ? n : null;\n};\n\n\n/**\n * Parses a floating point number.\n * @param {string} floatString The floating point number string.\n * @return {?number} The parsed floating point number on success; otherwise,\n *   return null. May return -Infinity or Infinity.\n */\nshaka.util.XmlUtils.parseFloat = function(floatString) {\n  var n = Number(floatString);\n  return !isNaN(n) ? n : null;\n};\n\n\n/**\n * Evaluate a division expressed as a string\n * @param {string} exprString\n *   The expression to evaluate, e.g. \"200/2\". Can also be a single number\n * @return {?number} The evaluated expression as floating point number on\n *   success; otherwise return null.\n */\nshaka.util.XmlUtils.evalDivision = function(exprString) {\n  var res;\n  var n;\n  if (res = exprString.match(/^(\\d+)\\/(\\d+)$/)) {\n    n = Number(res[1] / res[2]);\n  } else {\n    n = Number(exprString);\n  }\n  return !isNaN(n) ? n : null;\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/third_party/jsdoc/cli.js":"/*global java */\n/*eslint no-process-exit:0 */\n/**\n * Helper methods for running JSDoc on the command line.\n *\n * A few critical notes for anyone who works on this module:\n *\n * + The module should really export an instance of `cli`, and `props` should be properties of a\n * `cli` instance. However, Rhino interpreted `this` as a reference to `global` within the\n * prototype's methods, so we couldn't do that.\n * + On Rhino, for unknown reasons, the `jsdoc/fs` and `jsdoc/path` modules can fail in some cases\n * when they are required by this module. You may need to use `fs` and `path` instead.\n *\n * @private\n */\nmodule.exports = (function() {\n'use strict';\n\nvar logger = require('jsdoc/util/logger');\nvar stripJsonComments = require('strip-json-comments');\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\nvar props = {\n    docs: [],\n    packageJson: null,\n    shouldExitWithError: false,\n    tmpdir: null\n};\n\nvar app = global.app;\nvar env = global.env;\n\nvar FATAL_ERROR_MESSAGE = 'Exiting JSDoc because an error occurred. See the previous log ' +\n    'messages for details.';\nvar cli = {};\n\n// TODO: docs\ncli.setVersionInfo = function() {\n    var fs = require('fs');\n    var path = require('path');\n\n    // allow this to throw--something is really wrong if we can't read our own package file\n    var info = JSON.parse( fs.readFileSync(path.join(env.dirname, 'package.json'), 'utf8') );\n\n    env.version = {\n        number: info.version,\n        revision: new Date( parseInt(info.revision, 10) ).toUTCString()\n    };\n\n    return cli;\n};\n\n// TODO: docs\ncli.loadConfig = function() {\n    var _ = require('underscore');\n    var args = require('jsdoc/opts/args');\n    var Config = require('jsdoc/config');\n    var fs = require('jsdoc/fs');\n    var path = require('jsdoc/path');\n\n    var confPath;\n    var isFile;\n\n    var defaultOpts = {\n        destination: './out/',\n        encoding: 'utf8'\n    };\n\n    try {\n        env.opts = args.parse(env.args);\n    }\n    catch (e) {\n        cli.exit(1, e.message + '\\n' + FATAL_ERROR_MESSAGE);\n    }\n\n    confPath = env.opts.configure || path.join(env.dirname, 'conf.json');\n    try {\n        isFile = fs.statSync(confPath).isFile();\n    }\n    catch(e) {\n        isFile = false;\n    }\n\n    if ( !isFile && !env.opts.configure ) {\n        confPath = path.join(env.dirname, 'conf.json.EXAMPLE');\n    }\n\n    try {\n        env.conf = new Config( stripJsonComments(fs.readFileSync(confPath, 'utf8')) )\n            .get();\n    }\n    catch (e) {\n        cli.exit(1, 'Cannot parse the config file ' + confPath + ': ' + e + '\\n' +\n            FATAL_ERROR_MESSAGE);\n    }\n\n    // look for options on the command line, in the config file, and in the defaults, in that order\n    env.opts = _.defaults(env.opts, env.conf.opts, defaultOpts);\n\n    return cli;\n};\n\n// TODO: docs\ncli.configureLogger = function() {\n    function recoverableError() {\n        props.shouldExitWithError = true;\n    }\n\n    function fatalError() {\n        cli.exit(1);\n    }\n\n    if (env.opts.debug) {\n        logger.setLevel(logger.LEVELS.DEBUG);\n    }\n    else if (env.opts.verbose) {\n        logger.setLevel(logger.LEVELS.INFO);\n    }\n\n    if (env.opts.pedantic) {\n        logger.once('logger:warn', recoverableError);\n        logger.once('logger:error', fatalError);\n    }\n    else {\n        logger.once('logger:error', recoverableError);\n    }\n\n    logger.once('logger:fatal', fatalError);\n\n    return cli;\n};\n\n// TODO: docs\ncli.logStart = function() {\n    logger.debug( cli.getVersion() );\n\n    logger.debug('Environment info: %j', {\n        env: {\n            conf: env.conf,\n            opts: env.opts\n        }\n    });\n};\n\n// TODO: docs\ncli.logFinish = function() {\n    var delta;\n    var deltaSeconds;\n\n    if (env.run.finish && env.run.start) {\n        delta = env.run.finish.getTime() - env.run.start.getTime();\n    }\n\n    if (delta !== undefined) {\n        deltaSeconds = (delta / 1000).toFixed(2);\n        logger.info('Finished running in %s seconds.', deltaSeconds);\n    }\n};\n\n// TODO: docs\ncli.runCommand = function(cb) {\n    var cmd;\n\n    var opts = env.opts;\n\n    function done(errorCode) {\n        if (!errorCode && props.shouldExitWithError) {\n            cb(1);\n        }\n        else {\n            cb(errorCode);\n        }\n    }\n\n    if (opts.help) {\n        cmd = cli.printHelp;\n    }\n    else if (opts.test) {\n        cmd = cli.runTests;\n    }\n    else if (opts.version) {\n        cmd = cli.printVersion;\n    }\n    else {\n        cmd = cli.main;\n    }\n\n    cmd(done);\n};\n\n// TODO: docs\ncli.printHelp = function(cb) {\n    cli.printVersion();\n    console.log( '\\n' + require('jsdoc/opts/args').help() + '\\n' );\n    console.log('Visit http://usejsdoc.org for more information.');\n    cb(0);\n};\n\n// TODO: docs\ncli.runTests = function(cb) {\n    var path = require('jsdoc/path');\n\n    var runner = require( path.join(env.dirname, 'test/runner') );\n\n    console.log('Running tests...');\n    runner(function(failCount) {\n        cb(failCount);\n    });\n};\n\n// TODO: docs\ncli.getVersion = function() {\n    return 'JSDoc ' + env.version.number + ' (' + env.version.revision + ')';\n};\n\n// TODO: docs\ncli.printVersion = function(cb) {\n    console.log( cli.getVersion() );\n\n    if (cb) {\n        cb(0);\n    }\n};\n\n// TODO: docs\ncli.main = function(cb) {\n    cli.scanFiles();\n\n    if (env.sourceFiles.length) {\n        cli.createParser()\n            .parseFiles()\n            .processParseResults();\n    }\n    else {\n        console.log('There are no input files to process.\\n');\n        cli.printHelp(cb);\n    }\n\n    env.run.finish = new Date();\n    cb(0);\n};\n\nfunction readPackageJson(filepath) {\n    var fs = require('jsdoc/fs');\n\n    try {\n        return stripJsonComments( fs.readFileSync(filepath, 'utf8') );\n    }\n    catch (e) {\n        logger.error('Unable to read the package file \"%s\"', filepath);\n        return null;\n    }\n}\n\nfunction buildSourceList() {\n    var fs = require('jsdoc/fs');\n    var Readme = require('jsdoc/readme');\n\n    var packageJson;\n    var readmeHtml;\n    var sourceFile;\n    var sourceFiles = env.opts._ ? env.opts._.slice(0) : [];\n\n    if (env.conf.source && env.conf.source.include) {\n        sourceFiles = sourceFiles.concat(env.conf.source.include);\n    }\n\n    // load the user-specified package/README files, if any\n    if (env.opts.package) {\n        packageJson = readPackageJson(env.opts.package);\n    }\n    if (env.opts.readme) {\n        readmeHtml = new Readme(env.opts.readme).html;\n    }\n\n    // source files named `package.json` or `README.md` get special treatment, unless the user\n    // explicitly specified a package and/or README file\n    for (var i = 0, l = sourceFiles.length; i < l; i++) {\n        sourceFile = sourceFiles[i];\n\n        if ( !env.opts.package && /\\bpackage\\.json$/i.test(sourceFile) ) {\n            packageJson = readPackageJson(sourceFile);\n            sourceFiles.splice(i--, 1);\n        }\n\n        if ( !env.opts.readme && /(\\bREADME|\\.md)$/i.test(sourceFile) ) {\n            readmeHtml = new Readme(sourceFile).html;\n            sourceFiles.splice(i--, 1);\n        }\n    }\n\n    props.packageJson = packageJson;\n    env.opts.readme = readmeHtml;\n\n    return sourceFiles;\n}\n\n// TODO: docs\ncli.scanFiles = function() {\n    var Filter = require('jsdoc/src/filter').Filter;\n\n    var filter;\n\n    env.opts._ = buildSourceList();\n\n    // are there any files to scan and parse?\n    if (env.conf.source && env.opts._.length) {\n        filter = new Filter(env.conf.source);\n\n        env.sourceFiles = app.jsdoc.scanner.scan(env.opts._, (env.opts.recurse ? 10 : undefined),\n            filter);\n    }\n\n    return cli;\n};\n\nfunction resolvePluginPaths(paths) {\n    var path = require('jsdoc/path');\n\n    var pluginPaths = [];\n\n    paths.forEach(function(plugin) {\n        var basename = path.basename(plugin);\n        var dirname = path.dirname(plugin);\n        var pluginPath = path.getResourcePath(dirname);\n\n        if (!pluginPath) {\n            logger.error('Unable to find the plugin \"%s\"', plugin);\n            return;\n        }\n\n        pluginPaths.push( path.join(pluginPath, basename) );\n    });\n\n    return pluginPaths;\n}\n\ncli.createParser = function() {\n    var handlers = require('jsdoc/src/handlers');\n    var parser = require('jsdoc/src/parser');\n    var path = require('jsdoc/path');\n    var plugins = require('jsdoc/plugins');\n\n    app.jsdoc.parser = parser.createParser(env.conf.parser);\n\n    if (env.conf.plugins) {\n        env.conf.plugins = resolvePluginPaths(env.conf.plugins);\n        plugins.installPlugins(env.conf.plugins, app.jsdoc.parser);\n    }\n\n    handlers.attachTo(app.jsdoc.parser);\n\n    return cli;\n};\n\ncli.parseFiles = function() {\n    var augment = require('jsdoc/augment');\n    var borrow = require('jsdoc/borrow');\n    var Package = require('jsdoc/package').Package;\n\n    var docs;\n    var packageDocs;\n\n    props.docs = docs = app.jsdoc.parser.parse(env.sourceFiles, env.opts.encoding);\n\n    // If there is no package.json, just create an empty package\n    packageDocs = new Package(props.packageJson);\n    packageDocs.files = env.sourceFiles || [];\n    docs.push(packageDocs);\n\n    logger.debug('Adding inherited symbols...');\n    borrow.indexAll(docs);\n    augment.addInherited(docs);\n    augment.addImplemented(docs);\n    borrow.resolveBorrows(docs);\n\n    app.jsdoc.parser.fireProcessingComplete(docs);\n\n    return cli;\n};\n\ncli.processParseResults = function() {\n    if (env.opts.explain) {\n        cli.dumpParseResults();\n    }\n    else {\n        cli.resolveTutorials();\n        cli.generateDocs();\n    }\n\n    return cli;\n};\n\ncli.dumpParseResults = function() {\n    global.dump(props.docs);\n\n    return cli;\n};\n\ncli.resolveTutorials = function() {\n    var resolver = require('jsdoc/tutorial/resolver');\n\n    if (env.opts.tutorials) {\n        resolver.load(env.opts.tutorials);\n        resolver.resolve();\n    }\n\n    return cli;\n};\n\ncli.generateDocs = function() {\n    var path = require('jsdoc/path');\n    var resolver = require('jsdoc/tutorial/resolver');\n    var taffy = require('taffydb').taffy;\n\n    var template;\n\n    env.opts.template = (function() {\n        var publish = env.opts.template || 'templates/default';\n        var templatePath = path.getResourcePath(publish);\n\n        // if we didn't find the template, keep the user-specified value so the error message is\n        // useful\n        return templatePath || env.opts.template;\n    })();\n\n    try {\n        template = require(env.opts.template + '/publish');\n    }\n    catch(e) {\n        logger.fatal('Unable to load template: ' + e.message || e);\n    }\n\n    // templates should include a publish.js file that exports a \"publish\" function\n    if (template.publish && typeof template.publish === 'function') {\n        logger.printInfo('Generating output files...');\n        template.publish(\n            taffy(props.docs),\n            env.opts,\n            resolver.root\n        );\n        logger.info('complete.');\n    }\n    else {\n        logger.fatal(env.opts.template + ' does not export a \"publish\" function. Global ' +\n            '\"publish\" functions are no longer supported.');\n    }\n\n    return cli;\n};\n\n// TODO: docs\ncli.exit = function(exitCode, message) {\n    if (message && exitCode > 0) {\n        console.error(message);\n    }\n\n    process.exit(exitCode || 0);\n};\n\nreturn cli;\n})();\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/third_party/jsdoc/jsdoc.js":"#!/usr/bin/env node\n/*global arguments, require: true */\n/**\n * @project jsdoc\n * @author Michael Mathews <micmath@gmail.com>\n * @license See LICENSE.md file included in this distribution.\n */\n\n/**\n * Data representing the environment in which this app is running.\n *\n * @namespace\n * @name env\n */\nglobal.env = {\n    /**\n     * Running start and finish times.\n     *\n     * @memberof env\n     */\n    run: {\n        start: new Date(),\n        finish: null\n    },\n\n    /**\n     * The command-line arguments passed into JSDoc.\n     *\n     * @type Array\n     * @memberof env\n     */\n    args: [],\n\n    /**\n     * The parsed JSON data from the configuration file.\n     *\n     * @type Object\n     * @memberof env\n     */\n    conf: {},\n\n    /**\n     * The absolute path to the base directory of the JSDoc application.\n     *\n     * @private\n     * @type string\n     * @memberof env\n     */\n    dirname: '.',\n\n    /**\n     * The user's working directory at the time that JSDoc was started.\n     *\n     * @private\n     * @type string\n     * @memberof env\n     */\n    pwd: null,\n\n    /**\n     * The command-line options, parsed into a key/value hash.\n     *\n     * @type Object\n     * @memberof env\n     * @example if (global.env.opts.help) { console.log('Helpful message.'); }\n    */\n    opts: {},\n\n    /**\n     * The source files that JSDoc will parse.\n     * @type Array\n     * @memberof env\n     */\n    sourceFiles: [],\n\n    /**\n     * The JSDoc version number and revision date.\n     *\n     * @type Object\n     * @memberof env\n     */\n    version: {}\n};\n\n// initialize the environment for the current JavaScript VM\n(function(args) {\n    'use strict';\n\n    var path;\n\n    if (args[0] && typeof args[0] === 'object') {\n        // we should be on Node.js\n        args = [__dirname, process.cwd()];\n        path = require('path');\n\n        // Create a custom require method that adds `lib/jsdoc` and `node_modules` to the module\n        // lookup path. This makes it possible to `require('jsdoc/foo')` from external templates and\n        // plugins, and within JSDoc itself. It also allows external templates and plugins to\n        // require JSDoc's module dependencies without installing them locally.\n        require = require('requizzle')({\n            requirePaths: {\n                before: [path.join(__dirname, 'lib')],\n                after: [path.join(__dirname, 'node_modules')]\n            },\n            infect: true\n        });\n    }\n\n    require('./lib/jsdoc/util/runtime').initialize(args);\n})( Array.prototype.slice.call(arguments, 0) );\n\n/**\n * Data that must be shared across the entire application.\n *\n * @namespace\n * @name app\n */\nglobal.app = {\n    jsdoc: {\n        name: require('./lib/jsdoc/name'),\n        parser: null,\n        scanner: new (require('./lib/jsdoc/src/scanner').Scanner)()\n    }\n};\n\n/**\n * Recursively print an object's properties to stdout. This method is safe to use with objects that\n * contain circular references. In addition, on Mozilla Rhino, this method is safe to use with\n * native Java objects.\n *\n * @global\n * @name dump\n * @private\n * @param {Object} obj - Object(s) to print to stdout.\n */\nglobal.dump = function() {\n    'use strict';\n\n    var doop = require('./lib/jsdoc/util/doop').doop;\n    var _dump = require('./lib/jsdoc/util/dumper').dump;\n    for (var i = 0, l = arguments.length; i < l; i++) {\n        console.log( _dump(doop(arguments[i])) );\n    }\n};\n\n(function() {\n    'use strict';\n\n    var logger = require('./lib/jsdoc/util/logger');\n    var runtime = require('./lib/jsdoc/util/runtime');\n    var cli = require('./cli');\n\n    function cb(errorCode) {\n        cli.logFinish();\n        cli.exit(errorCode || 0);\n    }\n\n    cli.setVersionInfo()\n        .loadConfig();\n\n    if (!global.env.opts.test) {\n        cli.configureLogger();\n    }\n\n    cli.logStart();\n\n    // On Rhino, we use a try/catch block so we can log the Java exception (if available)\n    if ( runtime.isRhino() ) {\n        try {\n            cli.runCommand(cb);\n        }\n        catch(e) {\n            if (e.rhinoException) {\n                logger.fatal( e.rhinoException.printStackTrace() );\n            } else {\n                console.trace(e);\n                cli.exit(1);\n            }\n        }\n    }\n    else {\n        cli.runCommand(cb);\n    }\n})();\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/third_party/closure/goog/base.js":"// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Bootstrap for the Google JS Library (Closure).\n *\n * In uncompiled mode base.js will write out Closure's deps file, unless the\n * global <code>CLOSURE_NO_DEPS</code> is set to true.  This allows projects to\n * include their own deps file(s) from different locations.\n *\n *\n * @provideGoog\n */\n\n\n/**\n * @define {boolean} Overridden to true by the compiler when --closure_pass\n *     or --mark_as_compiled is specified.\n */\nvar COMPILED = false;\n\n\n/**\n * Base namespace for the Closure library.  Checks to see goog is already\n * defined in the current scope before assigning to prevent clobbering if\n * base.js is loaded more than once.\n *\n * @const\n */\nvar goog = goog || {};\n\n\n/**\n * Reference to the global context.  In most cases this will be 'window'.\n */\ngoog.global = this;\n\n\n/**\n * A hook for overriding the define values in uncompiled mode.\n *\n * In uncompiled mode, {@code CLOSURE_UNCOMPILED_DEFINES} may be defined before\n * loading base.js.  If a key is defined in {@code CLOSURE_UNCOMPILED_DEFINES},\n * {@code goog.define} will use the value instead of the default value.  This\n * allows flags to be overwritten without compilation (this is normally\n * accomplished with the compiler's \"define\" flag).\n *\n * Example:\n * <pre>\n *   var CLOSURE_UNCOMPILED_DEFINES = {'goog.DEBUG': false};\n * </pre>\n *\n * @type {Object.<string, (string|number|boolean)>|undefined}\n */\ngoog.global.CLOSURE_UNCOMPILED_DEFINES;\n\n\n/**\n * A hook for overriding the define values in uncompiled or compiled mode,\n * like CLOSURE_UNCOMPILED_DEFINES but effective in compiled code.  In\n * uncompiled code CLOSURE_UNCOMPILED_DEFINES takes precedence.\n *\n * Also unlike CLOSURE_UNCOMPILED_DEFINES the values must be number, boolean or\n * string literals or the compiler will emit an error.\n *\n * While any @define value may be set, only those set with goog.define will be\n * effective for uncompiled code.\n *\n * Example:\n * <pre>\n *   var CLOSURE_DEFINES = {'goog.DEBUG': false};\n * </pre>\n *\n * @type {Object.<string, (string|number|boolean)>|undefined}\n */\ngoog.global.CLOSURE_DEFINES;\n\n\n/**\n * Returns true if the specified value is not undefined.\n * WARNING: Do not use this to test if an object has a property. Use the in\n * operator instead.\n *\n * @param {?} val Variable to test.\n * @return {boolean} Whether variable is defined.\n */\ngoog.isDef = function(val) {\n  // void 0 always evaluates to undefined and hence we do not need to depend on\n  // the definition of the global variable named 'undefined'.\n  return val !== void 0;\n};\n\n\n/**\n * Builds an object structure for the provided namespace path, ensuring that\n * names that already exist are not overwritten. For example:\n * \"a.b.c\" -> a = {};a.b={};a.b.c={};\n * Used by goog.provide and goog.exportSymbol.\n * @param {string} name name of the object that this file defines.\n * @param {*=} opt_object the object to expose at the end of the path.\n * @param {Object=} opt_objectToExportTo The object to add the path to; default\n *     is |goog.global|.\n * @private\n */\ngoog.exportPath_ = function(name, opt_object, opt_objectToExportTo) {\n  var parts = name.split('.');\n  var cur = opt_objectToExportTo || goog.global;\n\n  // Internet Explorer exhibits strange behavior when throwing errors from\n  // methods externed in this manner.  See the testExportSymbolExceptions in\n  // base_test.html for an example.\n  if (!(parts[0] in cur) && cur.execScript) {\n    cur.execScript('var ' + parts[0]);\n  }\n\n  // Certain browsers cannot parse code in the form for((a in b); c;);\n  // This pattern is produced by the JSCompiler when it collapses the\n  // statement above into the conditional loop below. To prevent this from\n  // happening, use a for-loop and reserve the init logic as below.\n\n  // Parentheses added to eliminate strict JS warning in Firefox.\n  for (var part; parts.length && (part = parts.shift());) {\n    if (!parts.length && goog.isDef(opt_object)) {\n      // last part and we have an object; use it\n      cur[part] = opt_object;\n    } else if (cur[part]) {\n      cur = cur[part];\n    } else {\n      cur = cur[part] = {};\n    }\n  }\n};\n\n\n/**\n * Defines a named value. In uncompiled mode, the value is retreived from\n * CLOSURE_DEFINES or CLOSURE_UNCOMPILED_DEFINES if the object is defined and\n * has the property specified, and otherwise used the defined defaultValue.\n * When compiled, the default can be overridden using compiler command-line\n * options.\n *\n * @param {string} name The distinguished name to provide.\n * @param {string|number|boolean} defaultValue\n */\ngoog.define = function(name, defaultValue) {\n  var value = defaultValue;\n  if (!COMPILED) {\n    if (goog.global.CLOSURE_UNCOMPILED_DEFINES &&\n        Object.prototype.hasOwnProperty.call(\n            goog.global.CLOSURE_UNCOMPILED_DEFINES, name)) {\n      value = goog.global.CLOSURE_UNCOMPILED_DEFINES[name];\n    } else if (goog.global.CLOSURE_DEFINES &&\n        Object.prototype.hasOwnProperty.call(\n            goog.global.CLOSURE_DEFINES, name)) {\n      value = goog.global.CLOSURE_DEFINES[name];\n    }\n  }\n  goog.exportPath_(name, value);\n};\n\n\n/**\n * @define {boolean} DEBUG is provided as a convenience so that debugging code\n * that should not be included in a production js_binary can be easily stripped\n * by specifying --define goog.DEBUG=false to the JSCompiler. For example, most\n * toString() methods should be declared inside an \"if (goog.DEBUG)\" conditional\n * because they are generally used for debugging purposes and it is difficult\n * for the JSCompiler to statically determine whether they are used.\n */\ngoog.DEBUG = true;\n\n\n/**\n * @define {string} LOCALE defines the locale being used for compilation. It is\n * used to select locale specific data to be compiled in js binary. BUILD rule\n * can specify this value by \"--define goog.LOCALE=<locale_name>\" as JSCompiler\n * option.\n *\n * Take into account that the locale code format is important. You should use\n * the canonical Unicode format with hyphen as a delimiter. Language must be\n * lowercase, Language Script - Capitalized, Region - UPPERCASE.\n * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.\n *\n * See more info about locale codes here:\n * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers\n *\n * For language codes you should use values defined by ISO 693-1. See it here\n * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from\n * this rule: the Hebrew language. For legacy reasons the old code (iw) should\n * be used instead of the new code (he), see http://wiki/Main/IIISynonyms.\n */\ngoog.define('goog.LOCALE', 'en');  // default to en\n\n\n/**\n * @define {boolean} Whether this code is running on trusted sites.\n *\n * On untrusted sites, several native functions can be defined or overridden by\n * external libraries like Prototype, Datejs, and JQuery and setting this flag\n * to false forces closure to use its own implementations when possible.\n *\n * If your JavaScript can be loaded by a third party site and you are wary about\n * relying on non-standard implementations, specify\n * \"--define goog.TRUSTED_SITE=false\" to the JSCompiler.\n */\ngoog.define('goog.TRUSTED_SITE', true);\n\n\n/**\n * @define {boolean} Whether a project is expected to be running in strict mode.\n *\n * This define can be used to trigger alternate implementations compatible with\n * running in EcmaScript Strict mode or warn about unavailable functionality.\n * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode\n */\ngoog.define('goog.STRICT_MODE_COMPATIBLE', false);\n\n\n/**\n * Creates object stubs for a namespace.  The presence of one or more\n * goog.provide() calls indicate that the file defines the given\n * objects/namespaces.  Provided objects must not be null or undefined.\n * Build tools also scan for provide/require statements\n * to discern dependencies, build dependency files (see deps.js), etc.\n * @see goog.require\n * @param {string} name Namespace provided by this file in the form\n *     \"goog.package.part\".\n */\ngoog.provide = function(name) {\n  if (!COMPILED) {\n    // Ensure that the same namespace isn't provided twice.\n    // A goog.module/goog.provide maps a goog.require to a specific file\n    if (goog.isProvided_(name)) {\n      throw Error('Namespace \"' + name + '\" already declared.');\n    }\n    delete goog.implicitNamespaces_[name];\n\n    var namespace = name;\n    while ((namespace = namespace.substring(0, namespace.lastIndexOf('.')))) {\n      if (goog.getObjectByName(namespace)) {\n        break;\n      }\n      goog.implicitNamespaces_[namespace] = true;\n    }\n  }\n\n  goog.exportPath_(name);\n};\n\n\n/**\n * Forward declares a symbol. This is an indication to the compiler that the\n * symbol may be used in the source yet is not required and may not be provided\n * in compilation.\n *\n * The most common usage of forward declaration is code that takes a type as a\n * function parameter but does not need to require it. By forward declaring\n * instead of requiring, no hard dependency is made, and (if not required\n * elsewhere) the namespace may never be required and thus, not be pulled\n * into the JavaScript binary. If it is required elsewhere, it will be type\n * checked as normal.\n *\n *\n * @param {string} name The namespace to forward declare in the form of\n *     \"goog.package.part\".\n */\ngoog.forwardDeclare = function(name) {};\n\n\nif (!COMPILED) {\n\n  /**\n   * Check if the given name has been goog.provided. This will return false for\n   * names that are available only as implicit namespaces.\n   * @param {string} name name of the object to look for.\n   * @return {boolean} Whether the name has been provided.\n   * @private\n   */\n  goog.isProvided_ = function(name) {\n    return (!goog.implicitNamespaces_[name] &&\n        goog.isDefAndNotNull(goog.getObjectByName(name)));\n  };\n\n  /**\n   * Namespaces implicitly defined by goog.provide. For example,\n   * goog.provide('goog.events.Event') implicitly declares that 'goog' and\n   * 'goog.events' must be namespaces.\n   *\n   * @type {Object.<string, (boolean|undefined)>}\n   * @private\n   */\n  goog.implicitNamespaces_ = {};\n}\n\n\n/**\n * Returns an object based on its fully qualified external name.  The object\n * is not found if null or undefined.  If you are using a compilation pass that\n * renames property names beware that using this function will not find renamed\n * properties.\n *\n * @param {string} name The fully qualified name.\n * @param {Object=} opt_obj The object within which to look; default is\n *     |goog.global|.\n * @return {?} The value (object or primitive) or, if not found, null.\n */\ngoog.getObjectByName = function(name, opt_obj) {\n  var parts = name.split('.');\n  var cur = opt_obj || goog.global;\n  for (var part; part = parts.shift(); ) {\n    if (goog.isDefAndNotNull(cur[part])) {\n      cur = cur[part];\n    } else {\n      return null;\n    }\n  }\n  return cur;\n};\n\n\n/**\n * Globalizes a whole namespace, such as goog or goog.lang.\n *\n * @param {Object} obj The namespace to globalize.\n * @param {Object=} opt_global The object to add the properties to.\n * @deprecated Properties may be explicitly exported to the global scope, but\n *     this should no longer be done in bulk.\n */\ngoog.globalize = function(obj, opt_global) {\n  var global = opt_global || goog.global;\n  for (var x in obj) {\n    global[x] = obj[x];\n  }\n};\n\n\n/**\n * Adds a dependency from a file to the files it requires.\n * @param {string} relPath The path to the js file.\n * @param {Array} provides An array of strings with the names of the objects\n *                         this file provides.\n * @param {Array} requires An array of strings with the names of the objects\n *                         this file requires.\n */\ngoog.addDependency = function(relPath, provides, requires) {\n  if (goog.DEPENDENCIES_ENABLED) {\n    var provide, require;\n    var path = relPath.replace(/\\\\/g, '/');\n    var deps = goog.dependencies_;\n    for (var i = 0; provide = provides[i]; i++) {\n      deps.nameToPath[provide] = path;\n    }\n    for (var j = 0; require = requires[j]; j++) {\n      if (!(path in deps.requires)) {\n        deps.requires[path] = {};\n      }\n      deps.requires[path][require] = true;\n    }\n  }\n};\n\n\n\n\n// NOTE(nnaze): The debug DOM loader was included in base.js as an original way\n// to do \"debug-mode\" development.  The dependency system can sometimes be\n// confusing, as can the debug DOM loader's asynchronous nature.\n//\n// With the DOM loader, a call to goog.require() is not blocking -- the script\n// will not load until some point after the current script.  If a namespace is\n// needed at runtime, it needs to be defined in a previous script, or loaded via\n// require() with its registered dependencies.\n// User-defined namespaces may need their own deps file.  See http://go/js_deps,\n// http://go/genjsdeps, or, externally, DepsWriter.\n// https://developers.google.com/closure/library/docs/depswriter\n//\n// Because of legacy clients, the DOM loader can't be easily removed from\n// base.js.  Work is being done to make it disableable or replaceable for\n// different environments (DOM-less JavaScript interpreters like Rhino or V8,\n// for example). See bootstrap/ for more information.\n\n\n/**\n * @define {boolean} Whether to enable the debug loader.\n *\n * If enabled, a call to goog.require() will attempt to load the namespace by\n * appending a script tag to the DOM (if the namespace has been registered).\n *\n * If disabled, goog.require() will simply assert that the namespace has been\n * provided (and depend on the fact that some outside tool correctly ordered\n * the script).\n */\ngoog.define('goog.ENABLE_DEBUG_LOADER', true);\n\n\n/**\n * @param {string} msg\n * @private\n */\ngoog.logToConsole_ = function(msg) {\n  if (goog.global.console) {\n    goog.global.console['error'](msg);\n  }\n};\n\n\n/**\n * Implements a system for the dynamic resolution of dependencies that works in\n * parallel with the BUILD system. Note that all calls to goog.require will be\n * stripped by the JSCompiler when the --closure_pass option is used.\n * @see goog.provide\n * @param {string} name Namespace to include (as was given in goog.provide()) in\n *     the form \"goog.package.part\".\n * @return {?} If called within a goog.module file, the associated namespace or\n *     module otherwise null.\n */\ngoog.require = function(name) {\n\n  // If the object already exists we do not need do do anything.\n  if (!COMPILED) {\n    if (goog.isProvided_(name)) {\n      return null;\n    }\n\n    if (goog.ENABLE_DEBUG_LOADER) {\n      var path = goog.getPathFromDeps_(name);\n      if (path) {\n        goog.included_[path] = true;\n        goog.writeScripts_();\n        return null;\n      }\n    }\n\n    var errorMessage = 'goog.require could not find: ' + name;\n    goog.logToConsole_(errorMessage);\n\n    throw Error(errorMessage);\n  }\n};\n\n\n/**\n * Path for included scripts.\n * @type {string}\n */\ngoog.basePath = '';\n\n\n/**\n * A hook for overriding the base path.\n * @type {string|undefined}\n */\ngoog.global.CLOSURE_BASE_PATH;\n\n\n/**\n * Whether to load Closure's deps file automatically.\n * Shaka sets this to true since we are placing deps.js in a non-standard\n * location.  Running Shaka in uncompiled mode will require loading deps.js\n * explicitly.\n * @type {boolean|undefined}\n */\ngoog.global.CLOSURE_NO_DEPS = true;\n\n\n/**\n * A function to import a single script. This is meant to be overridden when\n * Closure is being run in non-HTML contexts, such as web workers. It's defined\n * in the global scope so that it can be set before base.js is loaded, which\n * allows deps.js to be imported properly.\n *\n * The function is passed the script source, which is a relative URI. It should\n * return true if the script was imported, false otherwise.\n * @type {(function(string): boolean)|undefined}\n */\ngoog.global.CLOSURE_IMPORT_SCRIPT;\n\n\n/**\n * True if goog.dependencies_ is available.\n * @const {boolean}\n */\ngoog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;\n\n\nif (goog.DEPENDENCIES_ENABLED) {\n  /**\n   * Object used to keep track of urls that have already been added. This record\n   * allows the prevention of circular dependencies.\n   * @type {Object}\n   * @private\n   */\n  goog.included_ = {};\n\n\n  /**\n   * This object is used to keep track of dependencies and other data that is\n   * used for loading scripts.\n   * @private\n   * @type {Object}\n   */\n  goog.dependencies_ = {\n    nameToPath: {}, // many to 1\n    requires: {}, // 1 to many\n    // Used when resolving dependencies to prevent us from visiting file twice.\n    visited: {},\n    written: {} // Used to keep track of script files we have written.\n  };\n\n\n  /**\n   * Tries to detect whether is in the context of an HTML document.\n   * @return {boolean} True if it looks like HTML document.\n   * @private\n   */\n  goog.inHtmlDocument_ = function() {\n    var doc = goog.global.document;\n    return typeof doc != 'undefined' &&\n           'write' in doc;  // XULDocument misses write.\n  };\n\n\n  /**\n   * Tries to detect the base path of base.js script that bootstraps Closure.\n   * @private\n   */\n  goog.findBasePath_ = function() {\n    if (goog.global.CLOSURE_BASE_PATH) {\n      goog.basePath = goog.global.CLOSURE_BASE_PATH;\n      return;\n    } else if (!goog.inHtmlDocument_()) {\n      return;\n    }\n    var doc = goog.global.document;\n    var scripts = doc.getElementsByTagName('script');\n    // Search backwards since the current script is in almost all cases the one\n    // that has base.js.\n    for (var i = scripts.length - 1; i >= 0; --i) {\n      var src = scripts[i].src;\n      var qmark = src.lastIndexOf('?');\n      var l = qmark == -1 ? src.length : qmark;\n      if (src.substr(l - 7, 7) == 'base.js') {\n        goog.basePath = src.substr(0, l - 7);\n        return;\n      }\n    }\n  };\n\n\n  /**\n   * Imports a script if, and only if, that script hasn't already been imported.\n   * (Must be called at execution time)\n   * @param {string} src Script source.\n   * @param {string=} opt_sourceText The optionally source text to evaluate\n   * @private\n   */\n  goog.importScript_ = function(src, opt_sourceText) {\n    var importScript = goog.global.CLOSURE_IMPORT_SCRIPT ||\n        goog.writeScriptTag_;\n    if (importScript(src, opt_sourceText)) {\n      goog.dependencies_.written[src] = true;\n    }\n  };\n\n\n  /**\n   * The default implementation of the import function. Writes a script tag to\n   * import the script.\n   *\n   * @param {string} src The script url.\n   * @param {string=} opt_sourceText The optionally source text to evaluate\n   * @return {boolean} True if the script was imported, false otherwise.\n   * @private\n   */\n  goog.writeScriptTag_ = function(src, opt_sourceText) {\n    if (goog.inHtmlDocument_()) {\n      var doc = goog.global.document;\n\n      // If the user tries to require a new symbol after document load,\n      // something has gone terribly wrong. Doing a document.write would\n      // wipe out the page.\n      if (doc.readyState == 'complete') {\n        // Certain test frameworks load base.js multiple times, which tries\n        // to write deps.js each time. If that happens, just fail silently.\n        // These frameworks wipe the page between each load of base.js, so this\n        // is OK.\n        var isDeps = /\\bdeps.js$/.test(src);\n        if (isDeps) {\n          return false;\n        } else {\n          throw Error('Cannot write \"' + src + '\" after document load');\n        }\n      }\n\n      if (opt_sourceText === undefined) {\n        doc.write(\n            '<script type=\"text/javascript\" src=\"' +\n                src + '\"></' + 'script>');\n      } else {\n        doc.write(\n            '<script type=\"text/javascript\">' +\n              opt_sourceText + '</' + 'script>');\n      }\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n\n  /**\n   * Resolves dependencies based on the dependencies added using addDependency\n   * and calls importScript_ in the correct order.\n   * @private\n   */\n  goog.writeScripts_ = function() {\n    // The scripts we need to write this time.\n    var scripts = [];\n    var seenScript = {};\n    var deps = goog.dependencies_;\n\n    function visitNode(path) {\n      if (path in deps.written) {\n        return;\n      }\n\n      // We have already visited this one. We can get here if we have cyclic\n      // dependencies.\n      if (path in deps.visited) {\n        if (!(path in seenScript)) {\n          seenScript[path] = true;\n          scripts.push(path);\n        }\n        return;\n      }\n\n      deps.visited[path] = true;\n\n      if (path in deps.requires) {\n        for (var requireName in deps.requires[path]) {\n          // If the required name is defined, we assume that it was already\n          // bootstrapped by other means.\n          if (!goog.isProvided_(requireName)) {\n            if (requireName in deps.nameToPath) {\n              visitNode(deps.nameToPath[requireName]);\n            } else {\n              throw Error('Undefined nameToPath for ' + requireName);\n            }\n          }\n        }\n      }\n\n      if (!(path in seenScript)) {\n        seenScript[path] = true;\n        scripts.push(path);\n      }\n    }\n\n    for (var path in goog.included_) {\n      if (!deps.written[path]) {\n        visitNode(path);\n      }\n    }\n\n    // record that we are going to load all these scripts.\n    for (var i = 0; i < scripts.length; i++) {\n      var path = scripts[i];\n      goog.dependencies_.written[path] = true;\n    }\n\n    for (var i = 0; i < scripts.length; i++) {\n      var path = scripts[i];\n      if (path) {\n        goog.importScript_(goog.basePath + path);\n      }\n    }\n  };\n\n\n  /**\n   * Looks at the dependency rules and tries to determine the script file that\n   * fulfills a particular rule.\n   * @param {string} rule In the form goog.namespace.Class or project.script.\n   * @return {?string} Url corresponding to the rule, or null.\n   * @private\n   */\n  goog.getPathFromDeps_ = function(rule) {\n    if (rule in goog.dependencies_.nameToPath) {\n      return goog.dependencies_.nameToPath[rule];\n    } else {\n      return null;\n    }\n  };\n\n  goog.findBasePath_();\n\n  // Allow projects to manage the deps files themselves.\n  if (!goog.global.CLOSURE_NO_DEPS) {\n    goog.importScript_(goog.basePath + 'deps.js');\n  }\n}\n\n\n\n//==============================================================================\n// Language Enhancements\n//==============================================================================\n\n\n/**\n * Returns true if the specified value is defined and not null.\n * @param {?} val Variable to test.\n * @return {boolean} Whether variable is defined and not null.\n */\ngoog.isDefAndNotNull = function(val) {\n  // Note that undefined == null.\n  return val != null;\n};\n\n\n/**\n * Returns true if the specified value is a string.\n * @param {?} val Variable to test.\n * @return {boolean} Whether variable is a string.\n */\ngoog.isString = function(val) {\n  return typeof val == 'string';\n};\n\n\n/**\n * Exposes an unobfuscated global namespace path for the given object.\n * Note that fields of the exported object *will* be obfuscated, unless they are\n * exported in turn via this function or goog.exportProperty.\n *\n * Also handy for making public items that are defined in anonymous closures.\n *\n * ex. goog.exportSymbol('public.path.Foo', Foo);\n *\n * ex. goog.exportSymbol('public.path.Foo.staticFunction', Foo.staticFunction);\n *     public.path.Foo.staticFunction();\n *\n * ex. goog.exportSymbol('public.path.Foo.prototype.myMethod',\n *                       Foo.prototype.myMethod);\n *     new public.path.Foo().myMethod();\n *\n * @param {string} publicPath Unobfuscated name to export.\n * @param {*} object Object the name should point to.\n * @param {Object=} opt_objectToExportTo The object to add the path to; default\n *     is goog.global.\n */\ngoog.exportSymbol = function(publicPath, object, opt_objectToExportTo) {\n  goog.exportPath_(publicPath, object, opt_objectToExportTo);\n};\n\n\n/**\n * Exports a property unobfuscated into the object's namespace.\n * ex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);\n * ex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);\n * @param {Object} object Object whose static property is being exported.\n * @param {string} publicName Unobfuscated name to export.\n * @param {*} symbol Object the name should point to.\n */\ngoog.exportProperty = function(object, publicName, symbol) {\n  object[publicName] = symbol;\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * Usage:\n * <pre>\n * function ParentClass(a, b) { }\n * ParentClass.prototype.foo = function(a) { };\n *\n * function ChildClass(a, b, c) {\n *   ChildClass.base(this, 'constructor', a, b);\n * }\n * goog.inherits(ChildClass, ParentClass);\n *\n * var child = new ChildClass('a', 'b', 'see');\n * child.foo(); // This works.\n * </pre>\n *\n * @param {Function} childCtor Child class.\n * @param {Function} parentCtor Parent class.\n */\ngoog.inherits = function(childCtor, parentCtor) {\n  /** @constructor */\n  function tempCtor() {}\n  tempCtor.prototype = parentCtor.prototype;\n  childCtor.superClass_ = parentCtor.prototype;\n  childCtor.prototype = new tempCtor();\n  /** @override */\n  childCtor.prototype.constructor = childCtor;\n\n  /**\n   * Calls superclass constructor/method.\n   *\n   * This function is only available if you use goog.inherits to\n   * express inheritance relationships between classes.\n   *\n   * NOTE: This is a replacement for goog.base and for superClass_\n   * property defined in childCtor.\n   *\n   * @param {!Object} me Should always be \"this\".\n   * @param {string} methodName The method name to call. Calling\n   *     superclass constructor can be done with the special string\n   *     'constructor'.\n   * @param {...*} var_args The arguments to pass to superclass\n   *     method/constructor.\n   * @return {*} The return value of the superclass method/constructor.\n   */\n  childCtor.base = function(me, methodName, var_args) {\n    var args = Array.prototype.slice.call(arguments, 2);\n    return parentCtor.prototype[methodName].apply(me, args);\n  };\n};\n\n\n/*\n * To support uncompiled, strict mode bundles that use eval to divide source\n * like so:\n *    eval('someSource;//# sourceUrl sourcefile.js');\n * We need to export the globally defined symbols \"goog\" and \"COMPILED\".\n * Exporting \"goog\" breaks the compiler optimizations, so we required that\n * be defined externally.\n * NOTE: We don't use goog.exportSymbol here because we don't want to trigger\n * extern generation when that compiler option is enabled.\n */\nif (!COMPILED) {\n  goog.global['COMPILED'] = COMPILED;\n}\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/third_party/jsdoc/node/fs.js":"'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar stream = require('stream');\nvar wrench = require('wrench');\n\nvar toDir = exports.toDir = function(_path) {\n    var isDirectory;\n\n    _path = path.normalize(_path);\n\n    try {\n        isDirectory = fs.statSync(_path).isDirectory();\n    }\n    catch(e) {\n        isDirectory = false;\n    }\n\n    if (isDirectory) {\n       return _path;\n    } else {\n        return path.dirname(_path);\n    }\n};\n\nexports.mkPath = function(/**Array*/ _path) {\n    if ( Array.isArray(_path) ) {\n        _path = _path.join('');\n    }\n\n    wrench.mkdirSyncRecursive(_path);\n};\n\n// adapted from http://procbits.com/2011/11/15/synchronous-file-copy-in-node-js\nexports.copyFileSync = function(inFile, outDir, fileName) {\n    var BUF_LENGTH = 64 * 1024;\n\n    var read;\n    var write;\n\n    var buffer = new Buffer(BUF_LENGTH);\n    var bytesRead = 1;\n    var outFile = path.join( outDir, fileName || path.basename(inFile) );\n    var pos = 0;\n\n    wrench.mkdirSyncRecursive(outDir);\n    read = fs.openSync(inFile, 'r');\n    write = fs.openSync(outFile, 'w');\n\n    while (bytesRead > 0) {\n        bytesRead = fs.readSync(read, buffer, 0, BUF_LENGTH, pos);\n        fs.writeSync(write, buffer, 0, bytesRead);\n        pos += bytesRead;\n    }\n\n    fs.closeSync(read);\n    return fs.closeSync(write);\n};\n\nObject.keys(fs).forEach(function(key) {\n    exports[key] = fs[key];\n});\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/third_party/jsdoc/plugins/commentConvert.js":"/**\n    @overview Demonstrate how to modify the source code before the parser sees it.\n    @module plugins/commentConvert\n    @author Michael Mathews <micmath@gmail.com>\n */\n'use strict';\n\n/*eslint spaced-line-comment: 0 */\n\nexports.handlers = {\n    ///\n    /// Convert ///-style comments into jsdoc comments.\n    /// @param e\n    /// @param e.filename\n    /// @param e.source\n    ///\n    beforeParse: function(e) {\n        e.source = e.source.replace(/(\\n[ \\t]*\\/\\/\\/[^\\n]*)+/g, function($) {\n            var replacement = '\\n/**' + $.replace(/^[ \\t]*\\/\\/\\//mg, '').replace(/(\\n$|$)/, '*/$1');\n            return  replacement;\n        });\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/third_party/jsdoc/plugins/commentsOnly.js":"/**\n * @overview Remove everything in a file except JSDoc-style comments. By enabling this plugin, you\n * can document source files that are not valid JavaScript (including source files for other\n * languages).\n * @module plugins/commentsOnly\n * @author Jeff Williams <jeffrey.l.williams@gmail.com>\n */\n'use strict';\n\nexports.handlers = {\n    beforeParse: function(e) {\n        // a JSDoc comment looks like: /**[one or more chars]*/\n        var comments = e.source.match(/\\/\\*\\*[\\s\\S]+?\\*\\//g);\n        if (comments) {\n            e.source = comments.join('\\n\\n');\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/third_party/jsdoc/plugins/escapeHtml.js":"/**\n    @overview Escape HTML tags in descriptions.\n    @module plugins/escapeHtml\n    @author Michael Mathews <micmath@gmail.com>\n */\n'use strict';\n\nexports.handlers = {\n    /**\n        Translate HTML tags in descriptions into safe entities.\n        Replaces <, & and newlines\n     */\n    newDoclet: function(e) {\n        if (e.doclet.description) {\n            e.doclet.description = e.doclet.description\n                                   .replace(/&/g,'&amp;')\n                                   .replace(/</g,'&lt;')\n                                   .replace(/\\r\\n|\\n|\\r/g, '<br>');\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/third_party/jsdoc/plugins/eventDumper.js":"/*global env: true */\n/**\n * @overview Dump information about parser events to the console.\n * @module plugins/eventDumper\n * @author Jeff Williams <jeffrey.l.williams@gmail.com>\n */\n'use strict';\n\nvar _ = require('underscore');\nvar util = require('util');\n\nvar conf = env.conf.eventDumper || {};\nvar isRhino = require('jsdoc/util/runtime').isRhino();\n\n// Dump the included parser events (defaults to all events)\nvar events = conf.include || [\n    'parseBegin',\n    'fileBegin',\n    'beforeParse',\n    'jsdocCommentFound',\n    'symbolFound',\n    'newDoclet',\n    'fileComplete',\n    'parseComplete',\n    'processingComplete'\n];\n// Don't dump the excluded parser events\nif (conf.exclude) {\n    events = _.difference(events, conf.exclude);\n}\n\n/**\n * Check whether a variable appears to be a Java native object.\n *\n * @param {*} o - The variable to check.\n * @return {boolean} Set to `true` for Java native objects and `false` in all other cases.\n */\nfunction isJavaNativeObject(o) {\n    if (!isRhino) {\n        return false;\n    }\n\n    return o && typeof o === 'object' && typeof o.getClass === 'function';\n}\n\n/**\n * Replace AST node objects in events with a placeholder.\n *\n * @param {Object} o - An object whose properties may contain AST node objects.\n * @return {Object} The modified object.\n */\nfunction replaceNodeObjects(o) {\n    var doop = require('jsdoc/util/doop');\n\n    var OBJECT_PLACEHOLDER = '<Object>';\n\n    if (o.code && o.code.node) {\n        // don't break the original object!\n        o.code = doop(o.code);\n        o.code.node = OBJECT_PLACEHOLDER;\n    }\n\n    if (o.doclet && o.doclet.meta && o.doclet.meta.code && o.doclet.meta.code.node) {\n        // don't break the original object!\n        o.doclet.meta.code = doop(o.doclet.meta.code);\n        o.doclet.meta.code.node = OBJECT_PLACEHOLDER;\n    }\n\n    if (o.astnode) {\n        o.astnode = OBJECT_PLACEHOLDER;\n    }\n\n    return o;\n}\n\n/**\n * Get rid of unwanted crud in an event object.\n *\n * @param {object} e The event object.\n * @return {object} The fixed-up object.\n */\nfunction cleanse(e) {\n    var result = {};\n\n    Object.keys(e).forEach(function(prop) {\n        // by default, don't stringify properties that contain an array of functions\n        if (!conf.includeFunctions && util.isArray(e[prop]) && e[prop][0] &&\n            String(typeof e[prop][0]) === 'function') {\n            result[prop] = 'function[' + e[prop].length + ']';\n        }\n        // never include functions that belong to the object\n        else if (typeof e[prop] !== 'function') {\n            // don't call JSON.stringify() on Java native objects--Rhino will throw an exception\n            result[prop] = isJavaNativeObject(e[prop]) ? String(e[prop]) : e[prop];\n        }\n    });\n\n    // allow users to omit node objects, which can be enormous\n    if (conf.omitNodes) {\n        result = replaceNodeObjects(result);\n    }\n\n    return result;\n}\n\nexports.handlers = {};\n\nevents.forEach(function(eventType) {\n    exports.handlers[eventType] = function(e) {\n        console.log( JSON.stringify({\n            type: eventType,\n            content: cleanse(e)\n        }, null, 4) );\n    };\n});\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/third_party/jsdoc/plugins/markdown.js":"/**\n * @overview Translate doclet descriptions from MarkDown into HTML.\n * @module plugins/markdown\n * @author Michael Mathews <micmath@gmail.com>\n * @author Ben Blank <ben.blank@gmail.com>\n */\n'use strict';\n\nvar config = global.env.conf.markdown || {};\nvar defaultTags = [\n    'classdesc',\n    'description',\n    'exceptions',\n    'params',\n    'properties',\n    'returns',\n    'see'\n];\nvar hasOwnProp = Object.prototype.hasOwnProperty;\nvar parse = require('jsdoc/util/markdown').getParser();\nvar tags = [];\nvar excludeTags = [];\n\nfunction shouldProcessString(tagName, text) {\n    var shouldProcess = false;\n\n    if (tagName !== 'see') {\n        shouldProcess = true;\n    }\n    // we only want to process `@see` tags that contain Markdown links\n    else if (tagName === 'see' && text.indexOf('[') !== -1) {\n        shouldProcess = true;\n    }\n\n    return shouldProcess;\n}\n\n/**\n * Process the markdown source in a doclet. The properties that should be\n * processed are configurable, but always include \"classdesc\", \"description\",\n * \"params\", \"properties\", and \"returns\".  Handled properties can be bare\n * strings, objects, or arrays of objects.\n */\nfunction process(doclet) {\n    tags.forEach(function(tag) {\n        if ( !hasOwnProp.call(doclet, tag) ) {\n            return;\n        }\n\n        if (typeof doclet[tag] === 'string' && shouldProcessString(tag, doclet[tag]) ) {\n            doclet[tag] = parse(doclet[tag]);\n        }\n        else if ( Array.isArray(doclet[tag]) ) {\n            doclet[tag].forEach(function(value, index, original) {\n                var inner = {};\n                inner[tag] = value;\n                process(inner);\n                original[index] = inner[tag];\n            });\n        }\n        else if (doclet[tag]) {\n            process(doclet[tag]);\n        }\n    });\n}\n\n// set up the list of \"tags\" (properties) to process\nif (config.tags) {\n    tags = config.tags.slice();\n}\n// set up the list of default tags to exclude from processing\nif (config.excludeTags) {\n    excludeTags = config.excludeTags.slice();\n}\ndefaultTags.forEach(function(tag) {\n    if (excludeTags.indexOf(tag) === -1 && tags.indexOf(tag) === -1) {\n        tags.push(tag);\n    }\n});\n\nexports.handlers = {\n    /**\n     * Translate markdown syntax in a new doclet's description into HTML. Is run\n     * by JSDoc 3 whenever a \"newDoclet\" event fires.\n     */\n    newDoclet: function(e) {\n        process(e.doclet);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/third_party/jsdoc/plugins/overloadHelper.js":"/**\n * The Overload Helper plugin automatically adds a signature-like string to the longnames of\n * overloaded functions and methods. In JSDoc, this string is known as a _variation_. (The longnames\n * of overloaded constructor functions are _not_ updated, so that JSDoc can identify the class'\n * members correctly.)\n *\n * Using this plugin allows you to link to overloaded functions without manually adding `@variation`\n * tags to your documentation.\n *\n * For example, suppose your code includes a function named `foo` that you can call in the\n * following ways:\n *\n * + `foo()`\n * + `foo(bar)`\n * + `foo(bar, baz)` (where `baz` is repeatable)\n *\n * This plugin assigns the following variations and longnames to each version of `foo`:\n *\n * + `foo()` gets the variation `()` and the longname `foo()`.\n * + `foo(bar)` gets the variation `(bar)` and the longname `foo(bar)`.\n * + `foo(bar, baz)` (where `baz` is repeatable) gets the variation `(bar, ...baz)` and the longname\n * `foo(bar, ...baz)`.\n *\n * You can then link to these functions with `{@link foo()}`, `{@link foo(bar)}`, and\n * `{@link foo(bar, ...baz)`. Note that the variation is based on the names of the function\n * parameters, _not_ their types.\n *\n * If you prefer to manually assign variations to certain functions, you can still do so with the\n * `@variation` tag. This plugin will not change these variations or add more variations for that\n * function, as long as the variations you've defined result in unique longnames.\n *\n * If an overloaded function includes multiple signatures with the same parameter names, the plugin\n * will assign numeric variations instead, starting at `(1)` and counting upwards.\n *\n * @module plugins/overloadHelper\n * @author Jeff Williams <jeffrey.l.williams@gmail.com>\n * @license Apache License 2.0\n */\n'use strict';\n\n// lookup table of function doclets by longname\nvar functionDoclets;\n\nfunction hasUniqueValues(obj) {\n    var isUnique = true;\n    var seen = [];\n    Object.keys(obj).forEach(function(key) {\n        if (seen.indexOf(obj[key]) !== -1) {\n            isUnique = false;\n        }\n\n        seen.push(obj[key]);\n    });\n\n    return isUnique;\n}\n\nfunction getParamNames(params) {\n    var names = [];\n\n    params.forEach(function(param) {\n        var name = param.name || '';\n        if (param.variable) {\n            name = '...' + name;\n        }\n        if (name !== '') {\n            names.push(name);\n        }\n    });\n\n    return names.length ? names.join(', ') : '';\n}\n\nfunction getParamVariation(doclet) {\n    return getParamNames(doclet.params || []);\n}\n\nfunction getUniqueVariations(doclets) {\n    var counter = 0;\n    var variations = {};\n    var docletKeys = Object.keys(doclets);\n\n    function getUniqueNumbers() {\n        var format = require('util').format;\n\n        docletKeys.forEach(function(doclet) {\n            var newLongname;\n\n            while (true) {\n                counter++;\n                variations[doclet] = String(counter);\n\n                // is this longname + variation unique?\n                newLongname = format('%s(%s)', doclets[doclet].longname, variations[doclet]);\n                if ( !functionDoclets[newLongname] ) {\n                    break;\n                }\n            }\n        });\n    }\n\n    function getUniqueNames() {\n        // start by trying to preserve existing variations\n        docletKeys.forEach(function(doclet) {\n            variations[doclet] = doclets[doclet].variation || getParamVariation(doclets[doclet]);\n        });\n\n        // if they're identical, try again, without preserving existing variations\n        if ( !hasUniqueValues(variations) ) {\n            docletKeys.forEach(function(doclet) {\n                variations[doclet] = getParamVariation(doclets[doclet]);\n            });\n\n            // if they're STILL identical, switch to numeric variations\n            if ( !hasUniqueValues(variations) ) {\n                getUniqueNumbers();\n            }\n        }\n    }\n\n    // are we already using numeric variations? if so, keep doing that\n    if (functionDoclets[doclets.newDoclet.longname + '(1)']) {\n        getUniqueNumbers();\n    }\n    else {\n        getUniqueNames();\n    }\n\n    return variations;\n}\n\nfunction ensureUniqueLongname(newDoclet) {\n    var doclets = {\n        oldDoclet: functionDoclets[newDoclet.longname],\n        newDoclet: newDoclet\n    };\n    var docletKeys = Object.keys(doclets);\n    var oldDocletLongname;\n    var variations = {};\n\n    if (doclets.oldDoclet) {\n        oldDocletLongname = doclets.oldDoclet.longname;\n        // if the shared longname has a variation, like MyClass#myLongname(variation),\n        // remove the variation\n        if (doclets.oldDoclet.variation || doclets.oldDoclet.variation === '') {\n            docletKeys.forEach(function(doclet) {\n                doclets[doclet].longname = doclets[doclet].longname.replace(/\\([\\s\\S]*\\)$/, '');\n                doclets[doclet].variation = null;\n            });\n        }\n\n        variations = getUniqueVariations(doclets);\n\n        // update the longnames/variations\n        docletKeys.forEach(function(doclet) {\n            doclets[doclet].longname += '(' + variations[doclet] + ')';\n            doclets[doclet].variation = variations[doclet];\n        });\n\n        // update the old doclet in the lookup table\n        functionDoclets[oldDocletLongname] = null;\n        functionDoclets[doclets.oldDoclet.longname] = doclets.oldDoclet;\n    }\n\n    // always store the new doclet in the lookup table\n    functionDoclets[doclets.newDoclet.longname] = doclets.newDoclet;\n\n    return doclets.newDoclet;\n}\n\nexports.handlers = {\n    parseBegin: function() {\n        functionDoclets = {};\n    },\n\n    newDoclet: function(e) {\n        if (e.doclet.kind === 'function') {\n            e.doclet = ensureUniqueLongname(e.doclet);\n        }\n    },\n\n    parseComplete: function() {\n        functionDoclets = null;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/third_party/jsdoc/plugins/partial.js":"/**\n    @overview Adds support for reusable partial jsdoc files.\n    @module plugins/partial\n    @author Ludo Antonov <ludo@hulu.com>\n */\n'use strict';\n\nvar fs = require('jsdoc/fs');\nvar path = require('path');\n\nexports.handlers = {\n    /**\n     * Include a partial jsdoc\n     *\n     * @param e\n     * @param e.filename\n     * @param e.source\n     * @example\n     *     @partial \"partial_doc.jsdoc\"\n     */\n    beforeParse: function(e) {\n        e.source = e.source.replace(/(@partial \\\".*\\\")+/g, function($) {\n            var pathArg = $.match(/\\\".*\\\"/)[0].replace(/\"/g,'');\n            var fullPath = path.join(e.filename , '..', pathArg);\n\n            var partialData = fs.readFileSync(fullPath, global.env.opts.encoding);\n\n            return partialData;\n        });\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/third_party/jsdoc/plugins/railsTemplate.js":"/**\n    @overview Strips the rails template tags from a js.erb file\n    @module plugins/railsTemplate\n    @author Jannon Frank <jannon@jannon.net>\n */\n'use strict';\n\nexports.handlers = {\n    /**\n     * Remove rails tags from the source input (e.g. <% foo bar %>)\n     * @param e\n     * @param e.filename\n     * @param e.source\n     */\n    beforeParse: function(e) {\n        if (e.filename.match(/\\.erb$/)) {\n            e.source = e.source.replace(/<%.*%>/g, '');\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/third_party/jsdoc/plugins/shout.js":"/**\n    @overview This is just an example.\n    @module plugins/shout\n    @author Michael Mathews <micmath@gmail.com>\n */\n'use strict';\n\nexports.handlers = {\n    /**\n        Make your descriptions more shoutier.\n     */\n    newDoclet: function(e) {\n        if (typeof e.doclet.description === 'string') {\n            e.doclet.description = e.doclet.description.toUpperCase();\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/third_party/jsdoc/plugins/sourcetag.js":"/**\n    @module plugins/sourcetag\n    @author Michael Mathews <micmath@gmail.com>\n */\n'use strict';\n\nvar logger = require('jsdoc/util/logger');\n\nexports.handlers = {\n    /**\n        Support @source tag. Expected value like:\n            { \"filename\": \"myfile.js\", \"lineno\": 123 }\n        Modifies the corresponding meta values on the given doclet.\n\n        WARNING: If you are using a JSDoc template that generates pretty-printed source files,\n        such as JSDoc's default template, this plugin can cause JSDoc to crash. To fix this issue,\n        update your template settings to disable pretty-printed source files.\n\n        @source { \"filename\": \"sourcetag.js\", \"lineno\": 13 }\n     */\n    newDoclet: function(e) {\n        var tags = e.doclet.tags,\n            tag,\n            value;\n\n        // any user-defined tags in this doclet?\n        if (typeof tags !== 'undefined') {\n            // only interested in the @source tags\n            tags = tags.filter(function($) {\n                return $.title === 'source';\n            });\n\n            if (tags.length) {\n                // take the first one\n                tag = tags[0];\n\n                try {\n                    value = JSON.parse(tag.value);\n                }\n                catch(e) {\n                    logger.error('@source tag expects a valid JSON value, like { \"filename\": \"myfile.js\", \"lineno\": 123 }.');\n                    return;\n                }\n\n                e.doclet.meta = e.doclet.meta || {};\n                e.doclet.meta.filename = value.filename || '';\n                e.doclet.meta.lineno = value.lineno || '';\n            }\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-shaka-player/node_modules/shaka-player/third_party/jsdoc/plugins/summarize.js":"/**\n * @overview This plugin creates a summary tag, if missing, from the first sentence in the\n * description.\n * @module plugins/summarize\n * @author Mads Bondo Dydensborg <mbd@dbc.dk>\n */\n'use strict';\n\nexports.handlers = {\n    /**\n     * Autogenerate summaries, if missing, from the description, if present.\n     */\n    newDoclet: function(e) {\n        var endTag;\n        var tags;\n        var stack;\n\n        // If the summary is missing, grab the first sentence from the description\n        // and use that.\n        if (e.doclet && !e.doclet.summary && e.doclet.description) {\n            // The summary may end with `.$`, `. `, or `.<` (a period followed by an HTML tag).\n            e.doclet.summary = e.doclet.description.split(/\\.$|\\.\\s|\\.</)[0];\n            // Append `.` as it was removed in both cases, or is possibly missing.\n            e.doclet.summary += '.';\n\n            // This is an excerpt of something that is possibly HTML.\n            // Balance it using a stack. Assume it was initially balanced.\n            tags = e.doclet.summary.match(/<[^>]+>/g) || [];\n            stack = [];\n\n            tags.forEach(function(tag) {\n                var idx = tag.indexOf('/');\n\n                if (idx === -1) {\n                    // start tag -- push onto the stack\n                    stack.push(tag);\n                } else if (idx === 1) {\n                    // end tag -- pop off of the stack\n                    stack.pop();\n                }\n\n                // otherwise, it's a self-closing tag; don't modify the stack\n            });\n\n            // stack should now contain only the start tags that lack end tags,\n            // with the most deeply nested start tag at the top\n            while (stack.length > 0) {\n                // pop the unmatched tag off the stack\n                endTag = stack.pop();\n                // get just the tag name\n                endTag = endTag.substring(1, endTag.search(/[ >]/));\n                // append the end tag\n                e.doclet.summary += '</' + endTag + '>';\n            }\n\n            // and, finally, if the summary starts and ends with a <p> tag, remove it; let the\n            // template decide whether to wrap the summary in a <p> tag\n            e.doclet.summary = e.doclet.summary.replace(/^<p>(.*)<\\/p>$/i, '$1');\n        }\n    }\n};\n"}